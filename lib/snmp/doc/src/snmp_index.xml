<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>1997</year><year>2016</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    
    </legalnotice>

    <title>snmp_index</title>
    <prepared></prepared>
    <responsible></responsible>
    <docno></docno>
    <approved></approved>
    <checked></checked>
    <date>2016-11-19</date>
    <rev></rev>
    <file>snmp_index.xml</file>
  </header>
  <module>snmp_index</module>
  <modulesummary>Abstract data type for SNMP indexing.</modulesummary>
  <description>
    <p>This module provides an Abstract Data Type (ADT) for an SNMP
      index structure for SNMP tables. It is implemented as an <c>ets</c>
      table of the <c>ordered_set</c> datatype, which means that all
      operations are O(log n). In the table, the key is an ASN.1 OBJECT
      IDENTIFIER.</p>
    <p>This index is used to separate the implementation of the SNMP
      ordering from the actual implementation of the table. The SNMP
      ordering, that is implementation of <c>GET NEXT</c>, is implemented
      in this module.</p>
    <p>For example, suppose there is an SNMP table, which is best
      implemented in Erlang as one process per SNMP table row. Suppose
      also that the INDEX in the SNMP table is an OCTET STRING. The
      index structure is then created as follows:</p>
    <code type="none">
snmp_index:new(string)</code>
    <p>For each new process we create, we insert an item in an
      <c>snmp_index</c> structure:</p>
    <code type="none"><![CDATA[
new_process(Name, SnmpIndex) ->
  Pid = start_process(),
  NewSnmpIndex = 
    snmp_index:insert(SnmpIndex, Name, Pid),
  <...>
    ]]></code>
    <p>With this structure, we can now map an OBJECT IDENTIFIER in,
      for example, a <c>GET NEXT</c> request, to the correct process:</p>
    <code type="none">
get_next_pid(Oid, SnmpIndex) ->
  {ok, {_, Pid}} = snmp_index:get_next(SnmpIndex, Oid),
  Pid.</code>
    <warning>
      <marker id="1"></marker>
      <p>All API functions that update the index return a <c>NewIndex</c>
        term. This is for backward compatibility with a previous
        implementation that used a B+ tree written purely in Erlang for
        the index. The <c>NewIndex</c> return value can now be ignored.
        The return value is now the unchanged table identifier for the
        <c>ets</c> table.</p>
      <p>The implementation using <c>ets</c> tables introduces a semantic
        incompatibility with older implementations. In those
        implementations, using pure Erlang terms, the index was garbage
        collected like any other Erlang term and did not have to be
        deleted when discarded. An <c>ets</c> table is deleted only when the
        process creating it explicitly deletes it or when the creating
        process terminates.</p>
      <p>A new interface,
        <seealso marker="#delete/1"><c>delete/1</c></seealso>, is now added
        to handle the case when a process wants to discard an index table
        (that is, to build a completely new). Any application using
        transient SNMP indexes must be modified to handle this.</p>
      <p>As an SNMP adaption usually keeps the index for the whole of the
        systems lifetime, this is rarely a problem.</p>
    </warning>
  </description>

  <datatypes>
    <datatype>
      <name name="index()"/>
      <desc>
        <p>An SNMP index structure.</p>
      </desc>
    </datatype>
    <datatype>
      <name name="key_types = type_spec()  |  {type_spec(), type_spec(), ...}"/>
      <desc>
        <p>Used when creating the index structure.</p>
        <p>Defines the types of the SNMP INDEX
          columns for the table. If the table has one single INDEX column,
          this type is to be a single atom. If the table has multiple
          INDEX columns, this type is to be a tuple with atoms.</p>
        <p>If the INDEX column is of type INTEGER, or derived from
          INTEGER, the corresponding type is to be <c>integer</c>. If it is a
          variable length type (for example, OBJECT IDENTIFIER, OCTET STRING),
          the corresponding type is to be <c>string</c>. If the
          type is of variable length, but with a fixed size restriction
          (for example, IpAddress), the corresponding type is to be
          <c>fix_string</c>.</p>
        <p>For example, if the SNMP table has two INDEX columns, the first
          one an OCTET STRING with size 2, and the second one an OBJECT
          IDENTIFER, the corresponding <c>key_types</c> parameter is
          <c>{fix_string, string}</c>.</p>
      </desc>
    </datatype>
    <datatype>
      <name name="key() = key_spec() | {key_spec(), key_spec(), ...}"/>
      <desc>
        <p>Used when inserting and deleting items from the structure.</p>
        <p>Correlates to the <c>key_types()</c> type.
          If the <c>key_types()</c> is a single atom, the
          corresponding <c>key()</c> is a single type as well, but if the
          <c>key_types()</c> is a tuple, <c>key</c> must be a tuple of the
          same size.</p>
        <p>In the example above, valid <c>keys</c> can be <c>{"hi", "mom"}</c>
          and <c>{"no", "thanks"}</c>, whereas <c>"hi"</c>,
          <c>{"hi", 42}</c>, and <c>{"hello", "there"}</c> are invalid.</p>
      </desc>
    </datatype>
    <datatype>
      <name name="key_spec() = string() | integer()"/>
    </datatype>
    <datatype>
      <name name="oid() = [byte()]"/>
      <desc>
        <p>Represents an ASN.1 OBJECT IDENTIFIER.</p>
      </desc>
    </datatype>
    <datatype>
      <name name="type_spec() = fix_string | string | integer"/>
    </datatype>
  </datatypes>

  <funcs>
    <func>
      <name>delete(Index) -> true</name>
      <fsummary>Delete an index table.</fsummary>
      <type>
        <v>Index = NewIndex = index()</v>
        <v>Key = key()</v>
      </type>
      <desc>
        <p>Deletes a complete index structure (that is, the <c>ets</c> table
          holding the index). The index can no longer be referenced
          after this call. See the <seealso marker="#1">warning note</seealso>
          above.</p>
      </desc>
    </func>

    <func>
      <name>delete(Index, Key) -> NewIndex</name>
      <fsummary>Delete an item from the index.</fsummary>
      <type>
        <v>Index = NewIndex = index()</v>
        <v>Key = key()</v>
      </type>
      <desc>
        <p>Deletes a key and its value from the index structure.
          Returns a new structure.</p>
      </desc>
    </func>

    <func>
      <name>get(Index, KeyOid) -> {ok, {KeyOid, Value}} | undefined</name>
      <fsummary>Get the item with <c>KeyOid</c>.</fsummary>
      <type>
        <v>Index = index()</v>
        <v>KeyOid = oid()</v>
        <v>Value = term()</v>
      </type>
      <desc>
        <p>Gets the item with key <c>KeyOid</c>. Can be used from
          within an SNMP instrumentation function.</p>
      </desc>
    </func>

    <func>
      <name>get_last(Index) -> {ok, {KeyOid, Value}} | undefined</name>
      <fsummary>Get the last item in the index structure.</fsummary>
      <type>
        <v>Index = index()</v>
        <v>KeyOid = oid()</v>
        <v>Value = term()</v>
      </type>
      <desc>
        <p>Gets the last item in the index structure.</p>
      </desc>
    </func>

    <func>
      <name>get_next(Index, KeyOid) -> {ok, {NextKeyOid, Value}} | undefined
      </name>
      <fsummary>Get the next item.</fsummary>
      <type>
        <v>Index = index()</v>
        <v>KeyOid = NextKeyOid = oid()</v>
        <v>Value = term()</v>
      </type>
      <desc>
        <p>Gets the next item in the SNMP lexicographic ordering,
          after <c>KeyOid</c> in the index structure. <c>KeyOid</c>
          does not have to refer to an existing item in the index.</p>
      </desc>
    </func>

    <func>
      <name>insert(Index, Key, Value) -> NewIndex</name>
      <fsummary>Insert an item into the index.</fsummary>
      <type>
        <v>Index = NewIndex = index()</v>
        <v>Key = key()</v>
        <v>Value = term()</v>
      </type>
      <desc>
        <p>Inserts a new key value tuple into the index structure. If
          an item with the same key already exists, the new <c>Value</c>
          overwrites the old value.</p>
      </desc>
    </func>

    <func>
      <name>key_to_oid(Index, Key) -> KeyOid</name>
      <fsummary>Convert a key to an OBJECT IDENTIFIER.</fsummary>
      <type>
        <v>Index = index()</v>
        <v>Key = key()</v>
        <v>KeyOid = NextKeyOid = oid()</v>
      </type>
      <desc>
        <p>Converts <c>Key</c> to an OBJECT IDENTIFIER.</p>
      </desc>
    </func>

    <func>
      <name>new(KeyTypes) -> Index</name>
      <fsummary>Create a new SNMP index structure.</fsummary>
      <type>
        <v>KeyTypes = key_types()</v>
        <v>Index = index()</v>
      </type>
      <desc>
        <p>Creates a new SNMP index structure.</p>
      </desc>
    </func>
  </funcs>
  
</erlref>

