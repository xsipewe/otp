<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>1996</year><year>2016</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    
    </legalnotice>

    <title>snmp</title>
    <prepared></prepared>
    <responsible></responsible>
    <docno></docno>
    <approved></approved>
    <checked></checked>
    <date>2016-11-18</date>
    <rev></rev>
    <file>snmp.xml</file>
  </header>
  <module>snmp</module>
  <modulesummary>Interface functions to the SNMP toolkit.</modulesummary>
  <description>
    <p>This module contains interface functions to the SNMP toolkit.</p>
  </description>

  <datatypes>
    <datatype>
      <name name="datetime() = {date(), time()}"/>
      <desc>
        <p>For more information, see the <seealso marker="stdlib:calendar">
          <c>stdlib:calendar</c></seealso> module.</p>
        <marker id="config"></marker>
      </desc>
    </datatype>
  </datatypes>

  <funcs>
    <func>
      <name>config() -> ok | {error, Reason}</name>
      <fsummary>Configure with a simple interactive tool.</fsummary>
      <desc>
        <p>A simple interactive configuration tool. Simple
          configuration files can be generated, but more complex
          configurations still must be edited manually.</p>
        <p>The tool is a textual-based tool that asks some questions
          and generates <c>sys.config</c> and <c>*.conf</c> files.</p>
        <p>Notice that if the application is to support version 3,
          the Crypto application must be started before running this function
          (password generation).</p>
        <p>Notice that some of the configuration files for the
          agent and manager share the same names. They must
          therefore be stored in <em>different</em> directories.</p>
        <marker id="start"></marker>
      </desc>
    </func>

    <func>
      <name>start() -> ok | {error, Reason}</name>
      <name>start(Type) -> ok | {error, Reason}</name>
      <fsummary>Start the SNMP application.</fsummary>
      <type>
        <v>Type = start_type()</v>
      </type>
      <desc>
        <p>Starts the SNMP application.</p>
        <p>For more information, see <seealso marker="kernel:application">
          <c>kernel:application</c></seealso>.</p>
        <marker id="start_agent"></marker>
      </desc>
    </func>

    <func>
      <name>start_agent() -> ok | {error, Reason}</name>
      <name>start_agent(Type) -> ok | {error, Reason}</name>
      <fsummary>Start the agent part of the SNMP application.</fsummary>
      <type>
        <v>Type = start_type()</v>
      </type>
      <desc>
        <p>Starts the agent entity of the application. The SNMP application
          consists of several entities, of which the agent is one.</p>
        <p>Notice that the only way to start the agent in this way is to add
          the agent-related config after starting the application (for
          example, it cannot be part of the normal application config;
          <c>sys.config</c>). This is done by calling
          <c>application:set_env(snmp, agent, Conf)</c>.</p>
        <p><c>Type</c> defaults to <c>normal</c>.</p>
	<marker id="start_manager"></marker>
      </desc>
    </func>

    <func>
      <name>start_manager() -> ok | {error, Reason}</name>
      <name>start_manager(Type) -> ok | {error, Reason}</name>
      <fsummary>Start the manager part of the SNMP application.</fsummary>
      <type>
        <v>Type = start_type()</v>
      </type>
      <desc>
        <p>Starts the manager entity of the application. The SNMP application
          consists of several entities, of which the manager is one.</p>
        <p>Notice that the only way to start the manager in this way is to add
          the manager-related config after starting the application (for
          example, it cannot be part of the normal application config;
          <c>sys.config</c>). This is done by calling
          <c>application:set_env(snmp, manager, Conf)</c>.</p>
        <p><c>Type</c> defaults to <c>normal</c>.</p>
        <marker id="dat"></marker>
      </desc>
    </func>

    <func>
      <name>date_and_time() -> DateAndTime</name>
      <fsummary>Return the current date and time as an OCTET STRING.</fsummary>
      <type>
        <v>DateAndTime = [int()]</v>
      </type>
      <desc>
        <p>Returns the current date and time as the data type
          <c>DateAndTime</c>, as specified in RFC 1903.
          This is an OCTET STRING.</p>
	<marker id="dat2ut_dst"></marker>
      </desc>
    </func>

    <func>
      <name>date_and_time_to_universal_time_dst(DateAndTime) -> [utc()]</name>
      <fsummary>Convert a DateAndTime value to a list of possible utc().
      </fsummary>
      <type>
        <v>DateAndTime = [int()]</v>
        <v>utc() = {{Y,Mo,D},{H,M,S}}</v>
      </type>
      <desc>
        <p>Converts a <c>DateAndTime</c> list to a list of possible universal
          time(s). The universal time value has the same format as defined in
          <seealso marker="stdlib:calendar">
          <c>stdlib:calendar(3)</c></seealso>.</p>
	<marker id="dat2s"></marker>
      </desc>
    </func>

    <func>
      <name>date_and_time_to_string(DateAndTime) -> string()</name>
      <name>date_and_time_to_string(DateAndTime, Validate) -> string()</name>
      <fsummary>Convert a DateAndTime value to a string.</fsummary>
      <type>
        <v>DateAndTime = [int()]</v>
	<v>Validate = fun(Kind, Data) -> boolean()</v>
      </type>
      <desc>
        <p>Converts a <c>DateAndTime</c> list to a printable string, according
          to the DISPLAY-HINT definition in RFC 2579.</p>
        <p>The validation fun, <c>Validate</c>, allows for a more "flexible"
          validation of argument <c>DateAndTime</c>. Whenever the data
          is found not to follow RFC 2579, the fun is called to allow a more
          "lax" validation. For more information on the <c>Validate</c> fun,
          see <seealso marker="#vdat">
          <c>validate_date_and_time/2</c></seealso>.</p>
	<marker id="dat2s2"></marker>
      </desc>
    </func>

    <func>
      <name>date_and_time_to_string2(DateAndTime) -> string()</name>
      <fsummary>Convert a DateAndTime value to a string.</fsummary>
      <type>
        <v>DateAndTime = [int()]</v>
      </type>
      <desc>
	<p>Converts a <c>DateAndTime</c> list to a printable string, according
	  to the DISPLAY-HINT definition in RFC 2579, with the extension
          that it also allows the values "hours from UTC" = 14 together with
          "minutes from UTC" = 0.</p>
	<marker id="lt2dat_dst"></marker>
      </desc>
    </func>

    <func>
      <name>local_time_to_date_and_time_dst(Local) -> [DateAndTime]</name>
      <fsummary>Convert a local time value to a list of possible
        DateAndTime(s).</fsummary>
      <type>
        <v>Local = {{Y,Mo,D},{H,M,S}}</v>
        <v>DateAndTime = [int()]</v>
      </type>
      <desc>
        <p>Converts a local time value to a list of possible <c>DateAndTime</c> 
          list(s). The local time value has the same format as defined in
          <seealso marker="stdlib:calendar">
          <c>stdlib:calendar(3)</c></seealso>.</p>
	<marker id="ut2dat"></marker>
      </desc>
    </func>

    <func>
      <name>universal_time_to_date_and_time(UTC) -> DateAndTime</name>
      <fsummary>Convert a UTC value to DateAndTime.</fsummary>
      <type>
        <v>UTC = {{Y,Mo,D},{H,M,S}}</v>
        <v>DateAndTime = [int()]</v>
      </type>
      <desc>
        <p>Converts a universal time value to a <c>DateAndTime</c> list. The
          universal time value has the same format as defined in
          <seealso marker="stdlib:calendar">
          <c>stdlib:calendar(3)</c></seealso>.</p>
        <marker id="vdat"></marker>
      </desc>
    </func>

    <func>
      <name>validate_date_and_time(DateAndTime) -> bool()</name>
      <name>validate_date_and_time(DateAndTime, Validate) -> bool()</name>
      <fsummary>Check if a DateAndTime value is correct.</fsummary>
      <type>
        <v>DateAndTime = term()</v>
	<v>Validate = fun(Kind, Data) -> boolean()</v>
      </type>
      <desc>
        <p>Checks if <c>DateAndTime</c> is a correct <c>DateAndTime</c>
          value, as specified in RFC 2579. This function can be used in
          instrumentation functions to validate a <c>DateAndTime</c> value.</p>
        <p>The validation fun, <c>Validate</c>, allows for a more "flexible"
          validation of argument <c>DateAndTime</c>. Whenever the data
          is found not to follow RFC 2579, the fun is called to allow a more
          "lax" validation.
          The input to the validation fun looks as follows:</p>
        <pre>
Kind             Data
--------------   ----------------------
year             {Year1, Year2}
month            Month
day              Day
hour             Hour
minute           Minute
seconds          Seconds
deci_seconds     DeciSeconds
diff             [Sign, Hour, Minute]
valid_date       {Year, Month, Day}</pre>
        <marker id="passwd2localized_key"></marker>
      </desc>
    </func>

    <func>
      <name>passwd2localized_key(Alg, Passwd, EngineID) -> Key</name>
      <fsummary>Generate a localized key.</fsummary>
      <type>
        <v>Alg = algorithm()</v>
        <v>algorithm() = md5 | sha</v>
        <v>Passwd = string()</v>
        <v>EngineID = string()</v>
        <v>Key = list()</v>
      </type>
      <desc>
        <p>Generates a key that can be used as an authentication
          or privacy key using MD5 and SHA. The key is
          localized for EngineID.</p>
        <marker id="octet_string_to_bits"></marker>
      </desc>
    </func>

    <func>
      <name>octet_string_to_bits(S) -> Val</name>
      <fsummary>Convert an OCTET-STRING to BITS.</fsummary>
      <type>
        <v>Val = bits()</v>
      </type>
      <desc>
        <p>Converts a value of type <c>OCTET-STRING</c> to <c>BITS</c>.</p>
        <marker id="bits_to_octet_string"></marker>
      </desc>
    </func>

    <func>
      <name>bits_to_octet_string(B) -> Val</name>
      <fsummary>Convert an OCTET-STRING to BITS.</fsummary>
      <type>
        <v>Val = octet_string()</v>
      </type>
      <desc>
        <p>Converts a value of type <c>BITS</c> to <c>OCTET-STRING</c>.</p>
        <marker id="read_mib"></marker>
      </desc>
    </func>

    <func>
      <name>read_mib(FileName) -> {ok, mib()} | {error, Reason}</name>
      <fsummary>Read a compiled MIB.</fsummary>
      <type>
        <v>FileName = string()</v>
        <v>mib() = #mib{}</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Reads a compiled MIB.</p>
        <marker id="log_to_txt"></marker>
      </desc>
    </func>

    <func>
      <name>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile) ->
        ok | {error, Reason}</name>
      <name>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile,
        Block | Start) -> ok | {error, Reason}</name>
      <name>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile,
        Start, Block | Stop) -> ok | {error, Reason}</name>
      <name>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile,
        Start, Stop, Block) -> ok | {error, Reason}</name>
      <fsummary>Convert an audit trail log to text format.</fsummary>
      <type>
        <v>LogDir = string()</v>
        <v>Mibs = [MibName]</v>
        <v>OutFile = string()</v>
        <v>MibName = string()</v>
        <v>LogName = string()</v>
        <v>LogFile = string()</v>
        <v>Start = Stop = null | datetime() | {local_time,datetime()} |
          {universal_time,datetime()}</v>
        <v>Block = boolean()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Converts an audit trail log to a readable text file, where
          each item has a trailing TAB character, and any TAB
          character in the body of an item has been replaced by ESC TAB.</p>
        <p>The function can be used on a running system, or by copying
          the entire log directory and calling this function. SNMP
          must be running to provide MIB information.</p>
        <list type="bulleted">
          <item><c>LogDir</c> is the name of the directory where the audit
            trail log is stored.</item>
          <item><c>Mibs</c> is a list of MIBs to be used. The function uses
            the information in the MIBs to convert, for example, object
            identifiers to their symbolic name.</item>
          <item><c>OutFile</c> is the name of the generated text file.</item>
          <item><c>LogName</c> is the name of the log.</item>
          <item><c>LogFile</c> is the name of the log file.</item>
          <item><c>Start</c> is the start (first) date and time from which
            log events will be converted.</item>
          <item><c>Stop</c> is the stop (last) date and time to which log
            events will be converted.</item>
          <item><c>Block</c> indicates if the log is to be blocked
            during conversion. This can be useful when converting large
            logs (when otherwise the log can wrap during conversion).
            Defaults to <c>true</c>.</item>
        </list>
        <p>The format of an audit trail log text item is as follows:</p>
        <pre>
Tag Addr - Community [TimeStamp] Vsn
PDU</pre>
	<p>where:</p>
        <list type="bulleted">
          <item><c>Tag</c> is <c>request</c>, <c>response</c>,
	    <c>report</c>, <c>trap</c>, or <c>inform</c>.</item>
          <item><c>Addr</c> is <c>IP:Port</c> (or comma-space-separated list
            of such).</item>
          <item><c>Community</c> is the community parameter (SNMPv1 and SNMPv2)
            or <c>SecLevel:"AuthEngineID":"UserName"</c> (SNMP v3).</item>
          <item><c>TimeStamp</c> is a date and time stamp.</item>
          <item><c>Vsn</c> is the SNMP version.</item>
          <item><c>PDU</c> is a textual version of the protocol data unit.
            There is a new line between <c>Vsn</c> and <c>PDU</c>.</item>
        </list>
        <marker id="log_to_io"></marker>
      </desc>
    </func>

    <func>
      <name>log_to_io(LogDir, Mibs, LogName, LogFile) ->
        ok | {error, Reason}</name>
      <name>log_to_io(LogDir, Mibs, LogName, LogFile, Block | Start) ->
        ok | {error, Reason}</name>
      <name>log_to_io(LogDir, Mibs, LogName, LogFile, Start, Block | Stop) ->
        ok | {error, Reason}</name>
      <name>log_to_io(LogDir, Mibs, LogName, LogFile, Start, Stop, Block) ->
        ok | {error, Reason}</name>
      <fsummary>Convert an audit trail log to text format.</fsummary>
      <type>
        <v>LogDir = string()</v>
        <v>Mibs = [MibName]</v>
        <v>MibName = string()</v>
        <v>LogName = string()</v>
        <v>LogFile = string()</v>
        <v>Start = Stop = null | datetime() | {local_time,datetime()} |
          {universal_time,datetime()}</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Converts an audit trail log to a readable format and 
	  prints it on stdio. For more information, see
	  <seealso marker="snmp#log_to_txt">log_to_txt</seealso>.</p>
        <marker id="change_log_size"></marker>
      </desc>
    </func>

    <func>
      <name>change_log_size(LogName, NewSize) -> ok | {error, Reason}</name>
      <fsummary>Change the size of the audit trail log.</fsummary>
      <type>
        <v>LogName = string()</v>
        <v>NewSize = {MaxBytes, MaxFiles}</v>
        <v>MaxBytes = integer()</v>
        <v>MaxFiles = integer()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Changes the log size of the audit trail log. The
          application must be configured to use the audit trail log function.
          For a description of how to change the log size, see
          <seealso marker="kernel:disk_log">
          <c>kernel:disk_log(3)</c></seealso>.</p>
        <p>The change is permanent, as long as the log is not deleted,
          that is, the log size is remembered across reboots.</p>
	<marker id="print_version_info"></marker>
      </desc>
    </func>

    <func>
      <name>print_version_info() -> void()</name>
      <name>print_version_info(Prefix) -> void()</name>
      <fsummary>Formatted print of result of the versions functions.</fsummary>
      <type>
        <v>Prefix = string() | integer()</v>
      </type>
      <desc>
        <p>Produces a formatted printout of the versions
          information generated by the
          <seealso marker="#versions1"><c>versions1</c></seealso> function.
          This is the same as, for example:</p>
        <pre>
{ok, V} = snmp:versions1(),
snmp:print_versions(V).</pre>
	<marker id="versions1"></marker>
	<marker id="versions2"></marker>
      </desc>
    </func>

    <func>
      <name>versions1() -> {ok, Info} | {error, Reason}</name>
      <name>versions2() -> {ok, Info} | {error, Reason}</name>
      <fsummary>Retrieve various system and application information.</fsummary>
      <type>
        <v>Info = [info()]</v>
        <v>info() = term()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Retrieves some system and application information.</p>
        <p>The difference between the two functions is in how they get
          the modules to check. <c>versions1</c> uses the application file and
          <c>versions2</c> uses the <c>application:get_key</c> function.</p>
        <marker id="print_versions"></marker>
      </desc>
    </func>

    <func>
      <name>print_versions(VersionInfo) -> void()</name>
      <name>print_versions(Prefix, VersionInfo) -> void()</name>
      <fsummary>Formatted print of result of the versions functions.</fsummary>
      <type>
        <v>VersionInfo = [version_info()]</v>
        <v>version_info() = term()</v>
        <v>Prefix = string() | integer()</v>
      </type>
      <desc>
        <p>Produces a formatted printout of the versions information
          generated by the
          <seealso marker="#versions1"><c>versions1</c></seealso> and
          <seealso marker="#versions2"><c>versions2</c></seealso>
          functions.</p>
        <p>Example:</p>
        <pre>
{ok, V} = snmp:versions1(), 
snmp:print_versions(V).</pre>
        <marker id="enable_trace"></marker>
      </desc>
    </func>

    <func>
      <name>enable_trace() -> void()</name>
      <fsummary>Starts a tracer.</fsummary>
      <!--
      <type>
        <v>Prefix = string() | integer()</v>
      </type>
      -->
      <desc>
        <p>Starts a dbg tracer that prints trace events to stdout (using
          <c>plain io:format</c> after a minor formatting).</p>
        <marker id="disable_trace"></marker>
      </desc>
    </func>

    <func>
      <name>disable_trace() -> void()</name>
      <fsummary>Stop the tracer.</fsummary>
      <!--
      <type>
        <v>Prefix = string() | integer()</v>
      </type>
      -->
      <desc>
        <p>Stops the tracer.</p>
        <marker id="set_trace1"></marker>
      </desc>
    </func>

    <func>
      <name>set_trace(Targets) -> void()</name>
      <fsummary>Set trace target.</fsummary>
      <type>
        <v>Targets = target() | targets()</v>
        <v>target() = module()</v>
        <v>module() = atom()</v>
        <v>targets() = [target() | {target(), target_options()}]</v>
        <v>target_options() = [target_option()]</v>
        <v>target_option() = {return_trace, boolean()} | {scope, scope()}</v>
        <v>scope() = all_functions | exported_functions | function_name() |
          {function_name(), function_arity()}</v>
        <v>function_name() = atom()</v>
        <v>function_arity() = integer() >= 0</v>
      </type>
      <desc>
        <p>Sets up default trace on function(s)
          for the specified module or modules. The scope of the trace is
          all <em>exported</em> functions (both the call information and
          the return value). Time-stamp information is also included.</p>
        <marker id="reset_trace"></marker>
      </desc>
    </func>

    <func>
      <name>reset_trace(Targets) -> void()</name>
      <fsummary>Reset trace target.</fsummary>
      <type>
        <v>Targets = module() | modules()</v>
        <v>modules() = [module()]</v>
        <v>module() = atom()</v>
      </type>
      <desc>
        <p>Resets (disables) trace for the specified module(s).</p>
	<marker id="set_trace2"></marker>
      </desc>
    </func>

    <func>
      <name>set_trace(Targets, Opts) -> void()</name>
      <fsummary>Set trace target.</fsummary>
      <type>
        <v>Targets = target() | targets()</v>
        <v>target() = module()</v>
        <v>module() = atom()</v>
        <v>targets() = [target() | {target(), target_options()}]</v>
        <v>target_options() = [target_option()]</v>
        <v>target_option() = {return_trace, boolean()} | {scope, scope()}</v>
        <v>scope() = all_functions | exported_functions | function_name() |
          {function_name(), function_arity()}</v>
        <v>function_name() = atom()</v>
        <v>function_arity() = integer() >= 0</v>
        <v>Opts = disable | trace_options()</v>
        <v>trace_options() = [trace_option()]</v>
        <v>trace_option() = {timestamp, boolean()} | target_option()</v>
      </type>
      <desc>
        <p>Sets up trace on function(s) for the specified module or modules.</p>
	<p>The following example sets up trace on the exported functions
          (default) of module <c>snmp_generic</c> and all functions of module
	  <c>snmp_generic_mnesia</c>. With return values (which is default)
          and time stamps in both cases (which is also default).</p>
	<pre>
snmp:enable_trace(),
snmp:set_trace([snmp_generic, {snmp_generic_mnesia, [{scope, all_functions}]}]),
.
.
.
snmp:set_trace(snmp_generic, disable),
.
.
.
snmp:disable_trace(),</pre>
      </desc>
    </func>
  </funcs>

  <section>
    <title>See Also</title>
    <p><seealso marker="stdlib:calendar"><c>stdlib:calendar(3)</c></seealso></p>
  </section>
  
</erlref>

