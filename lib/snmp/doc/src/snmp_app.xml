<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE appref SYSTEM "appref.dtd">

<appref>
  <header>
    <copyright>
      <year>1997</year><year>2016</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.

    </legalnotice>

    <title>snmp</title>
    <prepared></prepared>
    <responsible></responsible>
    <docno></docno>
    <approved></approved>
    <checked></checked>
    <date>2016-11-21</date>
    <rev></rev>
    <file>snmp.xml</file>
  </header>
  <app>snmp</app>
  <appsummary>The SNMP application.</appsummary>
  <description>
    <p>This section describes the SNMP application, which
      provides the following services:</p>
    <list type="bulleted">
      <item>A multilingual extensible SNMP agent</item>
      <item>An SNMP manager</item>
      <item>A MIB compiler</item>
    </list>
  </description>

  <section>
    <marker id="configuration_params"></marker>
    <title>Configuration</title>
    <p>The following configuration parameters are defined for the SNMP
      application. For more information about configuration parameters, see
      <seealso marker="kernel:application">
      <c>kernel:application(3)</c></seealso>.</p>
    <p>The SNMP part of the configuration file specifying the configuration
      parameters is basically the following tuple:</p>
    <pre>
{snmp, snmp_components_config()}</pre>
    <p>The following ia a minimal configuration file for starting a node
      with both a manager and an agent:</p>
    <pre>
[{snmp, 
  [{agent, [{db_dir, "/tmp/snmp/agent/db"},
            {config, [{dir, "/tmp/snmp/agent/conf"}]}]},
   {manager, [{config, [{dir, "/tmp/snmp/manager/conf"},
                        {db_dir, "/tmp/snmp/manager/db"}]}]}]}
  ]
 }
].</pre>

    <!-- 
	 ********************************************************

	 The info below is also found in the snmp_config.xml file 

	 ********************************************************
    -->

    <p>Each SNMP component has its own set of configuration parameters,
      although some of the types are common to both components.</p>

    <pre>
snmp_components_config() -> [snmp_component_config()]
snmp_component_config() -> {agent, agent_options()} | {manager, manager_options()}
agent_options() = [agent_option()]
agent_option() = {config,           agent_config()}     |
                 {discovery,        agent_discovery()}  |
                 {net_if,           agent_net_if()}     |
                 {agent_type,       agent_type()}       |
                 {audit_trail_log,  audit_trail_log()}  |
                 {db_dir,           db_dir()}           |
                 {db_init_error,    db_init_error()}    |
                 {error_report_mod, error_report_mod()} |
                 {gb_max_vbs,       gb_max_vbs()}       |
                 {local_db,         local_db()}         |
                 {mib_server,       mib_server()}       |
                 {mib_storage,      mib_storage()}      |
                 {mibs,             mibs()}             |
                 {multi_threaded,   multi_threaded()}   |
                 {note_store,       note_store()}       |
                 {priority,         priority()}         |
                 {restart_type,     restart_type()}     |
                 {symbolic_store,   symbolic_store()}   |
                 {target_cache,     target_cache()}     |
                 {agent_verbosity,  verbosity()}        |
                 {versions,         versions()}
manager_options() = [manager_option()]
manager_option() = {audit_trail_log,          audit_trail_log()} |
                   {def_user_data,            def_user_data()}   |
                   {def_user_mod,             def_user_module()  |
                   {config,                   manager_config()}  |
                   {inform_request_behaviour, manager_irb()}     |
                   {mibs,                     manager_mibs()}    |
                   {net_if,                   manager_net_if()}  |
                   {note_store,               note_store()}      |
                   {priority,                 priority()}        |
                   {restart_type,             restart_type()}    |
                   {server,                   server()}          |
                   {versions,                 versions()}</pre>

    <marker id="agent_opts_and_types"></marker>
    <p><em>Agent-Specific Configuration Options and Types</em></p>
    <taglist>
      <tag><marker id="agent_ldb_auto_save"></marker>
        <c><![CDATA[agent_auto_save() =
        integer() | infinity <optional>]]></c></tag>
      <item>
        <p>The auto save interval. The table is flushed to disk
          whenever not accessed for this amount of time.</p>
        <p>Defaults to <c>5000</c>.</p>
      </item>

      <tag><marker id="agent_config"></marker>
        <c><![CDATA[agent_config() =
        [agent_config_opt()] <mandatory>]]></c></tag>
      <item>
        <p><c>agent_config_opt() = {dir, agent_config_dir()} |
          {force_load, force_load()} | {verbosity, verbosity()}</c></p>
        <p>Defines specific configuration-related options for the SNMP
          agent.</p>
        <p>For defaults, see the options in <c>agent_config_opt()</c>.</p>
      </item>

      <tag><marker id="agent_config_dir"></marker>
        <c><![CDATA[agent_config_dir = dir() <mandatory>]]></c></tag>
      <item>
        <p>Defines where the SNMP agent configuration files are stored.</p>
      </item>

      <tag><marker id="agent_disco"></marker>
        <c><![CDATA[agent_discovery() =
        [agent_discovery_opt()] <optional>]]></c></tag>
      <item>
        <p><c>agent_discovery_opt() =
          {terminating, agent_terminating_discovery_opts()} |
          {originating, agent_originating_discovery_opts()}</c></p>
        <p>The <c>terminating</c> options effects discovery initiated by
          a manager.</p>
        <p>The <c>originating</c> options effects discovery initiated
          by this agent.</p>
        <p>For defaults, see the options in <c>agent_discovery_opt()</c>.</p>
      </item>

      <tag><marker id="agent_mibs"></marker>
        <c><![CDATA[agent_mibs() = [string()] <optional>]]></c></tag>
      <item>
        <p>Specifies a list of MIBs (including path) that defines which MIBs
          are initially loaded into the SNMP master agent.</p>
        <p>The following are always loaded:</p>
        <list type="bulleted">
          <item>Version v1: <c>STANDARD-MIB</c></item>
          <item>Version v2: <c>SNMPv2</c></item>
          <item>Version v3: <c>SNMPv2</c>, <c>SNMP-FRAMEWORK-MIB</c>, 
           and <c>SNMP-MPD-MIB</c></item>
        </list>
        <p>Defaults to <c>[]</c>.</p>
      </item>

      <tag><marker id="agent_net_if"></marker>
        <c><![CDATA[agent_net_if() =
        [agent_net_if_opt()] <optional>]]></c></tag>
      <item>
        <p><c>agent_net_if_option() = {module, agent_net_if_module()} |
            {verbosity, verbosity()} |
            {options, agent_net_if_options()}</c></p>
        <p>Defines options specific for the SNMP agent network interface
          entity.</p>
        <p>For defaults, see the options in <c>agent_net_if_opt()</c>.</p>
      </item>

      <tag><marker id="agent_ni_filter_module"></marker>
        <c><![CDATA[agent_net_if_filter_module() =
         atom() <optional>]]></c></tag>
      <item>
	<p>Module that handles the network interface filter part for the
	  SNMP agent. Must implement the
	  <seealso marker="snmpa_network_interface_filter">
          <c>snmpa_network_interface_filter</c></seealso> behavior.</p>
	<p>Defaults to <c>snmpa_net_if_filter</c>.</p>
      </item>

      <tag><marker id="agent_ni_filter_opts"></marker>
        <c><![CDATA[agent_net_if_filter_options() =
        [agent_net_if_filter_option()] <optional>]]></c></tag>
      <item>
	<p><c><![CDATA[agent_net_if_filter_option() =
          {module, agent_net_if_filter_module()}]]></c></p>
	<p>These options are specific to the used module.
	  The ones shown here are applicable to the default
	  <c>agent_net_if_filter_module()</c>.</p>
	<p>For defaults, see the options in
          <c>agent_net_if_filter_option()</c>.</p>
      </item>

      <tag><marker id="agent_ni_module"></marker>
        <c><![CDATA[agent_net_if_module() = atom() <optional>]]></c></tag>
      <item>
        <p>Module that handles the network interface part for the
          SNMP agent. Must implement the
          <seealso marker="snmpa_network_interface">
          <c>snmpa_network_interface</c></seealso> behavior.</p>
        <p>Defaults to <c>snmpa_net_if</c>.</p>
      </item>

      <tag><marker id="agent_ni_opts"></marker>
        <c><![CDATA[agent_net_if_options() =
        [agent_net_if_option()] <optional>]]></c></tag>
      <item>
        <p><c>agent_net_if_option() = {bind_to, bind_to()} |
            {sndbuf, sndbuf()} |
            {recbuf, recbuf()} |
            {no_reuse, no_reuse()} |
	    {req_limit, req_limit()} |
            {filter, agent_net_if_filter_options()}</c></p>
        <p>These options are specific to the used module.
          The ones shown here are applicable to the default
          <c>agent_net_if_module()</c>.</p>
        <p>For defaults, see the options in <c>agent_net_if_option()</c>.</p>
      </item>

      <tag><marker id="agent_orig_disco_opts"></marker>
        <c><![CDATA[agent_originating_discovery_opts() =
        [agent_originating_discovery_opt()] <optional>]]></c></tag>
      <item>
        <p><c>agent_originating_discovery_opt() = {enable, boolean()}</c></p>
        <p>Options effecting discovery <c>originating</c> in this agent.</p>
        <p>Default value for the <c>originating</c> discovery option:</p>
        <list type="bulleted">
          <item><c>enable</c>: <c>true</c></item>
        </list>
      </item>

      <tag><marker id="agent_ldb_repair"></marker>
        <c><![CDATA[agent_repair() =
        false | true | force <optional>]]></c></tag>
      <item>
        <p>When starting
          <seealso marker="snmpa_local_db"> <c>snmpa_local_db</c></seealso>,
          it always tries to open an
          existing database. If <c>false</c>, and some errors occur, a new
          database is created instead. If <c>true</c>, an existing file
          is repaired. If <c>force</c>, the table is repaired
          even if it was properly closed.</p>
        <p>Defaults to <c>true</c>.</p>
      </item>

      <tag><marker id="agent_term_disco_opts"></marker>
        <c><![CDATA[agent_terminating_discovery_opts() =
        [agent_terminating_discovery_opt()] <optional>]]></c></tag>
      <item>
        <p><c>agent_terminating_discovery_opt() =
          {enable, boolean()} |
          {stage2, discovery | plain} |
          {trigger_username, string()}</c></p>
        <p>Options effecting discovery <c>terminating</c> in this
          agent (that is, initiated by a manager).</p>
        <p>Default values for the <c>terminating</c> discovery options:</p>
        <list type="bulleted">
          <item><c>enable</c>: <c>true</c></item>
          <item><c>stage2</c>: <c>discovery</c></item>
          <item><c>trigger_username</c>: <c>""</c></item>
        </list>
      </item>

      <tag><marker id="agent_type"></marker>
        <c><![CDATA[agent_type() = master | sub <optional>]]></c></tag>
      <item>
        <p>If <c>master</c>, one master agent is
          started. Otherwise no agents are started.</p>
        <p>Defaults to <c>master</c>.</p>
      </item>

      <tag><marker id="agent_data_dir"></marker>
        <c><![CDATA[db_dir() = string() <mandatory>]]></c></tag>
      <item>
        <p>Defines where the SNMP agent internal database files are stored.</p>
      </item>

      <tag><marker id="agent_error_report_mod"></marker>
        <c><![CDATA[error_report_mod() = atom() <optional>]]></c></tag>
      <item>
        <p>Defines an error report module, implementing the
          <seealso marker="snmpa_error_report">
          <c>snmpa_error_report</c></seealso> 
          behavior. Two modules are provided with the toolkit:
          <seealso marker="snmpa_error_logger">
          <c>snmpa_error_logger</c></seealso> and
          <seealso marker="snmpa_error_io">
          <c>snmpa_error_io</c></seealso>.</p>
        <p>Defaults to <c>snmpa_error_logger</c>.</p>
      </item>

      <tag><marker id="agent_force_load"></marker>
        <c><![CDATA[force_load() = bool() <optional>]]></c></tag>
      <item>
        <p>If <c>true</c>, the configuration files are re-read
          during startup, and the contents of the configuration
          database is ignored. Thus, if <c>true</c>, changes to
          the configuration database are lost upon reboot of the
          agent.</p>
        <p>Defaults to <c>false</c>.</p>
      </item>

      <tag><marker id="agent_gb_max_vbs"></marker>
        <c><![CDATA[gb_max_vbs() =
        pos_integer() | infinity <optional>]]></c></tag>
      <item>
        <p>Defines the maximum number of varbinds allowed
	in a Get-Bulk response.</p>
        <p>Defaults to <c>1000</c>.</p>
      </item>

      <tag><marker id="agent_local_db"></marker>
        <c><![CDATA[local_db() = [local_db_opt()] <optional>]]></c></tag>
      <item>
        <p><c>local_db_opt() = {repair, agent_repair()} |
        {auto_save, agent_auto_save()} | {verbosity, verbosity()}</c></p>
        <p>Defines options specific for the SNMP agent local database.</p>
        <p>For defaults, see the options in <c>local_db_opt()</c>.</p>
      </item>

      <tag><marker id="agent_mib_server"></marker>
        <c><![CDATA[mib_server() = [mib_server_opt()] <optional>]]></c></tag>
      <item>
        <p><c>mib_server_opt() = {mibentry_override, mibentry_override()} |
          {trapentry_override, trapentry_override()} |
          {verbosity, verbosity()} | {cache, mibs_cache()} |
          {data_module, mib_server_data_module()}</c></p>
        <p>Defines options specific for the SNMP agent MIB server.</p>
        <p>For defaults, see the options in <c>mib_server_opt()</c>.</p>
      </item>

<!--
      <tag><marker id="agent_ms_data_module"></marker>
        <c><![CDATA[mib_server_data_module() = snmpa_mib_data_tttn |
        snmpa_mib_data_ttln | module() <optional>]]></c></tag>
-->
      <tag><marker id="agent_ms_data_module"></marker>
        <c><![CDATA[mib_server_data_module() =
        snmpa_mib_data_tttn | module() <optional>]]></c></tag>
      <item>
        <p>Defines the back end data module of the SNMP agent <c>mib-server</c>
        as defined by the
	<seealso marker="snmpa_mib_data"><c>snmpa_mib_data</c></seealso>
	behavior.</p>
	<p>Only the default module is provided with the agent,
	<c>snmpa_mib_data_tttn</c>.</p>
<!--
	<p>Two modules is provided with the agent,
	<c>snmpa_mib_data_tttn</c> (this is the old implementation) and
	<c>snmpa_mib_data_ttln</c> (for a MIB tree with many holes,
	this algorithm can be more price efficient).</p>
-->
        <p>Default module is <c>snmpa_mib_data_tttn</c>.</p>
      </item>

      <tag><marker id="agent_mib_storage"></marker>
        <c><![CDATA[mib_storage() = [mib_storage_opt()] <optional>]]></c></tag>
      <item>
        <p><c>mib_storage_opt() = {module, mib_storage_module()} |
        {options, mib_storage_options()}</c></p>
        <p>Specifies how basic MIB data is stored. 
	This option is used by two parts of the SNMP agent:
	the <c>mib-server</c> and the <c>symbolic-store</c>.</p>
        <p>Defaults to <c>[{module, snmpa_mib_storage_ets}]</c>.</p>
      </item>

<!--
This is the old format, which is "supported", but not documented,
in so far as it will be converted to the new format if found.

      <tag><marker id="agent_mib_storage"></marker>
        <c><![CDATA[mib_storage() = ets | {ets, Dir} | {ets, Dir, Action} |
        dets | {dets, Dir} | {dets, Dir, Action} | mnesia | {mnesia, Nodes} |
        {mnesia, Nodes, Action} <optional>]]></c></tag>
      <item>
        <p>Specifies how information retrieved from the MIBs is stored.</p>
        <p>If <c>mib_storage</c> is <c>{ets, Dir}</c>, the table is also
          stored on file. If <c>Dir</c> is <c>default</c>, <c>db_dir</c>
          is used.</p>
        <p>If <c>mib_storage</c> is <c>dets</c> or if <c>Dir</c> is
          <c>default</c>, <c>db_dir</c> is used for <c>Dir</c>.</p>
        <p>If <c>mib_storage</c> is <c>mnesia</c>, <c>erlang:nodes()</c>
          is used for <c>Nodes</c>.</p>
        <p>Defaults to <c>ets</c>.</p>
        <p><c>Dir = default | string()</c>. <c>Dir</c> is the directory where
          the files are stored. If <c>default</c>, <c>db_dir</c> is used.</p>
        <p><c>Nodes = visible | connected | [node()]</c>.
          <c>Nodes = visible</c> is translated to
          <c>erlang:nodes(visible)</c>.
          <c>Nodes = connected</c> is translated to
          <c>erlang:nodes(connected)</c>.
          If <c>Nodes = []</c>, the own node is assumed.</p>
        <p><c>Action = clear | keep</c>. Defaults to <c>keep</c>.
          <c>Action</c> is used to specify what must be done if the
          Mnesia/<c>dets</ table already exist.</p>
      </item>
-->

      <tag><marker id="agent_mst_module"></marker>
        <c><![CDATA[mib_storage_module() = snmpa_mib_data_ets |
          snmpa_mib_data_dets | snmpa_mib_data_mnesia | module()]]></c></tag>
      <item>
        <p>Defines the MIB storage module of the SNMP agent as defined by the
	<seealso marker="snmpa_mib_storage"><c>snmpa_mib_storage</c></seealso>
	behavior.</p>
	<p>Several entities (<c>mib-server</c> through the its data module and
	the <c>symbolic-store</c>) of the SNMP agent use this for storage
	of miscellaneous MIB-related data retrieved while loading a MIB.</p>
	<p>Several implementations are provided with the agent:
	<c>snmpa_mib_storage_ets</c>, <c>snmpa_mib_storage_dets</c>, and
	<c>snmpa_mib_storage_mnesia</c>.</p>
        <p>Default module is <c>snmpa_mib_storage_ets</c>.</p>
      </item>

      <tag><marker id="agent_mst_options"></marker>
        <c><![CDATA[mib_storage_options() = list() <optional>]]></c></tag>
      <item>
        <p>This is implementation-dependent, that is, it depends on the
	module. For each module, a specific set of options are valid.
	For the module provided with the app, these options are supported:</p>
        <list type="bulleted">
          <item>
	    <p><c>snmpa_mib_storage_ets</c>: <c>{dir, filename()} |
              {action, keep | clear}, {checksum, boolean()}</c></p>
	    <list>
	      <item>
		<p><c>dir</c> - If present, points to a directory where a file
		to which all data in the <c>ets</c> table is "synced".</p>
		<p>Also, when a table is opened, this file is read
		if it exists.</p>
		<p>By default, this will <em>not</em> be used.</p> 
	      </item>
	      <item>
		<p><c>action</c> - Specifies the behavior when a non-empty
		file is found: keep its content or clear it out.</p>
		<p>Defaults to <c>keep</c>.</p> 
	      </item>
	      <item>
		<p><c>checksum</c> - Defines if the file is checksummed.</p>
		<p>Defaults to <c>false</c>.</p> 
	      </item>
	    </list>
	  </item>
          <item>
	    <p><c>snmpa_mib_storage_dets</c>: <c>{dir, filename()} |
              {action, keep | clear}, {auto_save, default | pos_integer()} |
              {repair, force | boolean()}</c></p>
	    <list>
	      <item>
		<p><c>dir</c> - This <em>mandatory</em> option points to a
		directory where to place the file of a <c>dets</c> table.</p>
	      </item>
	      <item>
		<p><c>action</c> - Specifies the behavior when a non-empty
		file is found: keep its content or clear it out.</p>
		<p>Defaults to <c>keep</c>.</p> 
	      </item>
	      <item>
		<p><c>auto_save</c> - Defines the <c>dets</c> auto-save
                frequency.</p>
		<p>Defaults to <c>default</c>.</p> 
	      </item>
	      <item>
		<p><c>repair</c> - Defines the <c>dets</c> repair behavior.</p>
		<p>Defaults to <c>false</c>.</p> 
	      </item>
	    </list>
	  </item>
          <item>
	    <p><c>snmpa_mib_storage_mnesia</c>:
              <c>{action, keep | clear}, {nodes, [node()]}</c></p>
	    <list>
	      <item>
		<p><c>action</c> - Specifies the behavior when a non-empty,
		already existing, table is found: keep its content or clear
                it out.</p>
		<p>Defaults to <c>keep</c>.</p>
	      </item>
	      <item>
		<p><c>nodes</c> - A list of node names (or an atom
		describing a list of nodes) defining where to open the table.
		It is up to the user to ensure that Mnesia is running
		on the specified nodes.</p>
		<p>The following distinct values are recognized:</p>
		<list>
		  <item><c>[]</c> - Translated into a list of the own node:
                    <c>[node()]</c>
		  </item>
		  <item><c>all</c> - <c>erlang:nodes()</c>
		  </item>
		  <item><c>visible</c> - <c>erlang:nodes(visible)</c>
		  </item>
		  <item><c>connected</c> - <c>erlang:nodes(connected)</c>
		  </item>
		  <item><c>db_nodes</c> - <c>mnesia:system_info(db_nodes)</c>
		  </item>
		</list>		
		<p>Default is the result of the call: <c>erlang:nodes()</c>.</p>
	      </item>
	    </list>
	  </item>
        </list>
      </item>

      <tag><marker id="agent_ms_meo"></marker>
        <c><![CDATA[mibentry_override() = bool() <optional>]]></c></tag>
      <item>
        <p>If this value is <c>false</c>, then when loading a MIB each MIB
          entry is checked before installation of the MIB.
          The purpose of the check is to prevent that the same symbolic
          MIB entry name is used for different OIDs.</p>
        <p>Defaults to <c>false</c>.</p>
      </item>

      <tag><marker id="agent_ms_cache"></marker>
        <c><![CDATA[mibs_cache() =
        bool() | mibs_cache_opts() <optional>]]></c></tag>
      <item>
        <p>Defines if the agent is to use the <c>mib-server</c> lookup
          cache.</p>
        <p>Defaults to <c>true</c> (the <c>mibs_cache_opts()</c>
          default values then apply).</p>
      </item>

      <tag><marker id="agent_ms_cache_age"></marker>
        <c><![CDATA[mibs_cache_age() = integer() > 0 <optional>]]></c></tag>
      <item>
        <p>Defines how old the entries in the cache are allowed
	to become before they are GC'ed (assuming GC is performed).
	Each entry in the cache is "touched" whenever it is accessed.</p>
	<p>The age is defined in milliseconds.</p>
        <p>Defaults to <c>10 minutes</c>.</p>
      </item>

      <tag><marker id="agent_ms_cache_autogc"></marker>
        <c><![CDATA[mibs_cache_autogc() = bool() <optional>]]></c></tag>
      <item>
        <p>Defines if the <c>mib-server</c> is to perform cache GC
        automatically or leave it to the user (see
	<seealso marker="snmpa#gc_mibs_cache">
        <c>snmpa:gc_mibs_cache/0,1,2,3</c></seealso>).</p>
	<p>Defaults to <c>true</c>.</p>
      </item>

      <tag><marker id="agent_ms_cache_gclimit"></marker>
        <c><![CDATA[mibs_cache_gclimit() =
        integer() > 0 | infinity <optional>]]></c></tag>
      <item>
        <p>When performing a GC, this is the maximum number of cache entries
	that are deleted from the cache.</p>
	<p>The reason for having this limit is that if the cache is
	large, the GC can potentially take a long time, during which
	the agent is locked.</p>
	<p>Defaults to <c>100</c>.</p>
      </item>

      <tag><marker id="agent_ms_cache_opts"></marker>
        <c><![CDATA[mibs_cache_opts() =
        [mibs_cache_opt()] <optional>]]></c></tag>
      <item>
        <p><c>mibs_cache_opt() = {autogc, mibs_cache_autogc()} |
        {gclimit, mibs_cache_gclimit()} | {age, mibs_cache_age()}</c></p>
        <p>Defines options specific for the SNMP agent <c>mib-server</c>
        cache.</p>
        <p>For defaults, see the options in <c>mibs_cache_opt()</c>.</p>
      </item>

      <tag><marker id="agent_mt"></marker>
        <c><![CDATA[multi_threaded() = bool() <optional>]]></c></tag>
      <item>
        <p>If <c>true</c>, the agent is multi-threaded, with one
          thread for each get request.</p>
        <p>Defaults to <c>false</c>.</p>
      </item>

      <tag><marker id="agent_ni_req_limit"></marker>
        <c><![CDATA[req_limit() = integer() | infinity <optional>]]></c></tag>
      <item>
        <p>Maximum number of simultaneous requests handled by the agent.</p>
        <p>Defaults to <c>infinity</c>.</p>
      </item>

      <tag><marker id="agent_symbolic_store"></marker>
        <c>symbolic_store() = [symbolic_store_opt()]</c></tag>
      <item>
        <p><c>symbolic_store_opt() = {verbosity, verbosity()}</c></p>
        <p>Defines options specific for the SNMP agent
          <c>symbolic-store</c>.</p>
        <p>For defaults, see the options in <c>symbolic_store_opt()</c>.</p>
      </item>

      <tag><marker id="agent_target_cache"></marker>
        <c>target_cache() = [target_cache_opt()]</c></tag>
      <item>
        <p><c>target_cache_opt() = {verbosity, verbosity()}</c></p>
        <p>Defines options specific for the SNMP agent target cache.</p>
        <p>For defaults, see the options in <c>target_cache_opt()</c>.</p>
      </item>

      <tag><marker id="agent_ms_teo"></marker>
        <c><![CDATA[trapentry_override() = bool() <optional>]]></c></tag>
      <item>
        <p>If this value is <c>false</c>, then when loading a MIB each trap
          is checked before installation of the MIB.
          The purpose of the check is to prevent that the same symbolic
          trap name is used for different traps.</p>
        <p>Defaults to <c>false</c>.</p>
      </item>
    </taglist>

    <marker id="manager_opts_and_types"></marker>
    <p><em>Manager-Specific Configuration Options and Types</em></p>
    <taglist>
      <tag><marker id="manager_def_user_data"></marker>
        <c><![CDATA[def_user_data() = term() <optional>]]></c></tag>
      <item>
        <p>Data for the default user. Passed to the user when calling
          the callback functions.</p>
        <p>Defaults to <c>undefined</c>.</p>
      </item>

      <tag><marker id="manager_def_user_module"></marker>
        <c><![CDATA[def_user_module() = atom() <optional>]]></c></tag>
      <item>
        <p>The module implementing the default user. See the
          <seealso marker="snmpm_user"><c>snmpm_user</c></seealso> behavior.</p>
        <p>Defaults to <c>snmpm_user_default</c>.</p>
      </item>

      <tag><marker id="manager_config_auto_save"></marker>
        <c><![CDATA[manager_auto_save() =
        integer() | infinity <optional>]]></c></tag>
      <item>
        <p>The auto save interval. The table is flushed to disk
          whenever not accessed for this amount of time.</p>
        <p>Defaults to <c>5000</c>.</p>
      </item>

      <tag><marker id="manager_config"></marker>
        <c><![CDATA[manager_config() =
        [manager_config_opt()] <mandatory>]]></c></tag>
      <item>
        <p><c>manager_config_opt() = {dir, manager_config_dir()} |
          {db_dir, manager_db_dir()} | {db_init_error, db_init_error()} |
          {repair, manager_repair()} | {auto_save, manager_auto_save()} |
          {verbosity, verbosity()}</c></p>
        <p>Defines specific configuration-related options for the SNMP
          manager.</p>
        <p>For defaults, see the options in <c>manager_config_opt()</c>.</p>
      </item>

      <tag><marker id="manager_config_dir"></marker>
        <c><![CDATA[manager_config_dir = dir() <mandatory>]]></c></tag>
      <item>
        <p>Defines where the SNMP manager configuration files are stored.</p>
      </item>

      <tag><marker id="manager_config_db_dir"></marker>
        <c><![CDATA[manager_db_dir = dir() <mandatory>]]></c></tag>
      <item>
        <p>Defines where the SNMP manager stores persistent data.</p>
      </item>

      <tag><marker id="manager_irb"></marker>
        <c><![CDATA[manager_irb() =
        auto | user | {user, integer()} <optional>]]></c></tag>
      <item>
        <p>Defines how the manager handles the sending of
          response (acknowledgment) to received inform-requests.</p>
        <list type="bulleted">
          <item>
            <p><c>auto</c> - The manager autonomously sends response
              (acknowledgment) to inform-request messages.</p>
          </item>
          <item>
            <p><c>{user, integer()}</c> - The manager sends response
              (acknowledgment) to inform-request messages when the
              <seealso marker="snmpm_user#handle_inform">
              <c>snmpm_user:handle_inform</c></seealso>
              function completes. The integer is the time, in milliseconds,
              that the manager considers the stored inform-request information
              valid.</p>
          </item>
          <item>
            <p><c>user</c> - Same as <c>{user, integer()}</c>, except that
              the default time, 15000 milliseconds, is used.</p>
          </item>
        </list>
        <p>For more information, see
          <seealso marker="snmpm_network_interface">
          <c>snmpm_network_interface</c></seealso>,
          <seealso marker="snmpm_user#handle_inform">
          <c>snmpm_user:handle_inform</c></seealso>, and
          <seealso marker="snmp_manager_netif">
          definition of the manager net if</seealso>.</p>
        <p>Defaults to <c>auto</c>.</p>
      </item>

      <tag><marker id="manager_mibs"></marker>
        <c><![CDATA[manager_mibs() = [string()] <optional>]]></c></tag>
      <item>
        <p>Specifies a list of MIBs (including path) and defines which MIBs
          are initially loaded into the SNMP manager.</p>
        <p>Defaults to <c>[]</c>.</p>
      </item>

      <tag><marker id="manager_net_if"></marker>
        <c><![CDATA[manager_net_if() =
        [manager_net_if_opt()] <optional>]]></c></tag>
      <item>
        <p><c>manager_net_if_opt() = {module, manager_net_if_module()} |
          {verbosity, verbosity()} |
          {options, manager_net_if_options()}</c></p>
        <p>Defines options specific for the SNMP manager network interface
          entity.</p>
        <p>For defaults, see the options in <c>manager_net_if_opt()</c>.</p>
      </item>

      <tag><marker id="manager_ni_filter_module"></marker>
        <c><![CDATA[manager_net_if_filter_module() =
        atom() <optional>]]></c></tag>
      <item>
	<p>Module that handles the network interface filter part for the
	  SNMP manager. Must implement the
	  <seealso marker="snmpm_network_interface_filter">
          <c>snmpm_network_interface_filter</c></seealso> behavior.</p>
	<p>Defaults to <c>snmpm_net_if_filter</c>.</p>
      </item>

      <tag><marker id="manager_ni_filter_opts"></marker>
        <c><![CDATA[manager_net_if_filter_options() =
        [manager_net_if_filter_option()] <optional>]]></c></tag>
      <item>
	<p><c>manager_net_if_filter_option() =
          {module, manager_net_if_filter_module()}</c></p>
	<p>These options are specific to the used module.
	  The ones shown here are applicable to the default
	  <c><![CDATA[manager_net_if_filter_module()]]></c>.</p>
	<p>For defaults, see the options in
          <c>manager_net_if_filter_option()</c>.</p>
      </item>

      <tag><marker id="manager_ni_module"></marker>
        <c><![CDATA[manager_net_if_module() = atom() <optional>]]></c></tag>
      <item>
        <p>The module that handles the network interface part for the
	SNMP manager. It must implement the
	<seealso marker="snmpm_network_interface">
        <c>snmpm_network_interface</c></seealso> behavior.</p>
        <p>Defaults to <c>snmpm_net_if</c>.</p>
      </item>

      <tag><marker id="manager_ni_opts"></marker>
        <c><![CDATA[manager_net_if_options() =
        [manager_net_if_option()] <optional>]]></c></tag>
      <item>
        <p><c>manager_net_if_option() = {bind_to, bind_to()} |
          {sndbuf, sndbuf()} |
          {recbuf, recbuf()} |
          {no_reuse, no_reuse()} |
          {filter, manager_net_if_filter_options()}</c></p>
        <p>These options are specific to the used module.
	The ones shown here are applicable to the default
	<c>manager_net_if_module()</c>.</p>
        <p>For defaults, see the options in <c>manager_net_if_option()</c>.</p>
      </item>

      <tag><marker id="manager_config_repair"></marker>
        <c><![CDATA[manager_repair() =
        false | true | force <optional>]]></c></tag>
      <item>
        <p>The repair option for the persistent database (if
          and how the table is repaired when opened).</p>
        <p>Defaults to <c>true</c>.</p>
      </item>

      <tag><marker id="manager_server"></marker>
        <c><![CDATA[server() = [server_opt()] <optional>]]></c></tag>
      <item>
        <p><c>server_opt() = {timeout, server_timeout()} |
          {verbosity, verbosity()}</c></p>
        <p>Specifies the options for the manager server process.</p>
        <p>Defaults to <c>silence</c>.</p>
      </item>

      <tag><marker id="manager_server_timeout"></marker>
        <c><![CDATA[server_timeout() = integer() <optional>]]></c></tag>
      <item>
        <p>Asynchronous request cleanup time. For every request,
          some information is stored internally to be able to
          deliver the reply (when it arrives) to the proper destination.
          If the reply arrives, this information is deleted. But if
          there is no reply (in time), the information must be deleted
          after the <em>best before</em> time is passed.
          This cleanup is performed at regular intervals, defined
          by the <c>server_timeout()</c> time.
          The information has a <em>best before</em> time,
          defined by the <c>Expire</c> time specified when calling the
          request function (see
          <seealso marker="snmpm#async_get"><c>async_get</c></seealso>,
          <seealso marker="snmpm#async_get_next">
          <c>async_get_next</c></seealso>, and
          <seealso marker="snmpm#async_set"><c>async_set</c></seealso>).</p>
        <p>Time in milliseconds.</p>
        <p>Defaults to <c>30000</c>.</p>
      </item>
    </taglist>

    <marker id="common_types"></marker>
    <p><em>Common Configuration Types</em></p>
    <taglist>
      <tag><marker id="atl_dir"></marker>
        <c><![CDATA[atl_dir = dir() <mandatory>]]></c></tag>
      <item>
        <p>Specifies where to store the audit trail log.</p>
        <p>If <c>audit_trail_log</c> specifies that logging is to take
          place, this parameter <em>must</em> be defined.</p>
      </item>

      <tag><marker id="atl_repair"></marker>
        <c><![CDATA[atl_repair() =
          true | false | truncate | snmp_repair <optional>]]></c></tag>
      <item>
        <p>Specifies if and how the audit trail log is to be repaired
          when opened. Unless this parameter has the value <c>snmp_repair</c>,
          it is sent to <c>disk_log</c>. If the value is
          <c>snmp_repair</c>, SNMP attempts to handle certain faults on its
          own. Even if it cannot repair the file, it does not truncate it
          directly, but instead <em>moves it aside</em> for later offline
          analysis.</p>
        <p>Defaults to <c>true</c>.</p>
      </item>

      <tag><marker id="atl_seqno"></marker>
        <c><![CDATA[atl_seqno() = true | false <optional>]]></c></tag>
      <item>
        <p>Specifies if the audit trail log entries are to be (sequence)
          numbered. The range of the sequence numbers is according
          to RFC 5424, that is, 1 through 2147483647.</p>
        <p>Defaults to <c>false</c>.</p>
      </item>

      <tag><marker id="atl_size"></marker>
        <c><![CDATA[atl_size() = {integer(), integer()} <mandatory>]]></c></tag>
      <item>
        <p>The size of the audit trail log.
          This parameter is sent to <c>disk_log</c>.</p>
        <p>If <c>audit_trail_log</c> specifies that logging is to
          take place, this parameter <em>must</em> be defined.</p>
      </item>

      <tag><marker id="atl_type"></marker>
        <c><![CDATA[atl_type() =
        read | write | read_write <optional>]]></c></tag>
      <item>
        <p>Specifies what type of audit trail log to use. 
          The effect of the type is different for the the agent
          and the manager.</p>
        <p>For the agent:</p>
        <list type="bulleted">
          <item>If <c>write</c> is specified, only set requests are logged.
          </item>
          <item>If <c>read</c> is specified, only get requests are logged.
          </item>
          <item>If <c>read_write</c>, all requests are logged.</item>
        </list>
        <p>For the manager:</p>
        <list type="bulleted">
          <item>If <c>write</c> is specified, only sent messages are logged.
          </item>
          <item>If <c>read</c> is specified, only received messages are logged.
          </item>
          <item>If <c>read_write</c>, both outgoing and incoming messages are
           logged.</item>
        </list>
        <p>Defaults to <c>read_write</c>.</p>
      </item>

      <tag><marker id="audit_trail_log"></marker>
        <c><![CDATA[audit_trail_log() =
          [audit_trail_log_opt()] <optional>]]></c></tag>
      <item>
        <p><c>audit_trail_log_opt() = {type, atl_type()} | {dir, atl_dir()} |
          {size, atl_size()} |  {repair, atl_repair()} |
          {seqno, atl_seqno()}</c></p>
        <p>If present, this option specifies the options for the
          <em>audit trail logging</em>. The
          <seealso marker="kernel:disk_log">
          <c>kernel:disk_log</c></seealso> module is
          used to maintain a wrap log. If present, the <c>dir</c> and
          <c>size</c> options are mandatory.</p>
        <p>If not present, audit trail logging is not used.</p>
      </item>

      <tag><marker id="bind_to"></marker>
        <c><![CDATA[bind_to() = bool() <optional>]]></c></tag>
      <item>
        <p>If <c>true</c>, <c>net_if</c> binds to the IP address.
          If <c>false</c>, <c>net_if</c> listens on any IP address on the host
          where it is running.</p>
        <p>Defaults to <c>false</c>.</p>
      </item>

      <tag><marker id="db_init_error"></marker>
        <c>db_init_error() = terminate | create | create_db_and_dir</c></tag>
      <item>
        <p>Defines what to do if the agent is unable to open an
          existing database file:</p>
        <list type="bulleted">
          <item><c>terminate</c> means that the agent/manager terminates.</item>
          <item><c>create</c> means that the agent/manager removes the faulty
            file(s) and create new ones.</item>
          <item><c>create_db_and_dir</c> means that the agent/manager creates
            the database file along with any missing parent directories
            for the database file.</item>
        </list>
        <p>Defaults to <c>terminate</c>.</p>
      </item>

      <tag><marker id="no_reuse"></marker>
        <c><![CDATA[no_reuse() = bool() <optional>]]></c></tag>
      <item>
        <p>If <c>true</c>, <c>net_if</c> does not specify that the IP
          and port address are to be reusable. If <c>false</c>,
          the address is set to reusable.</p>
        <p>Defaults to <c>false</c>.</p>
      </item>

      <tag><marker id="note_store"></marker>
        <c><![CDATA[note_store() = [note_store_opt()] <optional>]]></c></tag>
      <item>
        <p><c>note_store_opt() = {timeout, note_store_timeout()} |
          {verbosity, verbosity()}</c></p>
        <p>Specifies the options for the SNMP note store.</p>
        <p>For defaults, see the options in <c>note_store_opt()</c>.</p>
      </item>

      <tag><marker id="ns_timeout"></marker>
        <c><![CDATA[note_store_timeout() = integer() <optional>]]></c></tag>
      <item>
        <p>Note cleanup time. When storing a note in the note store, each
          note is given lifetime. Every <c>timeout</c> the <c>note_store</c>
          process performs a GC to remove the expired notes. Time in
          milliseconds.</p>
        <p>Defaults to <c>30000</c>.</p>
      </item>

      <tag><marker id="prio"></marker>
        <c><![CDATA[priority() = atom() <optional>]]></c></tag>
      <item>
        <p>Defines the Erlang priority for all SNMP processes.</p>
        <p>Defaults to <c>normal</c>.</p>
      </item>

      <tag><marker id="recbuf"></marker>
        <c><![CDATA[recbuf() = integer() <optional>]]></c></tag>
      <item>
        <p>Receive buffer size.</p>
        <p>Default value is defined by
          <seealso marker="kernel:gen_udp"><c>kernel:gen_udp</c></seealso>.</p>
      </item>

      <tag><marker id="restart_type"></marker>
        <c>restart_type() = permanent | transient | temporary</c></tag>
      <item>
        <p>For more information, see supervisor documention in
          <seealso marker="stdlib:supervisor#child_spec">
          <c>supervisor:child_spec</c></seealso> in STDLIB.</p>
        <p>Defaults to <c>permanent</c> for the agent and <c>transient</c>
          for the manager.</p>
      </item>

      <tag><marker id="sndbuf"></marker>
        <c><![CDATA[sndbuf() = integer() <optional>]]></c></tag>
      <item>
        <p>Send buffer size.</p>
        <p>Default value is defined by
          <seealso marker="kernel:gen_udp"><c>kernel:gen_udp</c></seealso>.</p>
      </item>

      <tag><marker id="verbosity"></marker>
        <c><![CDATA[verbosity() =
        silence | info | log | debug | trace <optional>]]></c></tag>
      <item>
        <p>Verbosity for an SNMP process. This specifies now much debug
          information is printed.</p>
        <p>Defaults to <c>silence</c>.</p>
      </item>

      <tag><marker id="versions"></marker>
        <c><![CDATA[versions() = [version()] <optional>]]></c></tag>
      <item>
        <p><c>version() = v1 | v2 | v3</c></p>
        <p>Defines which SNMP versions to accept/use.</p>
        <p>Defaults to <c>[v1,v2,v3]</c>.</p>
      </item>
    </taglist>
  </section>

  <section>
    <title>See Also</title>
      <p><seealso marker="kernel:application">
        <c>kernel:application(3)</c></seealso>,
        <seealso marker="kernel:disk_log">
        <c>kernel:disk_log(3)</c></seealso></p>
  </section>
  
</appref>

