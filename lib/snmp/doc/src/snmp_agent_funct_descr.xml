<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE chapter SYSTEM "chapter.dtd">

<chapter>
  <header>
    <copyright>
      <year>1997</year><year>2016</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    
    </legalnotice>

    <title>Agent Functional Description</title>
    <prepared></prepared>
    <responsible></responsible>
    <docno></docno>
    <approved></approved>
    <checked>2016-11-29</checked>
    <date></date>
    <rev></rev>
    <file>snmp_agent_funct_descr.xml</file>
  </header>
  <p>The SNMP agent system consists of one master agent and
    optional subagents.
    </p>
  <p>The tool makes it easy to extend an SNMP agent in runtime dynamically.
    MIBs can be loaded and unloaded at any time. It is also
    easy to change the implementation of a MIB in runtime, without
    having to recompile it. The MIB implementation is clearly
    separated from the agent.
    </p>
  <p>To facilitate incremental MIB implementation, the tool can
    generate a prototype implementation for a whole MIB, or parts
    thereof. This allows different MIBs and management applications to
    be developed at the same time.
    </p>

  <section>
    <title>Features</title>
    <marker id="features"></marker>
    <p>To implement an agent, the programmer writes instrumentation
      functions for the variables and the tables in the MIBs that the
      agent is to support. A running prototype that handles <c>set</c>,
      <c>get</c>, and <c>get-next</c> can be created without any programming.
      </p>
    <p>The toolkit provides the following:
      </p>
    <list type="bulleted">
      <item>A multilingual multithreaded extensible SNMP agent</item>
      <item>Easy writing of instrumentation functions with a
       high-level programming language</item>
      <item>Basic fault handling, such as automatic type checking</item>
      <item>Access control</item>
      <item>Authentication</item>
      <item>Privacy through encryption</item>
      <item>Loading and unloading of MIBs in runtime</item>
      <item>Ability to change instrumentation functions without
       recompiling the MIB</item>
      <item>Rapid prototyping environment where the MIB compiler can
       use generic instrumentation functions, which later can be
       refined by the programmer</item>
      <item>A simple and extensible model for transaction handling and
       consistency checking of <c>set</c> requests</item>
      <item>Support of the subagent concept through distributed Erlang</item>
      <item>A mechanism for sending notifications (traps and informs)</item>
      <item>Support for implementing SNMP tables in the Mnesia Database
       Management System (DBMS)</item>
    </list>
  </section>

  <section>
    <title>SNMPv1, SNMPv2, and SNMPv3</title>
    <marker id="versions"></marker>
    <p>The SNMP development toolkit works with all three versions of the
      Standard Internet Management Framework: SNMPv1, SNMPv2, and SNMPv3.
      They all share the same basic structure and components, and
      follow the same architecture.</p>
    <p>The versions are defined in following RFCs:</p>
    <list type="bulleted">
      <item>For SNMPv1:
        <url href="http://tools.ietf.org/html/rfc1155">RFC 1155</url>,
        <url href="http://tools.ietf.org/html/rfc1157">RFC 1157</url>,
        <url href="http://tools.ietf.org/html/rfc1212">RFC 1212</url>,
        <url href="http://tools.ietf.org/html/rfc1213">RFC 1213</url>,
        <url href="http://tools.ietf.org/html/rfc1215">RFC 1215</url>
      </item>
      <item>For SNMPv2:
        <url href="http://tools.ietf.org/html/rfc1901">RFC 1901</url>,
        <url href="http://tools.ietf.org/html/rfc1902">RFC 1902</url>,
        <url href="http://tools.ietf.org/html/rfc1903">RFC 1903</url>,
        <url href="http://tools.ietf.org/html/rfc1904">RFC 1904</url>,
        <url href="http://tools.ietf.org/html/rfc1905">RFC 1905</url>,
        <url href="http://tools.ietf.org/html/rfc1906">RFC 1906</url>,
        <url href="http://tools.ietf.org/html/rfc1907">RFC 1907</url>
      </item>
      <item>For SNMPv3:
        <url href="http://tools.ietf.org/html/rfc2570">RFC 2570</url>,
        <url href="http://tools.ietf.org/html/rfc2571">RFC 2571</url>,
        <url href="http://tools.ietf.org/html/rfc2572">RFC 2572</url>,
        <url href="http://tools.ietf.org/html/rfc2573">RFC 2573</url>,
        <url href="http://tools.ietf.org/html/rfc2574">RFC 2574</url>,
        <url href="http://tools.ietf.org/html/rfc2575">RFC 2575</url>
      </item>
    </list>
    <p>Over time, as the Framework has evolved from SNMPv1, through SNMPv2,
      to SNMPv3, the definitions of each of these architectural components
      have become richer and more clearly defined, but the fundamental
      architecture has remained consistent.</p>
    <p>The following are the main features of SNMPv2 compared to SNMPv1:
      </p>
    <list type="bulleted">
      <item>The <c>get-bulk</c> operation for transferring large
       amounts of data
      </item>
      <item>Enhanced error codes
      </item>
      <item>A more precise language for MIB specification</item>
    </list>
    <p>The standard documents that define SNMPv2 are incomplete, in
      the sense that they do not specify how an SNMPv2 message looks
      like. The message format and security issues are left to a
      special administrative framework. One such framework is the
      community-based SNMPv2 framework (SNMPv2c), which uses the same
      message format and framework as SNMPv1. Other experimental
      frameworks exist, for example, SNMPv2u and SNMPv2*.
      </p>
    <p>The SNMPv3 specifications take a modular
      approach to SNMP. All modules are
      separated from each other and can be extended or replaced
      individually. Examples of modules are Message Definition,
      Security, and Access Control. The following are the main features
      of SNMPv3:
      </p>
    <list type="bulleted">
      <item>Encryption and authentication are added.
      </item>
      <item>MIBs for agent configuration are defined.</item>
    </list>
    <p>All these specifications are commonly referred to as "SNMPv3".
      However, only the following cannot be used with SNMPv1 or SNMPv2c:
    </p>
    <list type="bulleted">
      <item>The Message module, which defines a new message format</item>
      <item>The Security module, which takes care of encryption and
        authentication</item>
    </list>
    <p>In this version of the agent toolkit, all the standard
      MIBs for agent configuration are used. This includes MIBs for
      definition of management targets for notifications. These MIBs
      are used regardless of which SNMP version the agent is configured
      to use.
      </p>
    <p>The extensible agent in this toolkit understands SNMPv1,
      SNMPv2c, and SNMPv3. Recall that SNMP consists of two separate
      parts: the MIB definition language (SMI) and the protocol. On
      the protocol level, the agent can be configured to speak v1, v2c, v3,
      or any combination of them at the same time, that is, a v1 request
      gets a v1 reply, a v2c request gets a v2c reply, and a v3 request
      gets a v3 reply. On the MIB level, the MIB compiler can compile
      both SMIv1 and SMIv2 MIBs. Once compiled, any of the formats can
      be loaded into the agent, regardless of which protocol version the
      agent is configured to use. This means that the agent translates
      from v2 notifications to v1 traps, and conversely. For example,
      v2 MIBs can be loaded into an agent that speaks v1 only. The
      procedures for the translation between the two protocols are
      described in
      <url href="http://tools.ietf.org/html/rfc1908">RFC 1908</url> and
      <url href="http://tools.ietf.org/html/rfc2089">RFC 2089</url>.</p>
    <p>In order for an implementation to make full use of the enhanced
      SNMPv2 error codes, it is essential that the instrumentation
      functions always return SNMPv2 error codes if an error occurs.
      These error codes are translated into the corresponding SNMPv1
      error codes by the agent, if necessary.</p>
    <note>
      <p>The translation from an SMIv1 MIB to an SNMPv2c or SNMPv3 reply
        is always straightforward, but the translation from a v2 MIB
        to a v1 reply is more complicated. The data type <c>Counter64</c>
        in SMIv2 cannot be decoded correctly by an SNMPv1 manager.
        Therefore, an agent can never send a <c>Counter64</c>
        object to an SNMPv1 manager. The common practice in these
        situations is to ignore any <c>Counter64</c> objects, when sending
        a reply or a trap to an SNMPv1 manager. For example, if an SNMPv1
        manager tries to get an object of type <c>Counter64</c>, the
        manager gets a <c>noSuchName</c> error, while an SNMPv2 manager
        gets a correct value.</p>
    </note>
  </section>

  <section>
    <title>Operation</title>
    <marker id="operations"></marker>
    <p>The following steps are needed to get a running agent:</p>
    <taglist>
      <tag>1</tag>
      <item>Write your MIB in SMI in a text file.</item>
      <tag>2</tag>
      <item>Write the instrumentation functions in Erlang and compile them.
      </item>
      <tag>3</tag>
      <item>Put their names in the association file.</item>
      <tag>4</tag>
      <item>Run the MIB together with the association file through the
        MIB compiler.</item>
      <tag>5</tag>
      <item>Configure the application (agent).</item>
      <tag>6</tag>
      <item>Start the application (agent).</item>
      <tag>7</tag>
      <item>Load the compiled MIB into the agent.</item>
    </taglist>
    <p>The illustrations in this section illustrate the steps involved in
      the development of an SNMP agent.</p>
    <p>The compiler parses the SMI file and associates each table or
      variable with an instrumentation function (see figure
      <seealso marker="#image-1">MIB Compiler Principles</seealso>). The
      instrumentation functions are not needed at MIB compile time, only
      their names.
      </p>
    <marker id="image-1"></marker>
    <image file="snmp-um-1-image-1.gif">
      <icaption>MIB Compiler Principles</icaption>
    </image>
    <p>The binary output file produced by the compiler is read by the
      agent at MIB load time (see figure <seealso marker="#image-2">Starting
      the Agent</seealso>). The instrumentation is ordinary Erlang code,
      which is loaded explicitly or automatically the first time it is
      called.
      </p>
    <marker id="image-2"></marker>
    <image file="snmp-um-1-image-2.gif">
      <icaption>Starting the Agent</icaption>
    </image>
    <p>The SNMP agent system consists of one master agent and optional
      subagents. The master agent can be seen as a special kind of
      subagent. It implements the core agent functionality, UDP packet
      processing, type checking, access control, trap distribution, and
      so on. From a user perspective, it is used as an ordinary subagent.
      </p>
    <p>Subagents are only needed if your application requires special
      support for distribution from the SNMP toolkit. A subagent can
      also be used if the application requires a more complex set
      transaction scheme than is found in the master agent.
      </p>
    <p>The following illustration shows how a system can look in runtime.
      </p>
    <marker id="snmp_ch2_fig3"></marker>
    <image file="snmp-um-1-image-3.gif">
      <icaption>Architecture</icaption>
    </image>
    <p>A typical operation can include the following steps:</p>
    <taglist>
      <tag>1</tag>
      <item>The Manager sends a request to the agent.</item>
      <tag>2</tag>
      <item>The master agent decodes the incoming UDP packet.</item>
      <tag>3</tag>
      <item>The master agent determines which items in the request
       that are to be processed here and which items that are to be
       forwarded to its subagent.</item>
      <tag>4</tag>
      <item>Step 3 is repeated by all subagents.</item>
      <tag>5</tag>
      <item>Each subagent calls the instrumentation for its loaded MIBs.</item>
      <tag>6</tag>
      <item>The results of calling the instrumentation are propagated
       back to the master agent.</item>
      <tag>7</tag>
      <item>The answer to the request is encoded to a UDP Protocol
       Data Unit (PDU).</item>
    </taglist>
    <p>The sequence of steps shown is probably more complex than
      normal, but it illustrates the amount of functionality that is
      available. Notice the following:
      </p>
    <list type="bulleted">
      <item>An agent can have many MIBs loaded at the same time.</item>
      <item>Subagents can also have subagents. Each subagent can have
       any number of child subagents registered, forming a
       hierarchy.</item>
      <item>One MIB can communicate with many applications.</item>
      <item>Instrumentation can use Distributed Erlang to communicate
       with an application.</item>
    </list>
    <p>Most applications only need the master agent, as an agent
      can have multiple MIBs loaded at the same time.</p>
  </section>

  <section>
    <title>Subagents and MIB Loading</title>
    <marker id="sub_agent_mib_loading"></marker>
    <p>As applications tend to be transient (they are dynamically
      loaded and unloaded), the management of these applications must be
      dynamic as well. For example, if we have an equipment MIB for a
      rack and different MIBs for boards, which can be installed in the
      rack, the MIB for a board is to be loaded when the board is
      inserted, and unloaded when the board is removed.
      </p>
    <p>In this agent system, management information can be dynamically
      installed in two ways. The most common way is to load a MIB into
      an agent. The other way is to use a subagent, which is controlled
      by the application and is able to register and unregister itself. A
      subagent can register itself for managing a subtree (not to be mixed up
      with <c>erlang:register</c>). The subtree is identified by an
      Object Identifier (OID). When a subagent is registered, it receives all
      requests for this particular subtree and is responsible for
      answering them. Notice that a subagent can be
      started and stopped at any time.
      </p>
    <p>Compared to other SNMP agent packages, there is a significant
      difference in this way of using subagents. Other packages normally
      use subagents to load and unload MIBs in runtime. In Erlang, it is
      easy to load code in runtime and a MIB can be loaded into
      an existing subagent. It is not necessary to create a new process
      for handling a new MIB.
      </p>
    <p>Subagents are used for the following reasons:
      </p>
    <list type="bulleted">
      <item>To provide a more complex set-transaction scheme than
       master agent</item>
      <item>To avoid unnecessary process communication</item>
      <item>To provide a more lightweight mechanism for loading and
       unloading MIBs in runtime</item>
      <item>To provide interaction with other SNMP agent toolkits</item>
    </list>
    <p>For more information about these topics, see section
      <seealso marker="snmp_advanced_agent">Advanced Agent Topics</seealso>.
      </p>
    <p>The communication protocol between subagents is the normal
      message passing that is used in distributed Erlang systems. This
      implies that subagent communication is very efficient compared to
      SMUX, DPI, AgentX, and similar protocols.</p>
  </section>

  <section>
    <title>Contexts and Communities</title>
    <marker id="context_and_communities"></marker>
    <p>A context is a collection of management information accessible
      by an SNMP entity. An instance of a management object can exist in
      more than one context. An SNMP entity potentially has access to
      many contexts.</p>
    <p>Each managed object can exist in many instances within an
      SNMP entity. To identify the instances, specified by a MIB module,
      a method to distinguish the instance by its "scope" or
      context is used. Often the context is a physical or a logical device.
      It can include multiple devices, a subset of a single device or a
      subset of multiple devices, but the context is always
      defined as a subset of a single SNMP entity. To be able to
      identify a specific
      item of management information within an SNMP entity, the context,
      the object type, and its instance must be used.</p>
    <p>For example, the managed object type <c>ifDescr</c> from
      <url href="http://tools.ietf.org/html/rfc1573">RFC 1573</url> is
      defined as the description of a network interface. To identify
      the description of device-X's first network interface, the
      following information is needed:</p>
    <list type="bulleted">
      <item>The <c>snmpEngineID</c> of the SNMP entity that provides access
        to the management information at device-X</item>
      <item>The <c>contextName</c> (device-X)</item>
      <item>The managed object type (<c>ifDescr</c>)</item>
      <item>The instance ("1")</item>
    </list>
    <p>In SNMPv1 and SNMPv2c, the community string in the message was
      used for (at least) the following three purposes:
      </p>
    <list type="bulleted">
      <item>To identify the context</item>
      <item>To provide authentication</item>
      <item>To identify a set of trap targets</item>
    </list>
    <p>In SNMPv3, each of these areas has its own unique
      mechanism. A context is identified by the name of the SNMP
      entity, <c>contextEngineID</c>, and the name of the context,
      <c>contextName</c>. Each SNMPv3 message contains values for these
      two parameters.
      </p>
    <p>The SNMP-COMMUNITY-MIB maps a community
      string to a <c>contextEngineID</c> and <c>contextName</c>. Thus,
      each message, an SNMPv1, SNMPv2c, or an SNMPv3 message, always
      uniquely identifies a context.
      </p>
    <p>For an agent, the <c>contextEngineID</c> identified by a received
      message, is always equal to the <c>snmpEngineID</c> of the agent.
      Otherwise, the message was not intended for the agent. If the
      agent is configured with more than one context, the
      instrumentation code must be able to figure out for which context
      the request was intended. The function
      <seealso marker="snmpa#current_context/0">
      <c>snmpa:current_context/0</c></seealso> is provided for this purpose.
      </p>
    <p>By default, the agent has no knowledge of any other contexts
      than the default context (<c>""</c>). If it is to support more
      contexts, these must be explicitly added, by using an appropriate
      configuration file, see section <seealso marker="snmp_agent_config_files">
      Definition of Agent Configuration Files</seealso>.
      </p>
  </section>

  <section>
    <title>Management of the Agent</title>
    <marker id="management"></marker>
    <p>A set of standard MIBs are used to control and
      configure an SNMP agent.  All these MIBs, except
      the optional SNMP-PROXY-MIB (which is only used for proxy agents),
      are implemented in this agent. It is configurable which
      of these MIBs are loaded, and thus made visible to SNMP
      managers. For example, in a non-secure environment, it can be a
      good idea not to make MIBs that define access control visible.
      Notice that the data the MIBs define is used internally in the
      agent, even if the MIBs are not loaded. This section describes
      these standard MIBs, and some aspects of their implementation.
      </p>
    <p>Any SNMP agent must implement the groups <c>system</c> and
      <c>snmp</c>, defined in MIB-II. The definitions of these
      groups have changed from SNMPv1 to SNMPv2. MIBs and implementations
      for both of these versions are provided in the
      distribution:</p>
    <list type="bulleted">
      <item>STANDARD-MIB is the MIB file for SNMPv1.</item>
      <item>SNMPv2-MIB is the MIB file for SNMPv2.</item>
    </list>
   <p>If the agent is
      configured for SNMPv1 only, the STANDARD-MIB is loaded by default;
      otherwise the SNMPv2-MIB is loaded by default. This default
      behavior can be overridden by explicitly loading another
      version of this MIB, for example, you can choose to implement
      the union of all objects in these two MIBs.
      </p>
    <p>An SNMPv3 agent must implement the following MIBs:</p>
    <list type="bulleted">
      <item>SNMP-FRAMEWORK-MIB</item>
      <item>SNMP-MPD-MIB</item>
    </list>
    <p>If the agent is configured for SNMPv3, these MIBs
      are loaded by default. These MIBs can be loaded for other
      versions as well.
      </p>
    <p>The following standard MIBs can also be loaded into the agent:
      </p>
    <list type="bulleted">
      <item>
        <p>SNMP-TARGET-MIB and SNMP-NOTIFICATION-MIB, which define
          managed objects for configuration of management targets,
          that is, receivers of notifications (traps and informs). These
          MIBs can be used with any SNMP version.
          </p>
      </item>
      <item>
        <p>SNMP-VIEW-BASED-ACM-MIB, which defines managed objects
          for access control. This MIB can be used with any SNMP
          version.
          </p>
      </item>
      <item>
        <p>SNMP-COMMUNITY-MIB, which defines managed objects for
          coexistence of SNMPv1 and SNMPv2c with SNMPv3. This MIB is
          only useful if SNMPv1 or SNMPv2c is used, possibly in
          combination with SNMPv3.
          </p>
      </item>
      <item>
        <p>SNMP-USER-BASED-SM-MIB, which defines managed objects
          for authentication and privacy. This MIB is only useful
          with SNMPv3.
          </p>
      </item>
    </list>
    <p>All these MIBs are to be loaded into the master agent. Once
      loaded, they are always available in all contexts.
      </p>
    <p>The ASN.1 code, the Erlang source code, and the generated
      <c>.hrl</c> files for them are provided in the distribution and are
      placed in the directories <c>mibs</c>, <c>src</c>, and <c>include</c>,
      respectively, in the <c>snmp</c> application.
      </p>
    <p>The <c>.hrl</c> files are generated with
      <seealso marker="snmpc#mib_to_hrl/1">
      <c>snmpc:mib_to_hrl/1</c></seealso>.
      Include these files in your code as in the following example:
      </p>
    <code type="none">
-include_lib("snmp/include/SNMPv2-MIB.hrl").
    </code>
    <p>The initial values for the managed objects defined in these
      tables are read at startup from a set of configuration files,
      which are described in section <seealso marker="snmp_config">
      Running the Application</seealso>.
      </p>

    <section>
      <title>STANDARD-MIB and SNMPv2-MIB</title>
      <p>The STANDARD-MIB and SNMPv2-MIB contain the <c>snmp-</c> and
        <c>system</c> groups
        from MIB-II, which are defined in
        <url href="http://tools.ietf.org/html/rfc1213">RFC 1213</url>
        (STANDARD-MIB) and
        <url href="http://tools.ietf.org/html/rfc1907">RFC 1907</url>
        (SNMPv2-MIB). The MIBs are implemented in the
        <seealso marker="snmp_standard_mib"><c>snmp_standard_mib</c></seealso>
        module. All the <c>snmp</c> counters
        reside in volatile memory and the <c>system</c> and
        <c>snmpEnableAuthenTraps</c> variables in persistent memory,
        using the SNMP built-in database (for details, see
        <seealso marker="snmp_app"><c>snmp</c></seealso> and
        <seealso marker="snmpa_local_db"><c>snmpa_local_db</c></seealso>
        in the Reference Manual.</p>
      <p>If another implementation of any of these variables is needed,
        for example to store the persistent variables in a Mnesia database,
        an own implementation of the variables must be made. That MIB
        will be compiled and loaded instead of the default MIB.
        The new compiled MIB
        must have the same name as the original MIB (that is, STANDARD-MIB
        or SNMPv2-MIB), and be located in the SNMP configuration
        directory (see section <seealso marker="snmp_config">
        Running the Application</seealso>).
        </p>
      <p>One of these MIBs is always loaded. If only SNMPv1 is used,
        STANDARD-MIB is loaded, otherwise SNMPv2-MIB is loaded.
        </p>

      <section>
        <title>Data Types</title>
        <p>Some new data types in SNMPv2 are useful in
          SNMPv1 as well. In the STANDARD-MIB, three data types are
          defined: <c>RowStatus</c>, <c>TruthValue</c>, and
          <c>DateAndTime</c>. These data types are originally defined
          as textual conventions in SNMPv2-TC
          (<url href="http://tools.ietf.org/html/rfc1903">RFC 1903</url>).
        </p>
      </section>
    </section>

    <section>
      <title>SNMP-FRAMEWORK-MIB and SNMP-MPD-MIB</title>
      <p>The SNMP-FRAMEWORK-MIB and SNMP-MPD-MIB define additional
        read-only managed objects, which
        are used in the generic SNMP framework defined in
        <url href="http://tools.ietf.org/html/rfc2271">RFC 2271</url>
        and the generic message processing and dispatching module defined in
        <url href="http://tools.ietf.org/html/rfc2272">RFC 2272</url>.
        They are generic in the sense that they are not tied
        to any specific SNMP version.
        </p>
      <p>The objects in these MIBs are implemented in the modules
        <seealso marker="snmp_framework_mib">
        <c>snmp_framework_mib</c></seealso> and
        <seealso marker="snmp_standard_mib">
        <c>snmp_standard_mib</c></seealso>,
        respectively. All objects reside in volatile memory and the
        configuration files are always reread at startup.
        </p>
      <p>If SNMPv3 is used, these MIBs are loaded by default.
        </p>
    </section>

    <section>
      <title>SNMP-TARGET-MIB and SNMP-NOTIFICATION-MIB</title>
      <p>The SNMP-TARGET-MIB and SNMP-NOTIFICATION-MIB define managed
        objects for configuration of notification receivers. The MIBs 
        are described in detail in
        <url href="http://tools.ietf.org/html/rfc2273">RFC 2273</url>.
        Only a brief description is provided here.
        </p>
      <p>All tables in these MIBs have a column of type
        <c>StorageType</c>. The value of this column specifies how each
        row is stored, and what happens if the agent is restarted.
        The implementation supports the values <c>volatile</c>
        and <c>nonVolatile</c>. When the tables are initially filled
        with data from the configuration files, these rows
        automatically have storage type <c>nonVolatile</c>. If the
        agent restarts, all <c>nonVolatile</c> rows survive the restart,
        while the <c>volatile</c> rows are lost.
        The configuration files are not read at restart by default.
        </p>
      <p>These MIBs are not loaded by default.
        </p>

      <section>
        <title>snmpNotifyTable</title>
        <p>An entry in the <c>snmpNotifyTable</c> selects a set
          of management targets, which are to receive notifications,
          and the type (trap or inform) of notification that 
          is to be sent to each selected management target.
          When an application sends a notification using
          the function
          <seealso marker="snmpa#send_notification/5">
          <c>snmpa:send_notification/5</c></seealso>
          or the function <c>send_trap</c>, then
          parameter <c>NotifyName</c>, specified in
          the call, is used as an index in the table. The notification
          is sent to the management targets selected by that entry.
          </p>
      </section>

      <section>
        <title>snmpTargetAddrTable</title>
        <p>An entry in <c>snmpTargetAddrTable</c> defines
          transport parameters (such as
          IP address and UDP port) for each management target. Each row
          in <c>snmpNotifyTable</c> refers to potentially many rows
          in <c>snmpTargetAddrTable</c>. Each row in
          <c>snmpTargetAddrTable</c>
          refers to an entry in <c>snmpTargetParamsTable</c>.
          </p>
      </section>

      <section>
        <title>snmpTargetParamsTable</title>
        <p>An entry in <c>snmpTargetParamsTable</c> defines
          which SNMP version and which security parameters to use.
          </p>
        <p>Which SNMP version to use is implicitly defined by
          specifying the Message Processing Model. This version of the
          agent handles the models <c>v1</c>, <c>v2c</c>, and <c>v3</c>.
          </p>
        <p>Each row specifies which security model to use, along with
          security level and security parameters.
          </p>
      </section>
    </section>

    <section>
      <title>SNMP-VIEW-BASED-ACM-MIB</title>
      <p>The SNMP-VIEW-BASED-ACM-MIB defines managed objects to
        control access to the managed objects for the managers.
        The View Based Access Control Module (VACM) can be used with
        any SNMP version. However, if it is used with SNMPv1 or SNMPv2c,
        the SNMP-COMMUNITY-MIB defines additional objects to map
        community strings to VACM parameters.
        </p>
      <p>All tables in this MIB have a column of type <c>StorageType</c>.
        The value of this column specifies how each
        row is stored, and what happens if the agent is restarted.
        The implementation supports the values <c>volatile</c>
        and <c>nonVolatile</c>. When the tables are initially filled
        with data from the configuration files, these rows
        automatically have storage type <c>nonVolatile</c>. If the
        agent restarts, all <c>nonVolatile</c> rows survive the restart,
        while the <c>volatile</c> rows are lost.
        The configuration files are not read at restart by default.
        </p>
      <p>This MIB is not loaded by default.
        </p>
      <p>The VACM is described in detail in
        <url href="http://tools.ietf.org/html/rfc2275">RFC 2275</url>.
        Only a brief description is provided here.
        </p>
      <p>The basic concept is that of a <em>MIB view</em>. A MIB view
        is a subset of all the objects implemented by an agent. A
        Manager has access to a certain MIB view, depending on which
        security parameters are used, in which context the request is
        made, and which type of request is made.
        </p>
      <p>The following illustration provides an overview of the mechanism to
        select a MIB view.</p>
      <image file="MIB_mechanism.gif">
        <icaption>Overview of the Mechanism of MIB Selection</icaption>
      </image>
      <section>
        <title>vacmContextTable</title>
        <p>The <c>vacmContextTable</c> is a read-only table that lists all
          available contexts.
          </p>
      </section>

      <section>
        <title>vacmSecurityToGroupTable</title>
        <p>The <c>vacmSecurityToGroupTable</c> maps a <c>securityModel</c>
          and a <c>securityName</c> to a <c>groupName</c>.
          </p>
      </section>

      <section>
        <title>vacmAccessTable</title>
        <p>The <c>vacmAccessTable</c> maps the <c>groupName</c> (found in
          <c>vacmSecurityToGroupTable</c>), <c>contextName</c>,
          <c>securityModel</c>, and <c>securityLevel</c> to a MIB view
          for each type of operation (read, write, or notify). The MIB
          view is represented as a <c>viewName</c>. The definition of
          the MIB view represented by the <c>viewName</c> is found in
          the <c>vacmViewTreeFamilyTable</c>.
          </p>
      </section>

      <section>
        <title>vacmViewTreeFamilyTable</title>
        <p>The <c>vacmViewTreeFamilyTable</c> is indexed by the
          <c>viewName</c> and defines
          which objects are included in the MIB view.
          </p>
        <p>The MIB definition for the table is as follows:</p>
        <pre>
VacmViewTreeFamilyEntry ::= SEQUENCE
    {
        vacmViewTreeFamilyViewName     SnmpAdminString,
        vacmViewTreeFamilySubtree      OBJECT IDENTIFIER,
        vacmViewTreeFamilyMask         OCTET STRING,
        vacmViewTreeFamilyType         INTEGER,
        vacmViewTreeFamilyStorageType  StorageType,
        vacmViewTreeFamilyStatus       RowStatus
    }

INDEX { vacmViewTreeFamilyViewName,
        vacmViewTreeFamilySubtree
      }</pre>
        <p>Each <c>vacmViewTreeFamilyViewName</c> refers to a
          collection of subtrees.
          </p>

        <section>
          <title>MIB View Semantics</title>
          <p>A MIB view is a collection of included and excluded
            subtrees. A subtree is identified by an Object Identifier
            (OID). A mask is associated with each subtree.
            </p>
          <p>For each possible MIB object instance, the instance
            belongs to a subtree if both of the following apply:
            </p>
          <list type="bulleted">
            <item>The OID name of that MIB object
             instance comprises at least as many subidentifiers as
             does the subtree.
            </item>
            <item>Each subidentifier in the name of that MIB object
             instance matches the corresponding subidentifier of the
             subtree whenever the corresponding bit of the associated
             mask is 1 (0 is a wildcard that matches anything).</item>
          </list>
          <p>Membership of an object instance in a MIB view is
            determined by the following algorithm:
            </p>
          <list type="bulleted">
            <item>If a MIB object instance does not belong to any of
             the relevant subtrees, the instance is not in the
             MIB view.
            </item>
            <item>If a MIB object instance belongs to exactly one
             subtree, then the instance is included in, or excluded
             from, the relevant MIB view according to the type of
             that entry.
            </item>
            <item>If a MIB object instance belongs to more than one
             subtree, then the subtree that comprises the greatest
             number of subidentifiers, and is the lexicographically
             greatest, is used.
            </item>
          </list>
          <note>
            <p>If the OID is longer than an OID
              of an object type in the MIB, it refers to
              object instances. It is therefore possible to
              control whether particular rows in a table are to be
              visible.</p>
          </note>
        </section>
      </section>
    </section>

    <section>
      <title>SNMP-COMMUNITY-MIB</title>
      <p>The SNMP-COMMUNITY-MIB defines managed objects that are used
        for coexistence between SNMPv1 and SNMPv2c with SNMPv3. This
        MIB has the following properties:</p>
      <list type="bulleted">
        <item>Contains objects for mapping between community
          strings and version-independent SNMP message parameters.</item>
        <item>Provides a mechanism for performing source address
          validation on incoming requests.</item>
        <item>Provides a mechanism for selecting community
          strings based on target addresses for outgoing notifications.</item>
      </list>
      <p>All tables in this MIB have a column of type
        <c>StorageType</c>. The column value specifies how each
        row is stored, and what happens if the agent is restarted.
        The implementation supports the values <c>volatile</c>
        and <c>nonVolatile</c>. When the tables are initially filled
        with data from the configuration files, these rows
        automatically have storage type <c>nonVolatile</c>. If the
        agent restarts, all <c>nonVolatile</c> rows survive the restart,
        while the <c>volatile</c> rows are lost.
        The configuration files are not read at restart by default.
        </p>
      <p>This MIB is not loaded by default.
        </p>
    </section>

    <section>
      <title>SNMP-USER-BASED-SM-MIB</title>
      <p>The SNMP-USER-BASED-SM-MIB defines managed objects that are
        used for the User-Based Security Model.
        </p>
      <p>All tables in this MIB have a column of type
        <c>StorageType</c>. The column value specifies how each
        row is stored, and what happens if the agent is restarted.
        The implementation supports the values <c>volatile</c>
        and <c>nonVolatile</c>. When the tables are initially filled
        with data from the configuration files, these rows
        automatically have storage type <c>nonVolatile</c>. If the agent
        restarts, all <c>nonVolatile</c> rows survive the restart,
        while the <c>volatile</c> rows are lost.
        The configuration files are not read at restart by default.
        </p>
      <p>This MIB is not loaded by default.
        </p>
    </section>

    <section>
      <title>OTP-SNMPEA-MIB</title>
      <p>The OTP-SNMPEA-MIB was used in earlier versions of the agent, before
        standard MIBs existed for access control, MIB views, and trap
        target specification. All objects in this MIB are now obsolete.
        </p>
    </section>
  </section>

  <section>
    <title>Notifications</title>
    <marker id="notifications"></marker>
    <p>Notifications are defined in SMIv1 with the TRAP-TYPE macro in
      the definition of a MIB (see
      <url href="http://tools.ietf.org/html/rfc1215">RFC 1215</url>). The
      The corresponding macro in SMIv2 is NOTIFICATION-TYPE. When an application
      decides to send a notification, it calls one of the following functions:
      </p>
    <code type="none">
snmpa:send_notification(Agent, Notification, Receiver
                       [, NotifyName, ContextName, Varbinds])
snmpa:send_trap(Agent, Notification, Community [, Receiver, Varbinds])</code>
    <p>providing the registered name or process identifier of the
      agent, where the MIB that defines the notification is loaded, and
      the symbolic name of the notification.
      </p>
    <p>If the <seealso marker="snmpa#send_notification/3">
      <c>snmpa:send_notification/3,4</c></seealso> function is used,
      all management targets are selected, as defined in
      <url href="http://tools.ietf.org/html/rfc2273">RFC 2273</url>.
      Parameter <c>Receiver</c> defines where the agent is to send
      information about the delivery of inform requests.
      </p>
    <p>If the <seealso marker="snmpa#send_notification/5">
      <c>snmpa:send_notification/5</c></seealso> function is used, an
      <c>NotifyName</c> must be provided. This parameter is used as an
      index in <c>snmpNotifyTable</c>, and the management targets
      defined by that single entry is used.
      </p>
    <p>The <seealso marker="snmpa#send_notification/6">
      <c>snmpa:send_notification/6</c></seealso> function is the most general
      version of the function. A <c>ContextName</c> must be specified,
      from which the notification is sent. If this parameter is
      not specified, the default context (<c>""</c>) is used.
      </p>
    <p>The <c>send_trap</c> function is kept for backward
      compatibility and is not to be used in new code. Applications
      that use this function will
      continue to work. <c>snmpNotifyName</c> is used as the
      community string by the agent when a notification is sent.
      </p>

    <section>
      <title>Notification Sending</title>
      <p>The simplest way to send a notification is to call the function
        <seealso marker="snmpa#send_notification/3">
        <c>snmpa:send_notification(Agent, Notification,
        no_receiver)</c></seealso>.
        The agent then performs a <c>get</c> operation to retrieve the
        object values that are defined in the notification
        specification (with the TRAP-TYPE or NOTIFICATION-TYPE macros).
        The notification is sent to all managers defined in the target
        and notify tables, either unacknowledged as traps, or
        acknowledged as inform requests.
        </p>
      <p>If the caller of the function wants to know whether
        acknowledgments are received for a certain notification
        (provided it is sent as an inform), parameter <c>Receiver</c>
        can be specified as <c>{Tag, ProcessName}</c>
        (for details, see
        <seealso marker="snmp_app"><c>snmp</c></seealso> and the
        <seealso marker="snmp"><c>snmp</c></seealso> module in the
        Reference Manual). In this case, the agent sends a message
        <c>{snmp_notification, Tag, {got_response, ManagerAddr}}</c> or
        <c>{snmp_notification, Tag, {no_response, ManagerAddr}}</c> for
        each management target.
        </p>
      <p>Sometimes it is not possible to retrieve the values for some
        objects in the notification specification with a
        <c>get</c> operation. However, they are known when the
        <c>send_notification</c> function is called. This is true if
        an object is an element in a table. It is possible to specify the
        values of some objects to the function
        <seealso marker="snmpa#send_notification/4">
        <c>snmpa:send_notification(Agent, Notification, Receiver,
        Varbinds)</c></seealso>. In this function, <c>Varbinds</c> is a list of
        <c>Varbind</c>s, where each <c>Varbind</c> is one of the following:
        </p>
      <list type="bulleted">
        <item><p><c>{Variable, Value}</c>, where <c>Variable</c> is the
         symbolic name of a scalar variable referred to in the notification
         specification.</p>
        </item>
        <item><p><c>{Column, RowIndex, Value}</c>, where <c>Column</c> is
         the symbolic name of a column variable. <c>RowIndex</c> is a
         list of indexes for the specified element. If this is the
         case, the OID sent in the trap is the
         <c>RowIndex</c> appended to the OID for the
         table column. This is the OID that specifies the element.</p>
        </item>
        <item><p><c>{OID, Value}</c>, where <c>OID</c> is the OID for an
         instance of an object, scalar variable, or column variable.</p>
        </item>
      </list>
      <p>For example, to specify that <c>sysLocation</c> is to have the
        value <c>"upstairs"</c> in the notification. One of the following
        can be used:
        </p>
      <list type="bulleted">
        <item><c>{sysLocation, "upstairs"}</c></item>
        <item><c>{[1,3,6,1,2,1,1,6,0], "upstairs"}</c></item>
      </list>
      <p>It is also possible to specify names and values for extra
        variables that are to be sent in the notification, but are not
        defined in the notification specification.
        </p>
      <p>The notification is sent to all management targets found in
        the tables. However, ensure that each manager has access to
        the variables in the notification. If a variable is outside the
        Manager's MIB view, this Manager does not receive the
        notification.
        </p>
      <note>
        <p>By definition, it is not possible to send objects with the
          access <c>not-accessible</c> in notifications. However,
          historically this is often done and we therefore allow
          it in notification sending. If a variable has the access
          <c>not-accessible</c>, the user must provide a value for the
          variable in the <c>Varbinds</c> list. An agent cannot perform a
          <c>get</c> operation to retrieve this value.
          </p>
      </note>
    </section>

    <section>
      <title>Notification Filters</title>
      <p><em>Notification filters</em> can be added to an agent.
        These filters are called when a notification is to be sent.
        Their purpose is to allow modification, suppression, or
        other type of actions.</p>
      <p>A notification filter is a module implementing the
        <seealso marker="snmpa_notification_filter">
        <c>snmpa_notification_filter</c></seealso> behavior.
        A filter is added/deleted using the functions
        <seealso marker="snmpa#register_notification_filter">
        <c>snmpa:register_notification_filter</c></seealso> and
        <seealso marker="snmpa#unregister_notification_filter">
        <c>snmpa:unregister_notification_filter</c></seealso>.</p>
      <p>Unless otherwise specified, the order of the registered filters
        is the order in which they are registered.</p>
    </section>

    <section>
      <title>Subagent Path</title>
      <p>If a value for an object is not specified to the
        <seealso marker="snmpa#send_notification/3">
        <c>snmpa:send_notification</c></seealso> function, the subagent performs
        a <c>get</c> operation to retrieve it. If the object is not implemented
        in this subagent, its parent agent tries to perform a
        <c>get</c> operation to retrieve it. If the object is not implemented
        in this agent either, it forwards the object to its parent, and
        so on. Eventually the master agent is reached and then
        all unknown object values must be resolved. If some object is
        unknown even to the master agent, this is regarded as an error
        and is reported with a call to <c>user_err/2</c> of the
        error report module. No notifications are sent in this case.
        </p>
      <p>For a given notification, the variables, which are referred to
        in the notification specification, must be implemented by the
        agent that has the MIB loaded, or by some parent to this
        agent. Otherwise the application must provide values for the
        unknown variables. The application must also provide values for
        all elements in tables.
        </p>
    </section>
  </section>

  <section>
    <title>Discovery</title>
    <marker id="discovery"></marker>
    <p>The <em>sender</em> is <em>authoritative</em> for messages containing
      payload that does <em>not</em> expect a response (for example
      SNMPv2-Trap, Response, or Report PDU).</p>
    <p>The <em>receiver</em> is <em>authoritative</em> for messages containing
      payload that expects a response (for example
      Get, GetNext, Get-Bulk, Set, or Inform PDU).</p>
    <p>The agent can both perform and respond to discovery.</p>
    <p>The agent responds to discovery autonomously, without interaction
      by the user.</p> 
    <p>Initiating discovery to a manager is done by calling the
      <seealso marker="snmpa#discovery"><c>snmpa:discovery</c></seealso>
      function. The <c>EngineId</c> field of the target (manager) entry in the
      <seealso marker="snmp_agent_config_files#target_addr">
      <c>target_addr.conf</c></seealso> file must have the value
      <c>discovery</c>. Notice that if the manager does not respond,
      the <c>Timeout</c> and <c>RetryCount</c>
      fields decide how long the function hangs before it returns.</p>
    <p>Discovery can only be performed to one manager at a time.</p>
  </section>

</chapter>

