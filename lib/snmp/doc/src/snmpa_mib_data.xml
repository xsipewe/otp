<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>2013</year><year>2016</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    
    </legalnotice>

    <title>snmpa_mib_data</title>
    <prepared></prepared>
    <responsible></responsible>
    <docno></docno>
    <checked></checked>
    <date>2016-12-15</date>
    <rev></rev>
    <file>snmpa_mib_data.xml</file>
  </header>

  <module>snmpa_mib_data</module>
  <modulesummary>Behavior module for the SNMP agent mib-server
  data module.</modulesummary>
  <description>
    <p>This module defines the behavior of the SNMP agent <c>mib-server</c>
    data module.</p>
    <p>The functions in this module must be exported from an
      <c>snmpa_mib_data</c>-compliant module.</p>
    <p>Notice that the data extracted from the imported (loaded)
    MIBs are stored partly by the <c>mib-server</c> and partly by the
    <c>symbolic-store</c> server. For details, see the default
    <c>mib-server</c> data module, <c>snmpa_mib_data_tttn</c>.</p>
  </description>

  <section>
    <title>Callback Functions</title>
    <p>The following functions must be exported from a
    <c>mib-server</c> data callback module: </p>
    <marker id="new"></marker>
  </section>

  <funcs>
    <func>
      <name>Module:new(Storage) -> State</name>
      <fsummary>Create new (mib-server) data instance.</fsummary>
      <type>
        <v>Storage = mib_storage()</v>
        <v>State = term()</v>
      </type>
      <desc>
        <p>Creates a new <c>mib-server</c> data instance.</p>
        <marker id="close"></marker>
      </desc>
    </func>

    <func>
      <name>Module:close(State) -> void()</name>
      <fsummary>Close the mib-server data instance.</fsummary>
      <type>
        <v>State = term()</v>
      </type>
      <desc>
        <p>Closes the <c>mib-storage</c>.</p>
        <marker id="sync"></marker>
      </desc>
    </func>

    <func>
      <name>Module:sync(State) -> void()</name>
      <fsummary>Synchronize to disc.</fsummary>
      <type>
        <v>State = term()</v>
      </type>
      <desc>
        <p>Synchronizes (writes to disc, if possible) the <c>mib-server</c>
        data. This depends on the <c>mib_storage</c> option, and has only
	an effect if the <c>mib-storage</c> option has a disc component
	(such as <c>dets</c>, or <c>ets</c> with a file).</p>
        <marker id="load_mib"></marker>
      </desc>
    </func>

    <func>
      <name>Module:load_mib(State, Filename, MeOverride, TeOverride)
        -> {ok, NewState} | {error, Reason}</name>
      <fsummary>Load a MIB into the mib-server.</fsummary>
      <type>
        <v>State = NewState = term()</v>
        <v>Filename = filename()</v>
        <v>MeOverride = boolean()</v>
        <v>TeOverride = boolean()</v>
        <v>Reason = already_loaded | term()</v>
      </type>
      <desc>
        <p>Loads the MIB specified by argument <c>Filename</c>
	into the <c>mib-server</c>.
	Arguments <c>MeOverride</c> and <c>TeOverride</c> specify how
	the <c>mib-server</c> is to handle duplicate mib- and trap-
	entries.</p>
        <marker id="unload_mib"></marker>
      </desc>
    </func>

    <func>
      <name>Module:unload_mib(State, Filename)
        -> {ok, NewState} | {error, Reason}</name>
      <fsummary>Unload MIB from the mib-server.</fsummary>
      <type>
        <v>State = NewState = term()</v>
        <v>Filename = filename()</v>
        <v>Reason = not_loaded | term()</v>
      </type>
      <desc>
        <p>Unloads the MIB specified by argument <c>Filename</c>
	from the <c>mib-server</c>.</p>
        <marker id="lookup"></marker>
      </desc>
    </func>

    <func>
      <name>Module:lookup(State, Oid) -> Reply</name>
      <fsummary>Find the mib-entry corresponding to the OID.</fsummary>
      <type>
        <v>State = term()</v>
        <v>Reply = {variable, ME} | {table_column, ME, TEOid}
          | {subagent, SAPid, SAOid} | {false, Reason}</v>
        <v>Oid = TEOid = SAOid = oid()</v>
        <v>SAPid = pid()</v>
        <v>ME = me()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Finds the <c>mib-entry</c> corresponding to the <c>Oid</c>.
	If it is a variable, the <c>Oid</c> must be
	&lt;Oid for var&gt;.0
	and if it is a table, <c>Oid</c> must be
	&lt;table&gt;.&lt;entry&gt;.&lt;col&gt;.&lt;any&gt;.</p>
        <marker id="next"></marker>
      </desc>
    </func>

    <func>
      <name>Module:next(State, Oid, MibView) -> Reply</name>
      <fsummary>Find the lexicographically next OID.</fsummary>
      <type>
        <v>State = term()</v>
        <v>Reply = false | endOfTable | {subagent, SAPid, SAOid}
          | {variable, ME, VarOid} | {table, TableOid, TableRestOid, ME}</v>
        <v>Oid = SAOid = VarOid = TableOid = TableRestOid = oid()</v>
        <v>SAPid = pid()</v>
        <v>ME = me()</v>
      </type>
      <desc>
        <p>Finds the lexicographically next OID.</p>
        <marker id="register_subagent"></marker>
      </desc>
    </func>

    <func>
      <name>Module:register_subagent(State, Oid, Pid) -> Reply</name>
      <fsummary>Register the subagent.</fsummary>
      <type>
        <v>State = NewState = term()</v>
        <v>Reply = {ok, NewState} | {error, Reason}</v>
        <v>Oid = oid()</v>
        <v>Pid = pid()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Registers the subagent, process
	handling part of the MIB tree.</p>
        <marker id="unregister_subagent"></marker>
      </desc>
    </func>

    <func>
      <name>Module:unregister_subagent(State, PidOrOid) -> Reply</name>
      <fsummary>Unregister the subagent.</fsummary>
      <type>
        <v>State = NewState = term()</v>
        <v>Reply = {ok, NewState} | {ok, NewState, Pid} | {error, Reason}</v>
        <v>PidOrOid = pid() | oid()</v>
        <v>Pid = pid()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Unregisters the subagent, handling part of the MIB tree,
	as specified by the <c>oid()</c> or <c>pid()</c>
	(<c>PidOrOid</c>).</p>
        <p>When unregister the subagent using an <c>oid()</c>, the <c>pid()</c>
	of the process handling the subtree is also returned.</p>
        <marker id="dump"></marker>
      </desc>
    </func>

    <func>
      <name>Module:dump(State, Destination) -> Reply</name>
      <fsummary>Unregister the subagent.</fsummary>
      <type>
        <v>State = term()</v>
        <v>Reply = ok | {error, Reason}</v>
        <v>Destination = io | filename()</v>
        <v>Pid = pid()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Dump the <c>mib-server</c> data to <c>stdio</c>
        (<c>Destination</c> = <c>io</c>) or the specified file.</p>
        <marker id="which_mib"></marker>
      </desc>
    </func>

    <func>
      <name>Module:which_mib(State, Oid) -> Reply</name>
      <fsummary>Retrieve the MIB file for an OID.</fsummary>
      <type>
        <v>State = term()</v>
        <v>Reply = {ok, MibFile} | {error, Reason}</v>
        <v>Oid = oid()</v>
        <v>MibFile = string()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Retrieves the MIB file to which a specified <c>oid()</c> belongs.</p>
        <marker id="which_mibs"></marker>
      </desc>
    </func>

    <func>
      <name>Module:which_mibs(State) -> Reply</name>
      <fsummary>Retrieve all loaded MIB files.</fsummary>
      <type>
        <v>State = term()</v>
        <v>Reply = [{MibName, Filename}]</v>
        <v>MibName = atom()</v>
        <v>Filename = string()</v>
      </type>
      <desc>
        <p>Retrieves all loaded MIB files.</p>
        <marker id="whereis_mib"></marker>
      </desc>
    </func>

    <func>
      <name>Module:whereis_mib(State, MibName) -> Reply</name>
      <fsummary>Retrieve the MIB file for the MIB.</fsummary>
      <type>
        <v>State = term()</v>
        <v>MibName = atom()</v>
        <v>Reply = {ok, Filename} | {error, Reason}</v>
        <v>Filename = string()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Retrieves the MIB file for the MIB.</p>
        <marker id="info"></marker>
      </desc>
    </func>

    <func>
      <name>Module:info(State) -> Reply</name>
      <fsummary>Retrieve miscellaneous information for the MIB data.</fsummary>
      <type>
        <v>State = term()</v>
        <v>Reply = {ok, Filename} | {error, Reason}</v>
        <v>Filename = string()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Retrieves miscellaneous information for the MIB data.</p>
        <p>This is a utility function used to inspect, for example,
	memory usage, in a simple way. </p>
        <marker id="backup"></marker>
      </desc>
    </func>

    <func>
      <name>Module:backup(State, BackupDir) -> Reply</name>
      <fsummary>Perform a backup of the mib-server data.</fsummary>
      <type>
        <v>State = term()</v>
        <v>Reply = ok | {error, Reason}</v>
        <v>BackupDir = string()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Performs a backup of the <c>mib-server</c> data.</p>
        <p>Notice that it depends on the implementation (and
	if the <c>mib-storage</c> is used) if a backup is possible.</p>
        <marker id="code_change"></marker>
      </desc>
    </func>

    <func>
      <name>Module:code_change(Destination, Vsn, Extra, State) -> NewState
      </name>
      <fsummary>Perform a code change.</fsummary>
      <type>
        <v>Destination = up | down</v>
        <v>Vsn = term()</v>
        <v>Extra = term()</v>
        <v>State = NewState = term()</v>
      </type>
      <desc>
        <p>Performs a code change (upgrade or downgrade).</p>
        <p>For more information about arguments <c>Vsn</c> and <c>Extra</c>,
	see <seealso marker="stdlib:gen_server">
        <c>stdlib:gen_server</c></seealso>.</p>
      </desc>
    </func>
  </funcs>
  
</erlref>

