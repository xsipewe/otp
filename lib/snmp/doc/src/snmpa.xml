<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>2004</year><year>2016</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.

    </legalnotice>

    <title>snmpa</title>
    <prepared></prepared>
    <responsible></responsible>
    <docno></docno>
    <approved></approved>
    <checked></checked>
    <date>2016-11-21</date>
    <rev></rev>
    <file>snmpa.xml</file>
  </header>
  <module>snmpa</module>
  <modulesummary>Interface functions to the SNMP toolkit agent.</modulesummary>
  <description>
    <p>This module contains interface functions to the SNMP agent.</p>
    <marker id="data_types"></marker>
  </description>

  <datatypes>
    <datatype>
      <name name="oid() = [byte()]"/>
      <desc>
         <p>Represents an ASN.1 OID.</p>
      </desc>
    </datatype>
    <datatype>
      <name name="atl_type() = read | write | read_write"/>
    </datatype>
    <datatype>
      <name name="notification_delivery_info() =
        #snmpa_notification_delivery_info{}"/>
      <desc>
        <p>The record <c><![CDATA[snmpa_notification_delivery_info]]></c>
          contains the following fields:</p>
        <taglist>
          <tag><c><![CDATA[tag = term()]]></c></tag>
          <item>
            <p>A user-defined identity representing this notification send
              operation.</p>
          </item>
          <tag><c><![CDATA[mod = module()]]></c></tag>
          <item>
          <p>A module implementing the
            <seealso marker="snmpa_notification_delivery_info_receiver">
            <c>snmpa_notification_delivery_info_receiver</c></seealso>
            behavior. The information functions of this module are called at
            various stages of delivery.</p>
          </item>
          <tag><c><![CDATA[extra = term()]]></c></tag>
          <item>
            <p>Any extra information the user wants to have supplied
              when the functions in the callback module are called.</p>
          </item>
        </taglist>
        <marker id="add_agent_caps"></marker>
      </desc>
    </datatype>
  </datatypes>

  <funcs>
    <func>
      <name>add_agent_caps(SysORID, SysORDescr) -> SysORIndex</name>
      <fsummary>Add an AGENT-CAPABILITY definition to the agent.</fsummary>
      <type>
        <v>SysORID = oid()</v>
        <v>SysORDescr = string()</v>
        <v>SysORIndex = integer()</v>
      </type>
      <desc>
        <p>Adds an AGENT-CAPABILITY
          statement to the <c>sysORTable</c> in the agent. The table is
          defined in the SNMPv2-MIB.</p>
        <marker id="del_agent_caps"></marker>
      </desc>
    </func>

    <func>
      <name>del_agent_caps(SysORIndex) -> void()</name>
      <fsummary>Delete an AGENT-CAPABILITY definition from the agent.</fsummary>
      <type>
        <v>SysORIndex = integer()</v>
      </type>
      <desc>
        <p>Deletes an AGENT-CAPABILITY
          statement to the <c>sysORTable</c> in the agent. This table is
          defined in the SNMPv2-MIB.</p>
          <marker id="get_agent_caps"></marker>
      </desc>
    </func>

    <func>
      <name>get_agent_caps() -> [[SysORIndex, SysORID, SysORDescr, SysORUpTime]]
      </name>
      <fsummary>Return all AGENT-CAPABILITY definitions in the agent.</fsummary>
      <type>
        <v>SysORIndex = integer()</v>
        <v>SysORId = oid()</v>
        <v>SysORDescr = string()</v>
        <v>SysORUpTime = integer()</v>
      </type>
      <desc>
        <p>Returns all AGENT-CAPABILITY statements in the <c>sysORTable</c>
          in the agent. This table is defined in the SNMPv2-MIB.</p>
        <marker id="get"></marker>
      </desc>
    </func>

    <func>
      <name>get(Agent, Vars) -> Values | {error, Reason}</name>
      <name>get(Agent, Vars, Context) -> Values | {error, Reason}</name>
      <fsummary>Perform a get operation on the agent.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>Vars = [oid()]</v>
        <v>Context = string()</v>
        <v>Values = [term()]</v>
        <v>Reason = {atom(), oid()}</v>
      </type>
      <desc>
        <p>Performs a <c>get</c> operation on the agent. All loaded MIB
          objects are visible in this operation. The agent calls the
          corresponding instrumentation functions just as if it was a
          <c>get</c> request coming from a manager.</p>
        <p>Notice that the request-specific parameters (such as
          <seealso marker="#current_request_id">
          <c>current_request_id</c></seealso>)
          are not accessible for the instrumentation functions if this
          function is used.</p>
          <marker id="get_next"></marker>
      </desc>
    </func>

    <func>
      <name>get_next(Agent, Vars) -> Values | {error, Reason}</name>
      <name>get_next(Agent, Vars, Context) -> Values | {error, Reason}</name>
      <fsummary>Perform a get-next operation on the agent.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>Vars = [oid()]</v>
        <v>Context = string()</v>
        <v>Values = [{oid(), term()}]</v>
        <v>Reason = {atom(), oid()}</v>
      </type>
      <desc>
        <p>Performs a <c>get-next</c> operation on the agent. All loaded MIB
          objects are visible in this operation. The agent calls the
          corresponding instrumentation functions just as if it was a
          <c>get</c> request coming from a manager. </p>
        <p>Notice that the request-specific parameters (such as
          <c>snmpa:current_request_id/0</c>) are not accessible for the
          instrumentation functions if this function is used.</p>
        <marker id="backup"></marker>
        <!-- <marker id="get_symbolic_store_db"></marker> -->
      </desc>
    </func>
<!--
    <func>
      <name>get_symbolic_store_db() -> Db</name>
      <fsummary>Retrieve the symbolic store database reference.</fsummary>
      <type>
        <v>Db = term()</v>
      </type>
      <desc>
        <p>Retrieves the symbolic store database reference. This is used
          for faster access to the database using the functions
          <c>int_to_enum/3</c>, <c>enum_to_int/3</c>, <c>name_to_oid/2</c>,
          <c>oid_to_name/2</c>. </p>
        <marker id="backup"></marker>
      </desc>
    </func>
-->
    <func>
      <name>backup(BackupDir) -> ok | {error, Reason}</name>
      <name>backup(Agent, BackupDir) -> ok | {error, Reason}</name>
      <fsummary>Backup agent data.</fsummary>
      <type>
        <v>BackupDir = string()</v>
        <v>Agent = pid() | atom()</v>
        <v>Reason = backup_in_progress | term()</v>
      </type>
      <desc>
        <p>Back up persistent/permanent data handled by the agent
          (such as local-db, MIB data, and VACM).</p>
        <p>Data stored by Mnesia is not handled.</p>
        <p><c>BackupDir</c> cannot be identical to <c>DbDir</c>.</p>
        <p>Simultaneous backup calls are <em>not</em> allowed.
	That is, two different processes cannot simultaneously
	successfully call this function. One of them is first,
	and succeeds. The second fails with error reason
	<c>backup_in_progress</c>.</p>
        <marker id="info"></marker>
      </desc>
    </func>

    <func>
      <name>info() -> [{Key, Value}]</name>
      <name>info(Agent) -> [{Key, Value}]</name>
      <fsummary>Return information about the agent.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
      </type>
      <desc>
        <p>Returns a list (a dictionary) containing information about
	the agent. Information includes loaded MIBs, registered
	subagents, and some information about the memory allocation.</p>
	<p>As from Erlang version 4.4 the format of the information has
        changed. To convert the information to the old format, call the
	<seealso marker="#old_info_format"><c>old_info_format</c></seealso>
	function.</p>
        <marker id="old_info_format"></marker>
      </desc>
    </func>

    <func>
      <name>old_info_format(NewInfo) -> OldInfo</name>
      <fsummary>Return information about the agent.</fsummary>
      <type>
        <v>OldInfo = NewInfo = [{Key, Value}]</v>
      </type>
      <desc>
        <p>As from Erlang version 4.4 the format of the information has
          changed. This function converts to the old (pre-4.4) information
          format.</p>
        <marker id="load_mib"></marker>
      </desc>
    </func>

    <func>
      <name>load_mib(Mib) -> ok | {error, Reason}</name>
      <name>load_mib(Agent, Mib) -> ok | {error, Reason}</name>
      <fsummary>Load single MIB into the agent.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>MibName = string()</v>
        <v>Reason = already_loaded | term()</v>
      </type>
      <desc>
        <p>Loads a single MIB into an agent. The <c>MibName</c>
	is the name of the MIB, including the path to where the compiled
	MIB is found, for example:</p>
	<code type="none">
Dir = code:priv_dir(my_app) ++ "/mibs/",
snmpa:load_mib(snmp_master_agent, Dir ++ "MY-MIB").</code>
        <marker id="load_mibs"></marker>
      </desc>
    </func>

    <func>
      <name>load_mibs(Mibs) -> ok | {error, Reason}</name>
      <name>load_mibs(Mibs, Force) -> ok | {error, Reason}</name>
      <name>load_mibs(Agent, Mibs) -> ok | {error, Reason}</name>
      <name>load_mibs(Agent, Mibs, Force) -> ok | {error, Reason}</name>
      <fsummary>Load MIBs into the agent.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>Mibs = [MibName]</v>
        <v>Force = boolean()</v>
        <v>MibName = string()</v>
        <v>Reason = {'load aborted at', MibName, InternalReason}</v>
        <v>InternalReason = already_loaded | term()</v>
      </type>
      <desc>
        <p>Loads MIBs into an agent. If the agent cannot load all
	MIBs (the default value of argument <c>Force</c> is <c>false</c>),
	it indicates where loading was aborted. The <c>MibName</c>
	is the name of the MIB, including the path to where the compiled
	mib is found, for example:</p>
	<code type="none">
Dir = code:priv_dir(my_app) ++ "/mibs/",
snmpa:load_mibs(snmp_master_agent, [Dir ++ "MY-MIB"]).</code>
	<p>If <c>Force = true</c>, the agent continues attempting
	to load each MIB even after failing to load a previous MIB. Use with 
	care.</p>
        <marker id="unload_mib"></marker>
      </desc>
    </func>

    <func>
      <name>unload_mib(Mib) -> ok | {error, Reason}</name>
      <name>unload_mib(Agent, Mib) -> ok | {error, Reason}</name>
      <fsummary>Unload single MIB from the agent.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>MibName = string()</v>
        <v>Reason = not_loaded | term()</v>
      </type>
      <desc>
        <p>Unloads a single MIB from an agent.</p>
        <marker id="unload_mibs"></marker>
      </desc>
    </func>

    <func>
      <name>unload_mibs(Mibs) -> ok | {error, Reason}</name>
      <name>unload_mibs(Mibs, Force) -> ok | {error, Reason}</name>
      <name>unload_mibs(Agent, Mibs) -> ok | {error, Reason}</name>
      <name>unload_mibs(Agent, Mibs, Force) -> ok | {error, Reason}</name>
      <fsummary>Unload MIBs from the agent.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>Mibs = [MibName]</v>
        <v>Force = boolean()</v>
        <v>MibName = string()</v>
        <v>Reason = {'unload aborted at', MibName, InternalReason}</v>
        <v>InternalReason = not_loaded | term()</v>
      </type>
      <desc>
        <p>Unloads MIBs from an agent. If it cannot unload all MIBs
	(the default value of argument <c>Force</c> is <c>false</c>),
	it indicates where unloading was aborted.</p>
	<p>If <c>Force = true</c>, the agent continues attempting
	to unload each MIB even after failing to unload a previous MIB.
	Use with care.</p>
        <marker id="which_mibs"></marker>
      </desc>
    </func>

    <func>
      <name>which_mibs() -> Mibs</name>
      <name>which_mibs(Agent) -> Mibs</name>
      <fsummary>Get a list of all the loaded MIBs.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>Mibs = [{MibName, MibFile}]</v>
        <v>MibName = atom()</v>
        <v>MibFile = string()</v>
      </type>
      <desc>
        <p>Retrieves the list of all the MIBs loaded into this agent. Default
          is the master agent.</p>
        <marker id="whereis_mib"></marker>
      </desc>
    </func>

    <func>
      <name>whereis_mib(MibName) -> {ok, MibFile} | {error, Reason}</name>
      <name>whereis_mib(Agent, MibName) -> {ok, MibFile} | {error, Reason}
      </name>
      <fsummary>Get the path to the MIB file.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>MibName = atom()</v>
        <v>MibFile = string()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Get the full path to the (compiled) MIB file.</p>
        <marker id="current_request_id"></marker>
        <marker id="current_context"></marker>
        <marker id="current_community"></marker>
        <marker id="current_address"></marker>
      </desc>
    </func>

    <func>
      <name>current_request_id() -> {value, RequestId} | false</name>
      <name>current_context() -> {value, Context} | false</name>
      <name>current_community() -> {value, Community} | false</name>
      <name>current_address() -> {value, Address} | false</name>
      <fsummary>Get the request-id, context, community, and address of
        the current request.</fsummary>
      <type>
        <v>RequestId = integer()</v>
        <v>Context = string()</v>
        <v>Community = string()</v>
        <v>Address = term()</v>
      </type>
      <desc>
        <p>Gets the request-id, context, community, and address of the 
          request currently being processed by the agent.</p>
        <p>Notice that these functions are intended to be called by the
          instrumentation functions and <em>only</em> if they are
          executed in the context of the agent process (for example, it does
          not work if called from a spawned process).</p>
        <marker id="enum_to_int"></marker>
      </desc>
    </func>

    <func>
      <name>enum_to_int(Name, Enum) -> {value, Int} | false</name>
      <name>enum_to_int(Db, Name, Enum) -> {value, Int} | false</name>
      <fsummary>Convert an enum value to an integer.</fsummary>
      <type>
        <v>Db = term()</v>
        <v>Name = atom()</v>
        <v>Enum = atom()</v>
        <v>Int = int()</v>
      </type>
      <desc>
        <p>Converts the symbolic value <c>Enum</c> to the
          corresponding integer of the enumerated object or type
          <c>Name</c> in a MIB. The MIB must be loaded.
          </p>
        <p><c>false</c> is returned if the object or type is not
          defined in any loaded MIB, or if it does not define the
          symbolic value as enumerated.
          </p>
        <p><c>Db</c> is a reference to the symbolic store database
          (retrieved by a call to <c>get_symbolic_store_db/0</c>).</p>
        <marker id="int_to_enum"></marker>
      </desc>
    </func>

    <func>
      <name>int_to_enum(Name, Int) -> {value, Enum} | false</name>
      <name>int_to_enum(Db, Name, Int) -> {value, Enum} | false</name>
      <fsummary>Convert an integer to an enum value.</fsummary>
      <type>
        <v>Db = term()</v>
        <v>Name = atom()</v>
        <v>Int = int()</v>
        <v>Enum = atom()</v>
      </type>
      <desc>
        <p>Converts the integer <c>Int</c> to the corresponding
          symbolic value of the enumerated object or type <c>Name</c> in
          a MIB. The MIB must be loaded.
          </p>
        <p><c>false</c> is returned if the object or type is not
          defined in any loaded MIB, or if it does not define the
          symbolic value as enumerated.
          </p>
        <p><c>Db</c> is a reference to the symbolic store database
          (retrieved by a call to <c>get_symbolic_store_db/0</c>).</p>
        <marker id="name_to_oid"></marker>
      </desc>
    </func>

    <func>
      <name>name_to_oid(Name) -> {value, oid()} | false</name>
      <name>name_to_oid(Db, Name) -> {value, oid()} | false</name>
      <fsummary>Convert a symbolic name to an OID.</fsummary>
      <type>
        <v>Db = term()</v>
        <v>Name = atom()</v>
      </type>
      <desc>
        <p>Looks up the OID of a MIB object, given the
          symbolic name. Notice that the OID is given for the
          object, not for an instance.</p>
        <p><c>false</c> is returned if the object is not defined in any
          loaded MIB.</p>
        <p><c>Db</c> is a reference to the symbolic store database
          (retrieved by a call to <c>get_symbolic_store_db/0</c>).</p>
        <marker id="oid_to_name"></marker>
      </desc>
    </func>

    <func>
      <name>oid_to_name(OID) -> {value, Name} | false</name>
      <name>oid_to_name(Db, OID) -> {value, Name} | false</name>
      <fsummary>Convert an OID to a symbolic name.</fsummary>
      <type>
        <v>Db = term()</v>
        <v>OID = oid()</v>
        <v>Name = atom()</v>
      </type>
      <desc>
        <p>Looks up the symbolic name of a MIB object, given the OID.</p>
        <p><c>false</c> is returned if the object is not defined in any
          loaded MIB. </p>
        <p><c>Db</c> is a reference to the symbolic store database
          (retrieved by a call to <c>get_symbolic_store_db/0</c>). </p>
        <marker id="which_aliasnames"></marker>
      </desc>
    </func>

    <func>
      <name>which_aliasnames() -> Result</name>
      <fsummary>Get all alias names known to the agent.</fsummary>
      <type>
        <v>Result = [atom()]</v>
      </type>
      <desc>
        <p>Retrieves all alias names known to the agent.</p>
        <marker id="which_tables"></marker>
      </desc>
    </func>

    <func>
      <name>which_tables() -> Result</name>
      <fsummary>Get all tables known to the agent.</fsummary>
      <type>
        <v>Result = [atom()]</v>
      </type>
      <desc>
        <p>Retrieves all tables known to the agent.</p>
        <marker id="which_variables"></marker>
      </desc>
    </func>

    <func>
      <name>which_variables() -> Result</name>
      <fsummary>Get all variables known to the agent.</fsummary>
      <type>
        <v>Result = [atom()]</v>
      </type>
      <desc>
        <p>Retrieves all variables known to the agent.</p>
        <marker id="which_notifications"></marker>
      </desc>
    </func>

    <func>
      <name>which_notifications() -> Result</name>
      <fsummary>Get all notifications known to the agent.</fsummary>
      <type>
        <v>Result = [{Name, MibName, Info}]</v>
        <v>Name = atom()</v>
        <v>MibName = atom()</v>
        <v>Info = term()</v>
      </type>
      <desc>
        <p>Retrieves all notifications (and traps) known to the agent.</p>
        <marker id="log_to_txt"></marker>
      </desc>
    </func>

    <func>
      <name>log_to_txt(LogDir)</name>
      <name>log_to_txt(LogDir, Block | Mibs)</name>
      <name>log_to_txt(LogDir, Mibs, Block | OutFile) -> ok | {error, Reason}
      </name>
      <name>log_to_txt(LogDir, Mibs, OutFile, Block | LogName)
        -> ok | {error, Reason}</name>
      <name>log_to_txt(LogDir, Mibs, OutFile, LogName, Block | LogFile)
        -> ok | {error, Reason}</name>
      <name>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block | Start)
        -> ok | {error, Reason}</name>
      <name>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block, Start)
        -> ok | {error, Reason}</name>
      <name>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Start, Stop)
        -> ok | {error, Reason}</name>
      <name>log_to_txt(LogDir, Mibs, OutFile, LogName, LogFile, Block, Start,
        Stop) -> ok | {error, Reason}</name>
      <fsummary>Convert an Audit Trail Log to text format.</fsummary>
      <type>
        <v>LogDir = string()</v>
        <v>Mibs = [MibName]</v>
        <v>MibName = string()</v>
        <v>Block = boolean()</v>
        <v>OutFile = string()</v>
        <v>LogName = string()</v>
        <v>LogFile = string()</v>
        <v>Start = Stop = null | calendar:datetime()
          | {local_time, calendar:datetime()}
          | {universal_time, calendar:datetime()}</v>
        <v>Reason = disk_log_open_error() | file_open_error() | term()</v>
        <v>disk_log_open_error() = {LogName, term()}</v>
        <v>file_open_error() = {OutFile, term()}</v>
      </type>
      <desc>
        <p>Converts an Audit Trail Log to a readable text file.
	<c>OutFile</c> defaults to "./snmpa_log.txt".
	<c>LogName</c> defaults to "snmpa_log".
	<c>LogFile</c> defaults to "snmpa.log". </p>
	<p>Option <c>Block</c> indicates if the log is to be blocked
	during conversion. This can be useful when converting large
	logs (when otherwise the log can wrap during conversion).
	Defaults to <c>true</c>. </p>
	<p>For more information, see
        <seealso marker="snmp#log_to_txt"><c>snmp:log_to_txt</c></seealso>.</p>
        <marker id="log_to_io"></marker>
      </desc>
    </func>

    <func>
      <name>log_to_io(LogDir) ->  ok | {error, Reason}</name>
      <name>log_to_io(LogDir, Block | Mibs) ->  ok | {error, Reason}</name>
      <name>log_to_io(LogDir, Mibs, Block | LogName) -> ok | {error, Reason}
      </name>
      <name>log_to_io(LogDir, Mibs, LogName, Block | LogFile)
        -> ok | {error, Reason}</name>
      <name>log_to_io(LogDir, Mibs, LogName, LogFile, Block | Start)
        -> ok | {error, Reason}</name>
      <name>log_to_io(LogDir, Mibs, LogName, LogFile, Block, Start)
        -> ok | {error, Reason}</name>
      <name>log_to_io(LogDir, Mibs, LogName, LogFile, Start, Stop)
        -> ok | {error, Reason}</name>
      <name>log_to_io(LogDir, Mibs, LogName, LogFile, Block, Start, Stop)
        -> ok | {error, Reason}</name>
      <fsummary>Convert an Audit Trail Log to text format.</fsummary>
      <type>
        <v>LogDir = string()</v>
        <v>Mibs = [MibName]</v>
        <v>MibName = string()</v>
        <v>Block = boolean()</v>
        <v>LogName = string()</v>
        <v>LogFile = string()</v>
        <v>Start = Stop = null | calendar:datetime()
          | {local_time, calendar:datetime()}
          | {universal_time, calendar:datetime()}</v>
        <v>Reason = disk_log_open_error() | file_open_error() | term()</v>
        <v>disk_log_open_error() = {LogName, term()}</v>
        <v>file_open_error() = {OutFile, term()}</v>
      </type>
      <desc>
        <p>Converts an Audit Trail Log to a readable format and
	prints it on stdio.
	<c>LogName</c> defaults to "snmpa_log".
	<c>LogFile</c> defaults to "snmpa.log".</p>
	<p>Option <c>Block</c> indicates if the log is to be blocked
	during conversion. This can be useful when converting large
	logs (when otherwise the log can wrap during conversion).
	Defaults to <c>true</c>. </p>
	<p>For more information, see
        <seealso marker="snmp#log_to_io"><c>snmp:log_to_io</c></seealso>.</p>
        <marker id="change_log_size"></marker>
      </desc>
    </func>

    <func>
      <name>change_log_size(NewSize) -> ok | {error, Reason}</name>
      <fsummary>Change the size of the Audit Trail Log.</fsummary>
      <type>
        <v>NewSize = {MaxBytes, MaxFiles}</v>
        <v>MaxBytes = integer()</v>
        <v>MaxFiles = integer()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Changes the log size of the Audit Trail Log. The application must
          be configured to use the Audit Trail Log function. For information
          on how to change the log size, see
          <seealso marker="kernel:disk_log"><c>kernel:disk_log(3)</c></seealso>.
        </p>
        <p>The change is permanent, as long as the log is not deleted.
          That is, the log size is remembered across reboots. </p>
        <marker id="set_log_type"></marker>
      </desc>
    </func>

    <func>
      <name>set_log_type(NewType) -> {ok, OldType} | {error, Reason}</name>
      <name>set_log_type(Agent, NewType) -> {ok, OldType} | {error, Reason}
      </name>
      <fsummary>Change the type of the Audit Trail Log.</fsummary>
      <type>
        <v>NewType = OldType = atl_type()</v>
        <v>Agent = pid() | atom()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Changes the runtime Audit Trail Log type.</p>
        <p>Notice that this has no effect on the application configuration as
          defined by configuration files, so a node restart reverts the
          configuration to whatever is in those files. </p>
        <p>This function is primarily useful in testing/debugging 
          scenarios. </p>
        <marker id="mib_of"></marker>
      </desc>
    </func>

    <func>
      <name>mib_of(Oid) -> {ok, MibName} | {error, Reason}</name>
      <name>mib_of(Agent, Oid) -> {ok, MibName} | {error, Reason}</name>
      <fsummary>Which MIB an OID belongs to.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>Oid = oid()</v>
        <v>MibName = atom()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Finds the MIB corresponding to an OID. If it is a
          variable, the OID must be
          &lt;OID for var&gt;.0 and if it is a table, OID must be
          &lt;table&gt;.&lt;entry&gt;.&lt;col&gt;.&lt;any&gt;.</p>
        <marker id="me_of"></marker>
      </desc>
    </func>

    <func>
      <name>me_of(Oid) -> {ok, Me} | {error, Reason}</name>
      <name>me_of(Agent, Oid) -> {ok, Me} | {error, Reason}</name>
      <fsummary>Retrieve the MIB entry of an OID.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>Oid = oid()</v>
        <v>Me = #me{}</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Finds the MIB entry corresponding to an OID. If it is a
          variable, the OID must be
          &lt;OID for var&gt;.0 and if it is a table, OID must be
          &lt;table&gt;.&lt;entry&gt;.&lt;col&gt;.&lt;any&gt;.</p>
        <marker id="invalidate_mibs_cache"></marker>
      </desc>
    </func>

    <func>
      <name>invalidate_mibs_cache() -> void()</name>
      <name>invalidate_mibs_cache(Agent) -> void()</name>
      <fsummary>Invalidate the MIB server cache.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
      </type>
      <desc>
        <p>Invalidates the MIB server cache.</p>
        <p>The entire contents of the cache is deleted. </p>
        <marker id="enable_mibs_cache"></marker>
      </desc>
    </func>

    <func>
      <name>enable_mibs_cache() -> void()</name>
      <name>enable_mibs_cache(Agent) -> void()</name>
      <fsummary>Enable the MIB server cache.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
      </type>
      <desc>
        <p>Enables the MIB server cache.</p>
        <marker id="disable_mibs_cache"></marker>
      </desc>
    </func>

    <func>
      <name>disable_mibs_cache() -> void()</name>
      <name>disable_mibs_cache(Agent) -> void()</name>
      <fsummary>Disable the MIB server cache.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
      </type>
      <desc>
        <p>Disables the MIB server cache.</p>
        <marker id="which_mibs_cache_size"></marker>
      </desc>
    </func>

    <func>
      <name>which_mibs_cache_size() -> void()</name>
      <name>which_mibs_cache_size(Agent) -> void()</name>
      <fsummary>The size of the MIB server cache.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
      </type>
      <desc>
        <p>Retreives the size of the MIB server cache.</p>
        <marker id="gc_mibs_cache"></marker>
      </desc>
    </func>

    <func>
      <name>gc_mibs_cache() -> {ok, NumElementsGCed} | {error, Reason}</name>
      <name>gc_mibs_cache(Agent)
        -> {ok, NumElementsGCed} | {error, Reason}</name>
      <name>gc_mibs_cache(Age)
        -> {ok, NumElementsGCed} | {error, Reason}</name>
      <name>gc_mibs_cache(Agent, Age)
        -> {ok, NumElementsGCed} | {error, Reason}</name>
      <name>gc_mibs_cache(Age, GcLimit)
        -> {ok, NumElementsGCed} | {error, Reason}</name>
      <name>gc_mibs_cache(Agent, Age, GcLimit)
        -> {ok, NumElementsGCed} | {error, Reason}</name>
      <fsummary>Perform MIB server cache gc.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>Age = integer() > 0</v>
        <v>GcLimit = integer() > 0 | infinity</v>
        <v>NumElementsGCed = integer() >= 0</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Performs a MIB server cache gc.
          This can be done regardless of the value of option <c>autogc</c>. 
          The <c>NumElementsGCed</c> value indicates how many
          elements were removed from the cache. </p>
        <marker id="enable_mibs_cache_autogc"></marker>
      </desc>
    </func>

    <func>
      <name>enable_mibs_cache_autogc() -> void()</name>
      <name>enable_mibs_cache_autogc(Agent) -> void()</name>
      <fsummary>Enable automatic gc of the MIB server cache.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
      </type>
      <desc>
        <p>Enables automatic gc of the MIB server cache.</p>
        <marker id="disable_mibs_cache_autogc"></marker>
      </desc>
    </func>

    <func>
      <name>disable_mibs_cache_autogc() -> void()</name>
      <name>disable_mibs_cache_autogc(Agent) -> void()</name>
      <fsummary>Disable automatic gc of the MIB server cache.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
      </type>
      <desc>
        <p>Disables automatic gc of the MIB server cache.</p>
        <marker id="update_mibs_cache_age"></marker>
      </desc>
    </func>

    <func>
      <name>update_mibs_cache_age(NewAge) -> ok | {error, Reason}</name>
      <name>update_mibs_cache_age(Agent, NewAge) -> ok | {error, Reason}</name>
      <fsummary>Change the MIB server cache age property.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>NewAge = integer() > 0</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Changes the MIB server cache <c>age</c> property.</p>
        <marker id="update_mibs_cache_gclimit"></marker>
      </desc>
    </func>

    <func>
      <name>update_mibs_cache_gclimit(NewGcLimit) -> ok | {error, Reason}</name>
      <name>update_mibs_cache_gclimit(Agent, NewGCLimit)
        -> ok | {error, Reason}</name>
      <fsummary>Change the MIB server cache gclimit property.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>NewGcLimit = integer() > 0 | infinity</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Changes the MIB server cache <c>gclimit</c> property.</p>
        <marker id="register_notification_filter"></marker>
      </desc>
    </func>

    <func>
      <name>register_notification_filter(Id, Mod, Data)
        -> ok | {error, Reason}</name>
      <name>register_notification_filter(Agent, Id, Mod, Data)
        -> ok | {error, Reason}</name>
      <name>register_notification_filter(Id, Mod, Data, Where)
        -> ok | {error, Reason}</name>
      <name>register_notification_filter(Agent, Id, Mod, Data, Where)
        -> ok | {error, Reason}</name>
      <fsummary>Register a notification filter.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>Id = filter_id()</v>
        <v>filter_id() = term()</v>
        <v>Mod = atom()</v>
        <v>Data = term()</v>
        <v>Where = filter_position()</v>
        <v>Reason = term()</v>
        <v>filter_position() = first | last | {insert_before, filter_id()}
          | {insert_after, filter_id()} </v>
      </type>
      <desc>
        <p>Registers a notification filter.</p>
        <p><c>Mod</c> is a module implementing the
          <c>snmpa_notification_filter</c> behavior.</p>
        <p><c>Data</c> is passed on to the filter when calling the
          functions of the behavior.</p>
        <marker id="unregister_notification_filter"></marker>
      </desc>
    </func>

    <func>
      <name>unregister_notification_filter(Id) -> ok | {error, Reason}</name>
      <name>unregister_notification_filter(Agent, Id) -> ok | {error, Reason}
      </name>
      <fsummary>Unregister a notification filter.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>Id = filter_id()</v>
        <v>filter_id() = term()</v>
      </type>
      <desc>
        <p>Unregisters a notification filter.</p>
        <marker id="which_notification_filter"></marker>
      </desc>
    </func>

    <func>
      <name>which_notification_filter() -> Filters</name>
      <name>which_notification_filter(Agent) -> Filters</name>
      <fsummary>Which notification filter.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>Filters = [filter_id()]</v>
        <v>filter_id() = term()</v>
      </type>
      <desc>
        <p>Lists all notification filters in an agent.</p>
        <marker id="set_request_limit"></marker>
      </desc>
    </func>

   <func>
      <name>set_request_limit(NewLimit) -> {ok, OldLimit} | {error, Reason}
      </name>
      <name>set_request_limit(Agent, NewLimit)
        -> {ok, OldLimit} | {error, Reason}</name>
      <fsummary>Change the request limit.</fsummary>
      <type>
        <v>NewLimit = OldLimit = infinity | integer() >= 0</v>
        <v>Agent = pid() | atom()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Changes the request limit. </p>
        <p>Notice that this has no effect on the application configuration as
          defined by configuration files, so a node restart reverts the
          configuration to whatever is in those files. </p>
        <p>This function is primarily useful in load regulation
          scenarios. </p>
        <marker id="register_subagent"></marker>
      </desc>
    </func>

    <func>
      <name>register_subagent(Agent, SubTreeOid, Subagent)
        -> ok | {error, Reason}</name>
      <fsummary>Register a subagent under a subtree.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>SubTreeOid = oid()</v>
        <v>SubAgent = pid()</v>
      </type>
      <desc>
        <p>Registers a subagent under a subtree of another agent.</p>
        <p>It is easy to make mistakes when registering subagents and
          this activity is to be done carefully. For example, a
          strange behavior would result from the following
          configuration:</p>
        <pre>
snmp_agent:register_subagent(MAPid,[1,2,3,4],SA1),
snmp_agent:register_subagent(SA1,[1,2,3], SA2).</pre>
        <p><c>SA2</c> gets no requests starting with OID
          <c>[1,2,3]</c>, as <c>SA1</c> does not.</p>
        <marker id="unregister_subagent"></marker>
      </desc>
    </func>

    <func>
      <name>unregister_subagent(Agent, SubagentOidOrPid)
        -> ok | {ok, SubAgentPid} | {error, Reason}</name>
      <fsummary>Unregister a subagent.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>SubTreeOidorPid = oid() | pid()</v>
      </type>
      <desc>
        <p>Unregisters a subagent. If the second argument is a Pid,
          that subagent is unregistered from all trees in
          <c>Agent</c>. </p>
          <marker id="send_notification2"></marker>
      </desc>
    </func>

    <func>
      <name>send_notification2(Agent, Notification, SendOpts) -> void()</name>
      <fsummary>Send notification.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>Notification = atom()</v>
        <v>SendOpts = [send_option()]</v>
        <v>send_option() = {receiver, receiver()} | {name, notify_name()}
          | {context, context_name()} | {varbinds, varbinds()}
          | {local_engine_id, string()} | {extra, extra_info()}</v>
        <v>receiver() = no_receiver | {tag(), tag_receiver()}
          | notification_delivery_info()</v>
        <v>tag() = term(()</v>
        <v>tag_receiver() = pid() | registered_name() | {Mod, Func, Args}</v>
        <v>registered_name() = atom()</v>
        <v>Mod = atom()</v>
        <v>Func = atom()</v>
        <v>Args = list()</v>
        <v>notify_name() = string()</v>
        <v>context_name() = string()</v>
        <v>varbinds() = [varbind()]</v>
        <v>varbind() = {variable(), value()}
          | {column(), row_index(), value()} | {oid(), value()}</v>
        <v>variable() = atom()</v>
        <v>value() = term()</v>
        <v>column() = atom()</v>
        <v>row_index() = [int()]</v>
        <v>extra_info() = term()</v>
      </type>
      <desc>
        <p>Sends the notification <c>Notification</c> to the management
	targets defined for notify-name (<c>name</c>) in the
	<c>snmpNotifyTable</c> in the SNMP-NOTIFICATION-MIB from the
	specified <c>context</c>. </p>
	<p>If no <c>name</c> is specified (or if it is <c>""</c>), the
	notification is sent to all management targets. </p>
	<p>If no <c>context</c> is specified, the default context, <c>""</c>,
	is used. </p>
        <p>The send option <c>receiver</c> specifies where information
	about delivery of inform-requests is to be sent. The agent
	sends inform-requests and waits for acknowledgments from the
	management targets.
	The <c>receiver</c> can have three values: </p>
	<list type="bulleted">
          <item>
            <p><c>no_receiver</c> - No information is delivered. </p>
	  </item>
          <item>
	    <p><c>notification_delivery_info()</c> - The information is
	    delivered through a function call according to this data.
            For details, see section
	    <seealso marker="#data_types">Data Types</seealso> above.</p>
	  </item>
          <item>
            <p><c>{tag(), tag_receiver()}</c> - The information is delivered
	    either through messages or through a function call according to
            the value of <c>tag_receiver()</c>.</p>
	    <p>Delivery is done differently depending on the value
	    of <c>tag_receiver()</c>: </p>
	    <list>
	      <item>
		<p><c>pid() | registered_name()</c> - The information is
                  delivered in the following messages:</p>
		<list>
		  <item>
		    <p><c>{snmp_targets, tag(), Addresses}</c></p>
		    <p>This informs the user which target addresses the
		    notification was sent to. </p>
		  </item>
		  <item>
		    <p><c>{snmp_notification, tag(),
                      {got_response, Address}}</c></p>
		    <p>This informs the user that this target address
		    acknowledged the notification. </p>
		  </item>
		  <item>
		    <p><c>{snmp_notification, tag(), {no_response,
                      Address}}</c></p>
		    <p>This informs the user that this target address
		    did not acknowledge the notification. </p>
		  </item>
		</list>
		<p>The notification is sent as an inform-request to each
		target address in <c>Addresses</c>. If there are no
		targets for which an inform-request is sent, <c>Addresses</c>
		is the empty list <c>[]</c>. </p>
		<p>The <c>tag_receiver()</c> is first sent the
		<c>snmp_targets</c> message, and then for each address in the
		<c>Addresses</c> list one of the two <c>snmp_notification</c> 
		messages. </p>
	      </item>
	      <item>
		<p><c>{Mod, Func, Args}</c> - The information is delivered
		  through the function call
		  <c>Mod:Func([Msg | Args])</c>,
		  where <c>Msg</c> has the same content and purpose as the
		  messages described above.</p>
	      </item>
	    </list>
	  </item>
        </list>
	<note>
	  <p>The <c>extra</c> information is not normally interpreted by the
          agent, instead it is passed through to the
	  <seealso marker="snmp_agent_netif"><c>net-if</c></seealso> process.
          It is
	  up to the implementor of that process to make use of this data. </p>
	  <p>The version of <c>net-if</c> provided by this application makes
          no use of this data, with one exception:
	  any tuple containing the atom
	  <c>snmpa_default_notification_extra_info</c>
	  can be used by the agent and is therefore <em>reserved</em>. </p>
	  <p>For more information, see the <c>net-if</c> incoming messages for
          sending a trap
          (<seealso marker="snmp_agent_netif#im_send_pdu">
	  <c>snmp_agent_netif:im_send_pdu</c></seealso>) and notification
	  (<seealso marker="snmp_agent_netif#im_send_pdu_req">
          <c>snmp_agent_netif:im_send_pdu_req</c></seealso>.</p>
	</note>
	<marker id="send_notification"></marker>
      </desc>
    </func>

    <func>
      <name>send_notification(Agent, Notification, Receiver)</name>
      <name>send_notification(Agent, Notification, Receiver, Varbinds)</name>
      <name>send_notification(Agent, Notification, Receiver, NotifyName,
        Varbinds)</name>
      <name>send_notification(Agent, Notification, Receiver, NotifyName,
        ContextName, Varbinds) -> void()</name>
      <name>send_notification(Agent, Notification, Receiver, NotifyName,
        ContextName, Varbinds, LocalEngineID) -> void()</name>
      <fsummary>Send a notification.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
        <v>Notification = atom()</v>
        <v>Receiver = no_receiver | {Tag, Recv}
          | notification_delivery_info()</v>
        <v>Tag = term()</v>
        <v>Recv = receiver()</v>
        <v>receiver() = pid() | atom() | {Mod, Func, Args}</v>
        <v>Mod = atom()</v>
        <v>Func = atom()</v>
        <v>Args = list()</v>
        <v>NotifyName = string()</v>
        <v>ContextName = string()</v>
        <v>Varbinds = varbinds()</v>
        <v>varbinds() = [varbind()]</v>
        <v>varbind() = {Variable, Value} | {Column, RowIndex, Value}
          | {OID, Value}</v>
        <v>Variable = atom()</v>
        <v>Column = atom()</v>
        <v>OID = oid()</v>
        <v>Value = term()</v>
        <v>RowIndex = [int()]</v>
        <v>LocalEngineID = string()</v>
      </type>
      <desc>
        <p>Sends the notification <c>Notification</c> to the
	management targets defined for <c>NotifyName</c> in the
	<c>snmpNotifyTable</c> in the SNMP-NOTIFICATION-MIB from the
	specified context.</p>
	<p>If no <c>NotifyName</c> is specified (or if it is <c>""</c>),
	the notification is sent to all management targets
	(<c>Addresses</c> below).</p>
	<p>If no <c>ContextName</c> is specified, the default <c>""</c>
	context is used. </p>
        <p>Parameter <c>Receiver</c> specifies where information
	about delivery of inform-requests is to be sent. The agent
	sends inform-requests and waits for acknowledgments from the
	managers. <c>Receiver</c> can have three values: </p>
	<list type="bulleted">
          <item>
            <p><c>no_receiver</c> - No information is delivered. </p>
	  </item>
          <item>
            <p><c>notification_delivery_info()</c> - The information is
              delivered through a function call according to this data.
              For details, see section
              <seealso marker="#data_types">Data Types</seealso> above.</p>
	  </item>
          <item>
            <p><c>{Tag, Recv}</c> - The information is delivered through
	    messages or through a function call according to the value of
	    <c>Recv</c>. </p>
	  </item>
        </list>
        <p>If <c>Receiver</c> has the value <c>{Tag, Recv}</c>, the delivery is
          done according to <c>Recv</c>: </p>
        <list>
          <item>
            <p><c>pid() | atom()</c> - The information is delivered in
              the following messages: </p>
            <list>
              <item>
                <p><c>{snmp_targets, Tag, Addresses}</c></p>
                <p>This informs the user which target addresses the
                  notification was sent to. </p>
	      </item>
              <item>
                <p><c>{snmp_notification, Tag, {got_response, Address}}</c></p>
                <p>This informs the user that this target address
                  acknowledged the notification. </p>
		  </item>
              <item>
                <p><c>{snmp_notification, Tag, {no_response, Address}}</c></p>
                <p>This informs the user that this target address
                  did not acknowledge the notification. </p>
	      </item>
	    </list>
            <p>The notification is sent as an inform-request to each
              target address in <c>Addresses</c>. If there are no
              targets for which an inform-request is sent, <c>Addresses</c>
              is the empty list <c>[]</c>. </p>
            <p>The <c>receiver</c> is first sent the <c>snmp_targets</c>
              message, and then for each address in the <c>Addresses</c> list
              one of the two <c>snmp_notification</c> messages. </p>
	  </item>
          <item>
            <p><c>{Mod, Func, Args}</c> - The information is delivered through
              the function call <c>Mod:Func([Msg | Args])</c>,
              where <c>Msg</c> has the same content and purpose as the
              messages described above.</p>
	  </item>
	</list>
        <p><c>Address</c> is a management target address and <c>Addresses</c>
	  is a list of management target addresses, which are defined as
          follows:</p>
        <list type="bulleted">
          <item><c>Addresses = [address()]</c></item>
          <item><c>Address = address()</c></item>
          <item><c>address() = v1_address() | v3_address()</c></item>
          <item><c>v1_address() = {TDomain, TAddress}</c></item>
          <item><c>v3_address() = {{TDomain, TAddress}, V3MsgData}</c></item>
          <item><c>TDomain = tdoamin()</c></item>
          <item><c>TAddress = taddress()</c></item>
          <item><c>tdomain()</c> = The OID of <c>snmpUDPDomain</c>;
            this is the only supported transport domain.</item>
          <item><c>taddress() = [A1, A2, A3, A4, P1, P3]</c>;
            the 4 first bytes make up the IP address, and the last 2
            bytes make up the UDP port number.</item>
          <item><c>V3MsgData = v3_msg_data()</c></item>
          <item><c>v3_msg_data() = term()</c></item>
        </list>
        <p>If <c>Receiver</c> is a <c>notification_delivery_info()</c> record,
          the information about the notification delivery is delivered
          to the <c>receiver</c> through the callback functions defined by the
          <seealso marker="snmpa_notification_delivery_info_receiver">
          <c>snmpa_notification_delivery_info_receiver</c></seealso>
          behavior according to the content of the
          <c>notification_delivery_info()</c> record.</p>
        <p>The optional argument <c>Varbinds</c> defines
          values for the objects in the notification. If no value is
          specified for an object, the <c>Agent</c> performs a <c>get</c>
          operation to retrieve the value.
          </p>
        <p><c>Varbinds</c> is a list of <c>Varbind</c>s, where each
          <c>Varbind</c> is one of the following:
          </p>
        <list type="bulleted">
          <item><p><c>{Variable, Value}</c>, where <c>Variable</c> is the
           symbolic name of a scalar variable referred to in the notification
           specification.</p>
          </item>
          <item><p><c>{Column, RowIndex, Value}</c>, where <c>Column</c>
           is the symbolic name of a column variable.
           <c>RowIndex</c> is a list of indexes for the specified
           element. If so, the OID sent
           in the notification is the <c>RowIndex</c> appended to the
           OID for the table column. This is the OID
           that specifies the element.</p>
          </item>
          <item><p><c>{OID, Value}</c>, where <c>OID</c> is the
           OID for an instance of an object, scalar variable,
           or column variable.</p>
          </item>
        </list>
        <p>For example, to specify that <c>sysLocation</c> is to  have the
          value <c>"upstairs"</c> in the notification, one of the following
          can be used:
          </p>
        <list type="bulleted">
          <item><c>{sysLocation, "upstairs"}</c></item>
          <item><c>{[1,3,6,1,2,1,1,6,0], "upstairs"}</c></item>
          <item><c>{?sysLocation_instance, "upstairs"}</c> (if
            the generated <c>.hrl</c> file is included)</item>
        </list>
        <p>If a variable in the notification is a table element, the
          <c>RowIndex</c> for the element must be specified in the
          <c>Varbinds</c> list. The OID sent in
          the notification is then the OID that identifies this
          element. This OID can be used in a <c>get</c> operation later.
          </p>
        <p>This function is asynchronous and does not return any
          information. If an error occurs, <c>user_err/2</c> of the error
          report module is called and the notification is discarded.
          </p>
        <note>
          <p>The use of argument <c>LocalEngineID</c> is only intended for
            special cases, if the agent is to "emulate" multiple EngineIDs.
            By default, the agent uses the value of <c>SnmpEngineID</c>
            (see SNMP-FRAMEWORK-MIB).</p>
	</note>
        <p><c>ExtraInfo</c> is not normally used in any way by the agent.
	It is intended to be passed along to the <c>net-if</c> process, which is
	a component that a user can implement. The users own <c>net-if</c>
	can then make use of <c>ExtraInfo</c>. The <c>net-if</c> provided with
        this application does not process <c>ExtraInfo</c>.</p>
	<p>There is one exception: <em>any</em> tuple containing the atom
	<c>snmpa_default_notification_extra_info</c> is, in this context,
	considered to belong to this application, and can be processed
	by the agent. </p>
	<marker id="discovery"></marker>
      </desc>
    </func>

    <func>
      <name>discovery(TargetName, Notification)
        -> {ok, ManagerEngineID} | {error, Reason}</name>
      <name>discovery(TargetName, Notification, Varbinds)
        -> {ok, ManagerEngineID} | {error, Reason}</name>
      <name>discovery(TargetName, Notification, DiscoHandler)
        -> {ok, ManagerEngineID} | {error, Reason}</name>
      <name>discovery(TargetName, Notification, ContextName, Varbinds)
        -> {ok, ManagerEngineID} | {error, Reason}</name>
      <name>discovery(TargetName, Notification, Varbinds, DiscoHandler)
        -> {ok, ManagerEngineID} | {error, Reason}</name>
      <name>discovery(TargetName, Notification, ContextName, Varbinds,
        DiscoHandler) -> {ok, ManagerEngineID} | {error, Reason}</name>
      <name>discovery(TargetName, Notification, ContextName, Varbinds,
        DiscoHandler, ExtraInfo) -> {ok, ManagerEngineID} | {error, Reason}
      </name>
      <fsummary>Initiate the discovery process with a manager.</fsummary>
      <type>
        <v>TargetName = string()</v>
        <v>Notification = atom()</v>
        <v>ContextName = string()</v>
        <d>Defaults to <c>""</c>.</d>
        <v>Varbinds = varbinds()</v>
        <v>varbinds() = [varbind()]</v>
        <v>DiscoHandler = snmpa_discovery_handler()</v>
        <v>ExtraInfo = term()</v>
        <v>snmpa_discovery_handler() =</v>
        <d>Module implementing the <c>snmpa_discovery_handler</c> behavior</d>
        <v>ManagerEngineID = string()</v>
        <v>varbind() =
          {Variable, Value} | {Column, RowIndex, Value} | {OID, Value}</v>
        <v>Variable = atom()</v>
        <v>Column = atom()</v>
        <v>OID = oid()</v>
        <v>Value = term()</v>
        <v>RowIndex = [int()]</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Initiatess the discovery process with the manager identified by
          <c>TargetName</c> using the notification <c>Notification</c>. </p>
        <p>This function is synchronous, that is, it returns when
          the discovery process has completed or failed.</p>
        <p>The <c>DiscoHandler</c> module is used during the discovery
          process. For more information, see
          <seealso marker="snmpa_discovery_handler">
          <c>snmpa_discovery handler</c></seealso>.</p>
        <p>Argument <c>ExtraInfo</c> is passed on to the callback functions
          of the <c>DiscoHandler</c>. </p>
        <note><p>If we are not at security level <c>noAuthNoPriv</c>,
          this can be complicated, as the agent then continues
          with stage 2, before which the USM-related updates must be
          done. </p></note>
        <note><p>The default discovery handler requires
          more actions by the caller and the discovery does not work
          if the security level is higher than <c>noAuthNoPriv</c>.</p></note>
        <marker id="convert_config"></marker>
      </desc>
    </func>

    <func>
      <name>convert_config(OldConfig) -> AgentConfig</name>
      <fsummary>Convert old SNMP config to new agent config.</fsummary>
      <type>
        <v>OldConfig = list()</v>
        <v>AgentConfig = list()</v>
      </type>
      <desc>
        <p>This offline utility function converts
          the old SNMP application config (pre snmp-4.0) to the
          new SNMP agent config (as from snmp-4.0).</p>
        <p>For information about the old config (<c>OldConfig</c>),
          see the Erlang/OTP R9C documentation.</p>
        <p>For information about the current agent config
          (<c>AgentConfig</c>), see either
          the <seealso marker="snmp_app">SNMP application</seealso>
          part of this Reference Manual or section
          <seealso marker="snmp_config">Configuring the Application</seealso> 
          in the User's Guide.</p>
        <marker id="restart_worker"></marker>
      </desc>
    </func>

    <func>
      <name>restart_worker() -> void()</name>
      <name>restart_worker(Agent) -> void()</name>
      <fsummary>Restart the worker process of a multi-threaded agent.</fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
      </type>
      <desc>
        <p>Restarts the worker process of a multi-threaded agent.</p>
        <p>This utility function can be useful when, for example,
          debugging instrumentation functions.</p>
        <marker id="restart_set_worker"></marker>
      </desc>
    </func>

    <func>
      <name>restart_set_worker() -> void()</name>
      <name>restart_set_worker(Agent) -> void()</name>
      <fsummary>Restart the set worker process of a multi-threaded agent.
      </fsummary>
      <type>
        <v>Agent = pid() | atom()</v>
      </type>
      <desc>
        <p>Restarts the set worker process of a multi-threaded agent.</p>
        <p>This utility function can be useful when, for example,
          debugging instrumentation functions.</p>
        <marker id="print_mib_info"></marker>
      </desc>
    </func>

    <func>
      <name>print_mib_info() -> void()</name>
      <fsummary>Print MIB information.</fsummary>
      <desc>
        <p>Prints the content of all (SNMP) tables and variables
	for all MIBs handled by the SNMP agent.</p>
        <marker id="print_mib_tables"></marker>
      </desc>
    </func>

    <func>
      <name>print_mib_tables() -> void()</name>
      <fsummary>Print MIB tables.</fsummary>
      <desc>
        <p>Prints the content of all (SNMP) tables
	for all MIBs handled by the SNMP agent.</p>
        <marker id="print_mib_variables"></marker>
      </desc>
    </func>

    <func>
      <name>print_mib_variables() -> void()</name>
      <fsummary>Print MIB variables.</fsummary>
      <desc>
        <p>Prints the content of all (SNMP) variables
	for all MIBs handled by the SNMP agent.</p>
        <marker id="verbosity"></marker>
      </desc>
    </func>

    <func>
      <name>verbosity(Ref,Verbosity) -> void()</name>
      <fsummary>Assign a new verbosity for the process.</fsummary>
      <type>
        <v>Ref = pid() | sub_agents | master_agent | net_if
          | mib_server | symbolic_store | note_store | local_db</v>
        <v>Verbosity = verbosity() | {subagents, verbosity()}</v>
        <v>verbosity() = silence | info | log | debug | trace </v>
      </type>
      <desc>
        <p>Sets verbosity for the designated process. For the lowest
          verbosity <c>silence</c>, nothing is printed. The higher the
          verbosity, the more is printed. </p>
      </desc>
    </func>
  </funcs>

  <section>
    <title>See Also</title>
    <p><seealso marker="erts:erlc"><c>erts:erlc(1)</c></seealso>,
      <seealso marker="stdlib:calendar"><c>stdlib:calendar(3)</c></seealso></p>
  </section>

</erlref>

