<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>1996</year><year>2016</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    
    </legalnotice>

    <title>dyntrace</title>
    <prepared>Patrik Nyblom</prepared>
    <responsible></responsible>
    <docno>1</docno>
    <approved>ETX/B/SFP (Kenneth Lundin)</approved>
    <checked></checked>
    <date>2012-03-20</date>
    <rev>A</rev>
    <file>dyntrace.xml</file>
  </header>
  <module>dyntrace</module>
  <modulesummary>Interface to dynamic tracing.</modulesummary>
  <description>
    <p>This module provides interfaces to dynamic tracing, if such
      is compiled into the virtual machine. For a standard and/or commercial
      build, no dynamic tracing is available, in which case none of the
      functions in this module is usable or give any effect.</p>

    <p>If dynamic tracing is enabled in the current build, either by
      configuring with <c>./configure --with-dynamic-trace=dtrace</c> or
      <c>./configure --with-dynamic-trace=systemtap</c>, the module can be
      used for two tasks:</p>

    <list type="bulleted">
      <item>
        <p>Trigger the user-probe <c>user_trace_i4s4</c> in the NIF library
          <c>dyntrace.so</c> by calling <c>dyntrace:p/1,2,3,4,5,6,7,8</c>.</p>
      </item>
      <item>
        <p>Set a user-specified tag that will be present in the trace messages
          of both the <c>efile_drv</c> and the user-probe mentioned above.</p>
      </item>
    </list>

    <p>Both building with dynamic trace probes and using them is experimental
      and unsupported by Erlang/OTP. It is included as an option for the
      developer to trace and debug performance issues in their systems.</p>

    <p>The original implementation is mostly done by Scott Lystiger Fritchie
      as an Open Source Contribution and it is to be viewed as such, although
      the source for dynamic tracing as well as this module are included in
      the main distribution. However, the ability to use dynamic tracing of
      the virtual machine is a very valuable contribution that OTP has every
      intention to maintain as a tool for the developer.</p>

    <p>How to write <c>d</c> programs or <c>systemtap</c> scripts can be
      learned from books and from a many pages on the internet. This manual
      page does not include any documentation about using the dynamic trace
      tools of respective platform. However, the <c>examples</c> directory
      of the <c>runtime_tools</c> application contains comprehensive examples
      of both <c>d</c> and <c>systemtap</c> programs, which will help you
      getting started. Another source of information is section
      <seealso marker="DTRACE">DTrace and Erlang/OTP</seealso> and section
      <seealso marker="SYSTEMTAP">SystemTap and Erlang/OTP</seealso>
      in the User's Guide.</p>
  </description>

  <funcs>
    <func>
      <name>available() -> boolean()</name>
      <fsummary>Check if dynamic tracing is available.</fsummary>
      <desc>
        <p>Checks if dynamic tracing is available by using the NIF library.
          Calling <seealso marker="erts:erlang#system_info/1">
          <c>erlang:system_info/1</c></seealso> is usually
          a better indicator of the availability of dynamic tracing.</p>
        <p>The function throws an exception if the <c>dyntrace</c> NIF library
          cannot be loaded by the <c>on_load</c> function of this module.</p>
      </desc>
    </func>

    <func>
      <name>get_tag() -> binary() | undefined</name>
      <fsummary>Get the user tag set in the process.</fsummary>
      <desc>
        <p>Returns the user tag set in the current process. If no tag is set
          or dynamic tracing is unavailable, <c>undefined</c> is returned.</p>
      </desc>
    </func>

    <func>
      <name>get_tag() -> binary() | undefined</name>
      <fsummary>Get the user tag set in the process or sent to the process.
      </fsummary>
      <desc>
        <p>Returns the user tag set in the current process or, if no user tag
          is present, the last user tag sent to the process together with a
          message (in the same way as <seealso marker="kernel:seq_trace">
          sequential trace tokens</seealso> are spread to other processes
          together with messages). For information about how user tags can be
          spread together with messages, see <seealso marker="#spread_tag/1">
          <c>spread_tag/1</c></seealso>. If no tag is found or dynamic tracing
          is unavailable, <c>undefined</c> is returned.</p>
      </desc>
    </func>

    <func>
      <name>p() -> true | false | error | badarg</name>
      <fsummary>Trigger the user trace probe.</fsummary>
      <desc>
        <p>Triggers the "user" trace probe <c>user_trace_i4s4</c> in the
          <c>dyntrace</c> NIF module, sending a trace message only containing
          the user tag and zeroes/empty strings in all other fields.</p>
      </desc>
    </func>

    <func>
      <name>p(integer() | string()) -> true | false | error | badarg</name>
      <fsummary>Trigger the user trace probe.</fsummary>
      <desc>
        <p>Trigger the "user" trace probe <c>user_trace_i4s4</c> in the
          <c>dyntrace</c> NIF module, sending a trace message containing
          the user tag and the <c>integer()</c> or <c>string()</c> parameter
          in the first integer/string field.</p>
      </desc>
    </func>

    <func>
      <name>p(integer() | string(), integer() | string()) -> true | false |
        error | badarg</name>
      <fsummary>Trigger the user trace probe.</fsummary>
      <desc>
        <p>Triggers the "user" trace probe <c>user_trace_i4s4</c> in the
          <c>dyntrace</c> NIF module, sending a trace message containing
          the user tag and the <c>integer()</c> or <c>string()</c> parameters
          as the first fields of respective type. Put <c>integer()</c>
          parameters before any <c>string()</c> parameters. For example,
          <c>p(1,"Hello")</c> is OK, as is <c>p(1,1)</c>, and
          <c>p("Hello","Again")</c>, but not <c>p("Hello",1)</c>.</p>
      </desc>
    </func>

    <func>
      <name>p(integer() | string(), integer() | string(), integer() | string())
        -> true | false | error | badarg</name>
      <fsummary>Trigger the user trace probe.</fsummary>
      <desc>
        <p>Trigger the "user" trace probe <c>user_trace_i4s4</c> in the
          <c>dyntrace</c> NIF module, sending a trace message containing
          the user tag and the <c>integer()</c> or <c>string()</c> parameters
          as the first fields of respective type. Put <c>integer()</c>
          parameters before any <c>string()</c> parameters, as in
          <seealso marker="#p/2"><c>p/2</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>p(integer() | string(), integer() | string(), integer() | string(),
        integer() | string()) -> true | false | error | badarg</name>
      <fsummary>Trigger the user trace probe.</fsummary>
      <desc>
        <p>Triggers the "user" trace probe <c>user_trace_i4s4</c> in the
          <c>dyntrace</c> NIF module, sending a trace message containing
          the user tag and the <c>integer()</c> or <c>string()</c> parameters
          as the first fields of respective type. Put <c>integer()</c>
          parameters before any <c>string()</c> parameters, as in
          <seealso marker="#p/2"><c>p/2</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>p(integer(), integer() | string(), integer() | string(), integer()
        | string(), string()) -> true | false | error | badarg</name>
      <fsummary>Trigger the user trace probe.</fsummary>
      <desc>
        <p>Triggers the "user" trace probe <c>user_trace_i4s4</c> in the
          <c>dyntrace</c> NIF module, sending a trace message containing
          the user tag and the <c>integer()</c> or <c>string()</c> parameters
          as the first fields of respective type. Put <c>integer()</c>
          parameters before any <c>string()</c> parameters, as in
          <seealso marker="#p/2"><c>p/2</c></seealso>.</p>
        <p>A maximum of four parameters of any type (<c>integer()</c> or
          <c>string()</c>) is allowed, so the first parameter must
          be an <c>integer()</c> and the last a <c>string()</c>.</p> 
      </desc>
    </func>

    <func>
      <name>p(integer(), integer(), integer() | string(), integer() | string(),
        string(), string()) -> true | false | error | badarg</name>
      <fsummary>Trigger the user trace probe.</fsummary>
      <desc>
        <p>Triggers the "user" trace probe <c>user_trace_i4s4</c> in the
          <c>dyntrace</c> NIF module, sending a trace message containing
          the user tag and the <c>integer()</c> or <c>string()</c> parameters
          as the first fields of respective type. Put <c>integer()</c>
          parameters before any <c>string()</c> parameters, as in
          <seealso marker="#p/2"><c>p/2</c></seealso>.</p>
        <p>A maxumum of four parameters of any type (<c>integer()</c> or
          <c>string()</c>) is allowed, so the first two parameters must be
          <c>integer()</c>s and the last two <c>string()</c>s.</p> 
      </desc>
    </func>

    <func>
      <name>p(integer(), integer(), integer(), integer() | string(), string(),
        string(), string()) -> true | false | error | badarg</name>
      <fsummary>Trigger the user trace probe.</fsummary>
      <desc>
        <p>Triggers the "user" trace probe <c>user_trace_i4s4</c> in the
          <c>dyntrace</c> NIF module, sending a trace message containing
          the user tag and the <c>integer()</c> or <c>string()</c> parameters
          as the first fields of respective type. Put <c>integer()</c>
          parameters before any <c>string()</c> parameters, as in
          <seealso marker="#p/2"><c>p/2</c></seealso>.</p>
        <p>A maximum of four parameters of any type (<c>integer()</c> or
          <c>string()</c>) is allowed, so the first three parameters must be
          <c>integer()</c>s and the last three <c>string()</c>s.</p> 
      </desc>
    </func>

    <func>
      <name>p(integer(), integer(), integer(), integer(), string(), string(),
        string(), string()) -> true | false | error | badarg</name>
      <fsummary>Trigger the user trace probe.</fsummary>
      <desc>
        <p>Triggers the "user" trace probe <c>user_trace_i4s4</c> in the
          <c>dyntrace</c> NIF module, sending a trace message containing
          all the <c>integer()</c>s and <c>string()</c>s provided, as well
          as any user tag set in the current process.</p> 
      </desc>
    </func>

    <func>
      <name>put_tag(Item) -> binary() | undefined </name>
      <fsummary>Set the user tag of the current process.</fsummary>
      <type>
        <v>Item = iodata()</v>
      </type>
      <desc>
        <p>Sets the user tag of the current process. The user tag is a
          <c>binary()</c>, but can be specified as any <c>iodata()</c>,
          which is converted to a binary automatically by this function.</p>
        <p>The user tag is provided to the user probes triggered by calls to
          <c>dyntrace:p/1,2,3,4,5,6,7,8</c> as well as probes in the
          <c>efile_driver</c>. In the future, user tags might be added to
          more probes.</p>
        <p>Returns the old user tag (if any). If no user tag is present or
          dynamic tracing is disabled, <c>undefined</c> is returned.</p>
      </desc>
    </func>

    <func>
      <name>restore_tag(TagData) -> true</name>
      <fsummary>Restore to a previous state of user tag spreading.</fsummary>
      <type>
        <v>TagData = opaque data returned by
          <seealso marker="#spread_tag/1"><c>spread_tag/1</c></seealso></v>
      </type>
      <desc>
        <p>Restores the previous state of user tags and their spreading as
          it was before a call to <seealso marker="#spread_tag/1">
          <c>spread_tag/1</c></seealso>. Notice that the restoring is not
          limited to the same process; this can be used to turn off spreding
          in one process and restore it in a newly created, the one that
          actually is going to send messages:</p>
        <pre>
f() ->
    TagData=dyntrace:spread_tag(false),
    spawn(fun() ->
             dyntrace:restore_tag(TagData),
             do_something()
          end),
    do_something_else(),
    dyntrace:restore_tag(TagData).</pre>
        <p>Correctly handling user tags and their spreading can take some
          effort, as Erlang programs tend to send and receive messages so
          that sometimes the user tag gets lost for various reasons, such as
          double receives or communication with a port (ports do not handle
          user tags, in the same way as they do not handle regular sequential
          trace tokens).</p>
      </desc>
    </func>

    <func>
      <name>spread_tag(boolean()) -> TagData</name>
      <fsummary>Start or stop spreading dynamic trace user tags with the next
        message.</fsummary>
      <type>
        <v>TagData = opaque data that can be used as parameter to
          <seealso marker="#restore_tag/1"><c>restore_tag/1</c></seealso></v>
      </type>
      <desc>
        <p>Controls if user tags are to be spread to other processes with
          the next message. Spreading of user tags work like spreading of
          sequential trace tokens, so that a received user tag is active in
          the process until the next message arrives (if that message does
          not also contain the user tag.</p>
        <p>This functionality is used when a client process communicates with
          a file I/O-server to spread the user tag to the I/O-server and then
          down to the <c>efile_drv</c> driver. By using <c>spread_tag/1</c>
          and <seealso marker="#restore/1"><c>restore_tag/1</c></seealso>, one
          can enable or disable spreading of user tags to other processes and
          then restore the previous state of the user tag. The <c>TagData</c>
          returned from this call contains all previous information, so the
          state (including any previously spread user tags) is completely
          restored by a later call to <c>restore_tag/1</c>.</p> 
        <p>The <seealso marker="kernel:file">kernel:file</seealso> module
          already spreads tags, so there is no need to manually call this
          function to get user tags spread to the <c>efile_drv</c> driver
          through that module.</p>
        <p>The most use of this function is if one, for example, uses the
          <seealso marker="stdlib:io"><c>stdlib:io</c></seealso> module to
          communicate with an I/O-server for a regular file, as in the
          following example:</p>
        <pre>
f() ->
   {ok, F} = file:open("test.tst",[write]),
   Saved = dyntrace:spread_tag(true),
   io:format(F,"Hello world!",[]),
   dyntrace:restore_tag(Saved),
   file:close(F).</pre>
        <p>In this example, any user tag set in the calling process are
          spread to the I/O-server when the <c>io:format</c> call is done.</p>
      </desc>
    </func>
  </funcs>
</erlref>

