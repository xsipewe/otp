<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>1996</year><year>2016</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    
    </legalnotice>

    <title>dbg</title>
    <prepared>Patrik Nyblom (Claes Wikstrom)</prepared>
    <responsible></responsible>
    <docno>1</docno>
    <approved>ETX/B/SFP (Kenneth Lundin)</approved>
    <checked></checked>
    <date>1996-11-07</date>
    <rev>A</rev>
    <file>dbg.xml</file>
  </header>
  <module>dbg</module>
  <modulesummary>Text-based trace facility.</modulesummary>

  <description>
    <p>This module implements a text-based interface to the
      <seealso marker="erts:erlang#trace-3"><c>erlang:trace/3</c></seealso> and
      <seealso marker="erts:erlang#trace_pattern-2">
      <c>erlang:trace_pattern/2</c></seealso> BIFs. It makes it
      possible to trace functions, processes, ports, and messages.</p>

    <p>To get started quickly on tracing function calls, you can use the
      following code in the Erlang shell:</p>

    <pre>
1> dbg:tracer(). %% Start the default trace message receiver
{ok,&lt;0.36.0>}
2> dbg:p(all, c). %% Set up call (c) tracing on all processes
{ok,[{matched,nonode@nohost,26}]}
3> dbg:tp(lists, seq, x). %% Set up an exception return trace (x) on lists:seq
{ok,[{matched,nonode@nohost,2},{saved,x}]}
4> lists:seq(1,10).
(&lt;0.34.0>) call lists:seq(1,10)
(&lt;0.34.0>) returned from lists:seq/2 -> [1,2,3,4,5,6,7,8,9,10]
[1,2,3,4,5,6,7,8,9,10]</pre>

    <p>For more examples on how to use <c>dbg</c> from the Erlang shell, see
      section <seealso marker="#simple_example">Simple Examples - Tracing from
      the Shell</seealso>.</p>

    <p>The utilities are also suitable to use in system testing on
      large systems, where other tools have too much impact on the
      system performance. Some primitive support for sequential tracing is also
      included, see section <seealso marker="#advanced">Advanced Topics -
      Combining with seq_trace</seealso>.</p>
  </description>

  <funcs>
    <func>
      <name>c(Mod, Fun, Args)</name>
      <fsummary>Evaluate <c>apply(M,F,Args)</c> with <c>all</c> trace flags set.
      </fsummary>
      <desc>
        <p>Same as
          <seealso marker="#c/4"><c>c(Mod, Fun, Args, all)</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>c(Mod, Fun, Args, Flags)</name>
      <fsummary>Evaluate <c>apply(M,F,Args)</c> with <c>Flags</c> trace flags
        set.</fsummary>
      <desc>
        <p>Evaluates the expression <c>apply(Mod, Fun, Args)</c> with the trace
          flags in <c>Flags</c> set. This is a convenient way to trace processes
          from the Erlang shell.</p>
      </desc>
    </func>

    <func>
      <name>cn(Nodename) -> ok</name>
      <fsummary>Clear a node from the list of traced nodes.</fsummary>
      <type>
        <v>Nodename = atom()</v>
      </type>
      <desc>
        <p>Clears a node from the list of traced nodes. The following
          calls to <seealso marker="#tp-2"><c>tp/2</c></seealso> and
          <seealso marker="#p-2"><c>p/2</c></seealso> will not consider that
          node, but tracing already activated on the node will continue
          to be in effect.</p>
        <p>Returns <c>ok</c>, cannot fail.</p>
      </desc>
    </func>

    <func>
      <name>ctp()</name>
      <fsummary>Clear call trace pattern for the specified functions.</fsummary>
      <desc>
        <p>Same as <c>ctp({'_', '_', '_'})</c>.</p>
      </desc>
    </func>

    <func>
      <name>ctp(Module)</name>
      <fsummary>Clear call trace pattern for the specified functions.</fsummary>
      <desc>
        <p>Same as <c>ctp({Module, '_', '_'})</c>.</p>
      </desc>
    </func>

    <func>
      <name>ctp(Module, Function)</name>
      <fsummary>Clear call trace pattern for the specified functions.</fsummary>
      <desc>
        <p>Same as <c>ctp({Module, Function, '_'})</c>.</p>
      </desc>
    </func>

    <func>
      <name>ctp(Module, Function, Arity)</name>
      <fsummary>Clear call trace pattern for the specified functions.</fsummary>
      <desc>
        <p>Same as <c>ctp({Module, Function, Arity})</c>.</p>
      </desc>
    </func>

    <func>
      <name>ctp({Module, Function, Arity}) -> {ok, MatchDesc} | {error,
        term()}</name>
      <fsummary>Clear call trace pattern for the specified functions.</fsummary>
      <type>
        <v>Module = atom() | '_'</v>
        <v>Function = atom() | '_'</v>
        <v>Arity = integer() | '_'</v>
        <v>MatchDesc = [MatchNum]</v>
        <v>MatchNum = {matched, node(), integer()} | {matched, node(), 0,
          RPCError}</v>
      </type>
      <desc>
        <p>Disables call tracing on the specified
          functions. The semantics of the parameter is the same
          as for the corresponding function specification in
          <seealso marker="#tp-2"><c>tp/2</c></seealso> or
          <seealso marker="#tpl-2"><c>tpl/2</c></seealso>.
          Both local and global call trace are disabled.</p>
        <p>The return value reflects how many functions that matched,
          and is constructed as described in
          <seealso marker="#tp-2"><c>tp/2</c></seealso>. A tuple
          <c>{saved, N}</c> is, however, not returned (for obvious reasons).</p>
      </desc>
    </func>

    <func>
      <name>ctpe(Event) -> {ok, MatchDesc} | {error, term()}</name>
      <fsummary>Clear trace pattern for the specified event.</fsummary>
      <type>
        <v>Event = send | 'receive'</v>
        <v>MatchDesc = [MatchNum]</v>
        <v>MatchNum = {matched, node(), 1} | {matched, node(), 0, RPCError}</v>
      </type>
      <desc>
        <p>Clears match specifications for the specified
          trace event (<c>send</c> or <c>'receive'</c>). Reverts
          to the default behavior of tracing all triggered events.</p>
        <p>The return value follows the same style as for
          <seealso marker="#ctp-1"><c>ctp/1</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>ctpg()</name>
      <fsummary>Clear call trace pattern for the specified functions.</fsummary>
      <desc>
        <p>Same as <c>ctpg({'_', '_', '_'})</c>.</p>
      </desc>
    </func>

    <func>
      <name>ctpg(Module)</name>
      <fsummary>Clear call trace pattern for the specified functions.</fsummary>
      <desc>
        <p>Same as <c>ctpg({Module, '_', '_'})</c>.</p>
      </desc>
    </func>

    <func>
      <name>ctpg(Module, Function)</name>
      <fsummary>Clear call trace pattern for the specified functions.</fsummary>
      <desc>
        <p>Same as <c>ctpg({Module, Function, '_'})</c>.</p>
      </desc>
    </func>

    <func>
      <name>ctpg(Module, Function, Arity)</name>
      <fsummary>Clear call trace pattern for the specified functions.</fsummary>
      <desc>
        <p>Same as <c>ctpg({Module, Function, Arity})</c>.</p>
      </desc>
    </func>

    <func>
      <name>ctpg({Module, Function, Arity}) -> {ok, MatchDesc} | {error, term()}
      </name>
      <fsummary>Clear call trace pattern for the specified functions.</fsummary>
      <desc>
        <p>Works as <seealso marker="#ctp-1"><c>ctp/1</c></seealso>, but only
          disables tracing set up with <seealso marker="#tp-2">
          <c>tp/2</c></seealso> (not with <seealso marker="#tpl-2">
          <c>tpl/2</c></seealso>).</p>
      </desc>
    </func>

    <func>
      <name>ctpl()</name>
      <fsummary>Clear call trace pattern for the specified functions.</fsummary>
      <desc>
        <p>Same as <c>ctpl({'_', '_', '_'})</c>.</p>
      </desc>
    </func>

    <func>
      <name>ctpl(Module)</name>
      <fsummary>Clear call trace pattern for the specified functions.</fsummary>
      <desc>
        <p>Same as <c>ctpl({Module, '_', '_'})</c>.</p>
      </desc>
    </func>

    <func>
      <name>ctpl(Module, Function)</name>
      <fsummary>Clear call trace pattern for the specified functions.</fsummary>
      <desc>
        <p>Same as <c>ctpl({Module, Function, '_'})</c>.</p>
      </desc>
    </func>

    <func>
      <name>ctpl(Module, Function, Arity)</name>
      <fsummary>Clear call trace pattern for the specified functions.</fsummary>
      <desc>
        <p>Same as <c>ctpl({Module, Function, Arity})</c>.</p>
      </desc>
    </func>

    <func>
      <name>ctpl({Module, Function, Arity}) -> {ok, MatchDesc} | {error, term()}
      </name>
      <fsummary>Clear call trace pattern for the specified functions.</fsummary>
      <desc>
        <p>Works as <seealso marker="#ctp-1"><c>ctp/1</c></seealso>, but only
          disables tracing set up with <seealso marker="#tpl-2">
          <c>tpl/2</c></seealso> (not with <seealso marker="#tp-2">
          <c>tp/2</c></seealso>).</p>
      </desc>
    </func>

    <func>
      <name>dtp() -> ok</name>
      <fsummary>Delete all saved match specifications.</fsummary>
      <desc>
        <p>Use this function to "forget" all match specifications
          saved during calls to <seealso marker="#tp-2"><c>tp/2</c></seealso>.
          This is useful when one wants to restore other match specifications
          from a file with <seealso marker="#rtp-1"><c>rtp/1</c></seealso>.</p>
        <p>To delete specific saved match specifications, use
          <seealso marker="#dtp-1"><c>dtp/1</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>dtp(N) -> ok</name>
      <fsummary>Delete a specific saved match specification.</fsummary>
      <type>
        <v>N = integer()</v>
      </type>
      <desc>
        <p>Use this function to "forget" a specific match specification saved
          during calls to <seealso marker="#tp-2"><c>tp/2</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>flush_trace_port()</name>
      <fsummary>Same as flush_trace_port(node()).</fsummary>
      <desc>
        <p>Same as <seealso marker="#flush_trace_port/1">
          <c>flush_trace_port(node())</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>flush_trace_port(Nodename) -> ok | {error, Reason}</name>
      <fsummary>Flush internal data buffers in a trace driver on the specified
        node.</fsummary>
      <desc>
        <p>Same as <seealso marker="#trace_port_control/2">
          <c>trace_port_control(Nodename,flush)</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>fun2ms(LiteralFun) -> MatchSpec</name>
      <fsummary>Pseudo function that transforms fun syntax to match_spec.
      </fsummary>
      <type>
        <v>LiteralFun = fun() literal</v>
        <v>MatchSpec = term()</v>
      </type>
      <desc>
        <p>Pseudo function that, by means of a <c>parse_transform</c>,
          translates the <em>literal</em> <c>fun()</c> typed as parameter in
          the function call to a match specification, as described in section
          <seealso marker="erts:match_spec">Match Specifications in
          Erlang</seealso> in the <c>ERTS</c> User's Guide.
          (With literal is meant that the <c>fun()</c> must
          textually be written as the parameter of the function; it
          cannot be held in a variable that in turn is passed to the 
          function.)</p>
        <p>The parse transform is provided in the <c>ms_transform</c>
          module and the source <em>must</em> include the
          <c>ms_transform.hrl</c> file in <c>STDLIB</c> for this
          pseudo function to work. Failing to include the hrl file in
          the source results in a runtime error, not a compile
          time error. The include file is easiest included by adding
          the line
          <c>-include_lib("stdlib/include/ms_transform.hrl").</c> to
          the source file.</p>
        <p>The <c>fun()</c> is very restricted. It can take only a single
          parameter (the parameter list to match), a single variable, or a
          list. It must use the <c>is_</c>XXX guard tests and one
          cannot use language constructs that have no representation
          in a match specification (such as <c>if</c>, <c>case</c>, or
          <c>receive</c>). The return value from the fun is
          the return value of the resulting match specification.</p>
        <p>Example:</p>
        <pre>
1> <input>dbg:fun2ms(fun([M,N]) when N > 3 -> return_trace() end).</input>
[{['$1','$2'],[{'>','$2',3}],[{return_trace}]}]</pre>
        <p>Variables from the environment can be imported, so that this
          works:</p>
        <pre>
2> <input>X=3.</input>
3
3> <input>dbg:fun2ms(fun([M,N]) when N > X  -> return_trace() end).</input>
[{['$1','$2'],[{'>','$2',{const,3}}],[{return_trace}]}]</pre>
        <p>The imported variables will be replaced by match specification
          <c>const</c> expressions, which is consistent with the
          static scoping for Erlang <c>fun()</c>s. However, local or global
          function calls cannot be in the guard or body of the fun.
          Calls to built-in match specification functions is of course
          allowed:</p>
        <pre>
4> <input>dbg:fun2ms(fun([M,N]) when N > X, is_atomm(M) -> return_trace() end).</input>
Error: fun containing local erlang function calls ('is_atomm' called in guard)\
cannot be translated into match_spec
{error,transform_error}
5> <input>dbg:fun2ms(fun([M,N]) when N > X, is_atom(M) -> return_trace() end).</input>
[{['$1','$2'],[{'>','$2',{const,3}},{is_atom,'$1'}],[{return_trace}]}]</pre>
        <p>As shown in the example, the function can be called from
          the shell too. The <c>fun()</c> must be literally in the
          call when used from the shell as well. Other means than the
          <c>parse_transform</c> are used in the shell case, but more or less
          the same restrictions apply (the exception is records,
          as they are not handled by the shell).</p>
        <warning>
          <p>If the <c>parse_transform</c> is not applied to a module that
            calls this pseudo function, the call fails in runtime (with a
            <c>badarg</c>). The <c>dbg</c> module actually exports a
            function with this name, but it is never really to be called
            except when using the function in the shell. If the
            <c>parse_transform</c> is properly applied by including
            the <c>ms_transform.hrl</c> header file, the compiled code
            never calls the function, but the function call is
            replaced by a literal match specification.</p>
        </warning>
        <p>For more information, see <seealso marker="stdlib:ms_transform">
          <c>stdlib:ms_transform</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>get_tracer()</name>
      <fsummary>Same as get_tracer(node()).</fsummary>
      <desc>
        <p>Same as <seealso marker="#get_tracer/1">
          <c>get_tracer(node())</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>get_tracer(Nodename) -> {ok, Tracer}</name>
      <fsummary>Return the process or port to which all trace messages are sent.
      </fsummary>
      <type>
        <v>Nodename = atom()</v>
        <v>Tracer = port() | pid() | {module(), term()}</v>
      </type>
      <desc>
        <p>Returns the process, port, or tracer module to which all trace
          messages are sent.</p>
      </desc>
    </func>

    <func>
      <name>h() -> ok</name>
      <fsummary>Get a list of available help items on standard output.
      </fsummary>
      <desc>
        <p>Returns a list of items for brief online help.</p>
      </desc>
    </func>

    <func>
      <name>h(Item) -> ok </name>
      <fsummary>Brief help for an item.</fsummary>
      <type>
        <v>Item = atom()</v>
      </type>
      <desc>
        <p>Returns a brief help text for functions in the <c>dbg</c> module.
          The available items can be listed with
          <seealso marker="#h/0"><c>h/0</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>i() -> ok</name>
      <fsummary>Get information about all traced processes and ports.</fsummary>
      <desc>
        <p>Returns information about all traced processes and ports.</p>
      </desc>
    </func>

    <func>
      <name>ln() -> ok</name>
      <fsummary>Show the list of traced nodes on the console.</fsummary>
      <desc>
        <p>Returns the list of traced nodes on the console.</p>
      </desc>
    </func>

    <func>
      <name>ltp() -> ok</name>
      <fsummary>List saved and built-in match specifications on the console.
      </fsummary>
      <desc>
        <p>Use this function to recall all match specifications previously
          used in the session (that is, previously saved during calls
          to <seealso marker="#tp-2"><c>tp/2</c></seealso>, and built-in
          match specifications. This is very useful, as a complicated match
          specification can be quite awkward to write. Notice that the
          match specifications are lost if
          <seealso marker="#stop-0"><c>stop/0</c></seealso> is called.</p>
        <p>Match specifications used can be saved in a file (if a
          read-write file system is present) for use in later debugging
          sessions, see <seealso marker="#wtp-1"><c>wtp/1</c></seealso>
          and <seealso marker="#rtp-1"><c>rtp/1</c></seealso>.</p>
        <p>Three built-in trace patterns exist:
          <c>exception_trace</c>, <c>caller_trace</c>,
          and <c>caller_exception_trace</c> (or <c>x</c>, <c>c</c>, and
          <c>cx</c>, respectively).
          Exception trace sets a trace which will show function names,
          parameters, return values, and exceptions thrown from functions.
          Caller traces display function names, parameters, and information
          about which function called it. An example using a built-in alias:</p>
        <pre>
(x@y)4> <input>dbg:tp(lists,sort,cx).</input>
{ok,[{matched,nonode@nohost,2},{saved,cx}]}
(x@y)4> <input>lists:sort([2,1]).</input>
(&lt;0.32.0&gt;) call lists:sort([2,1]) ({erl_eval,do_apply,5})
(&lt;0.32.0&gt;) returned from lists:sort/1 -> [1,2]
[1,2]</pre>
      </desc>
    </func>

    <func>
      <name>n(Nodename) -> {ok, Nodename} | {error, Reason}</name>
      <fsummary>Add a remote node to the list of traced nodes.</fsummary>
      <type>
        <v>Nodename = atom()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>The <c>dbg</c> server keeps a list of nodes where tracing is to be
          performed. Whenever a <seealso marker="#tp-2"><c>tp/2</c></seealso>
          call or a <seealso marker="#p-2"><c>p/2</c></seealso> call is made,
          it is executed for all nodes in this list, including the local node
          (except for <seealso marker="#p-2"><c>p/2</c></seealso> with a
          specific <c>pid()</c> or <c>port()</c> as first argument; the
          command then executes only on the node where the designated
          process or port resides).</p>
        <p>This function adds a remote node (<c>Nodename</c>) to the
          list of nodes where tracing is performed. It starts a tracer
          process on the remote node, which will send all trace messages
          to the tracer process on the local node (through the Erlang
          distribution). If no tracer process is running on the local
          node, error reason <c>no_local_tracer</c> is returned. The
          tracer process on the local node must be started with
          <seealso marker="#tracer-2"><c>tracer/0,2</c></seealso>.</p>
        <p>If <c>Nodename</c> is the local node, the error reason
          <c>cant_add_local_node</c> is returned.</p>
        <p>If a trace port (see
          <seealso marker="#trace_port-2"><c>trace_port/2</c></seealso>) is
          running on the local node, remote nodes cannot be traced with
          a tracer process; error reason
          <c>cant_trace_remote_pid_to_local_port</c> is returned. A
          trace port can, however, be started on the remote node with
          <seealso marker="#tracer-3"><c>tracer/3</c></seealso>.</p>
        <p>The function also returns an error if the node
          <c>Nodename</c> is unreachable.</p>
      </desc>
    </func>

    <func>
      <name>p(Item) -> {ok, MatchDesc} | {error, term()}</name>
      <fsummary>Trace messages to and from an item.</fsummary>
      <desc>
        <p>Same as <seealso marker="#p/2"><c>p(Item, [m])</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>p(Item, Flags) -> {ok, MatchDesc} | {error, term()}</name>
      <fsummary>Trace Item according to Flags.</fsummary>
      <type>
        <v>MatchDesc = [MatchNum]</v>
        <v>MatchNum = {matched, node(), integer()} | {matched, node(), 0,
          RPCError}</v>
        <v>RPCError = term()</v>
      </type>
      <desc>
        <p>Traces <c>Item</c> according to the value specified
          by <c>Flags</c>. The variation of <c>Item</c> is as follows:</p>
        <taglist>
          <tag><c>pid()</c> or <c>port()</c></tag>
          <item>
            <p>The corresponding process or port is traced. The process or port
              can be a remote process or port (on another Erlang node). The
              node must be in the list of traced nodes (see
              <seealso marker="#n-1"><c>n/1</c></seealso> and
              <seealso marker="#tracer-3"><c>tracer/3</c></seealso>).</p>
          </item>
          <tag><c>all</c></tag>
          <item>
            <p>All processes and ports in the system as well as all processes
              and ports created hereafter are traced.</p>
          </item>
          <tag><c>processes</c></tag>
          <item>
            <p>All processes in the system as well as all processes created
              hereafter are traced.</p>
          </item>
          <tag><c>ports</c></tag>
          <item>
            <p>All ports in the system as well as all ports created hereafter
              are traced.</p>
          </item>
          <tag><c>new</c></tag>
          <item>
            <p>All processes and ports created after the call are traced.</p>
          </item>
          <tag><c>new_processes</c></tag>
          <item>
            <p>All processes created after the call are traced.</p>
          </item>
          <tag><c>new_ports</c></tag>
          <item>
            <p>All ports created after the call are traced.</p>
          </item>
          <tag><c>existing</c></tag>
          <item>
            <p>All existing processes and ports are traced.</p>
          </item>
          <tag><c>existing_processes</c></tag>
          <item>
            <p>All existing processes are traced.</p>
          </item>
          <tag><c>existing_ports</c></tag>
          <item>
            <p>All existing ports are traced.</p>
          </item>
          <tag><c>atom()</c></tag>
          <item>
            <p>The process or port with the corresponding registered name is
              traced. The process or port can be a remote process (on another
              Erlang node). The node must be added with
              <seealso marker="#n-1"><c>n/1</c></seealso> or
              <seealso marker="#tracer-3"><c>tracer/3</c></seealso></p>.
          </item>
          <tag><c>integer()</c></tag>
          <item>
            <p>The process <c><![CDATA[<0.Item.0>]]></c> is traced.</p>
          </item>
          <tag><c>{X, Y, Z}</c></tag>
          <item>
            <p>The process <c><![CDATA[<X.Y.Z>]]></c> is traced.</p>
          </item>
          <tag><c>string()</c></tag>
          <item>
            <p>If <c>Item</c> is a string <![CDATA["<X.Y.Z>"]]> as returned
              from <seealso marker="erts:erlang#pid_to_list-1">
              <c>erlang:pid_to_list/1</c></seealso>,
              the process <c><![CDATA[<X.Y.Z>]]></c> is traced.</p>
          </item>
        </taglist>
        <p>When enabling an <c>Item</c> that represents a group of processes,
          the <c>Item</c> is enabled on all nodes added with
          <seealso marker="#n-1"><c>n/1</c></seealso> or
          <seealso marker="#tracer-3"><c>tracer/3</c></seealso>.</p>
        <p><c>Flags</c> can be a single atom or a list of flags.
          The available flags are as follows:</p>
        <taglist>
          <tag><c>s (send)</c></tag>
          <item>
            <p>Traces the messages the process or port sends.</p>
          </item>
          <tag><c>r (receive)</c></tag>
          <item>
            <p>Traces the messages the process or port receives.</p>
          </item>
          <tag><c>m (messages)</c></tag>
          <item>
            <p>Traces the messages the process or port receives and sends.</p>
          </item>
          <tag><c>c (call)</c></tag>
          <item>
            <p>Traces global function calls for the process
              according to the trace patterns set in the system
              (see <seealso marker="#tp/2"><c>tp/2</c></seealso>).</p>
          </item>
          <tag><c>p (procs)</c></tag>
          <item>
            <p>Traces process-related events to the process.</p>
          </item>
          <tag><c>ports</c></tag>
          <item>
            <p>Traces port-related events to the port.</p>
          </item>
          <tag><c>sos (set on spawn)</c></tag>
          <item>
            <p>Lets all processes created by the traced
              process inherit the trace flags of the traced process.</p>
          </item>
          <tag><c>sol (set on link)</c></tag>
          <item>
            <p>Lets another process, <c>P2</c>, inherit the
              trace flags of the traced
              process whenever the traced process links to <c>P2</c>.</p>
          </item>
          <tag><c>sofs (set on first spawn)</c></tag>
          <item>
            <p>Same as <c>sos</c>, but only
              for the first process spawned by the traced process.</p>
          </item>
          <tag><c>sofl (set on first link)</c></tag>
          <item>
            <p>Same as <c>sol</c>, but only for the first call to
              <seealso marker="erts:erlang#link-1">
              <c>erlang:link/1</c></seealso> by the traced process.</p>
          </item>
          <tag><c>all</c></tag>
          <item>
            <p>Sets all flags except <c>silent</c>.</p>
          </item>
          <tag><c>clear</c></tag>
          <item>
            <p>Clears all flags.</p>
          </item>
        </taglist>
        <p>The list can also include any of the flags allowed in 
          <seealso marker="erts:erlang#trace-3">
          <c>erlang:trace/3</c></seealso>.</p>
        <p>The function returns either an error tuple or a tuple
          <c>{ok, List}</c>. The <c>List</c> consists of
          specifications of how many processes and ports that matched (in the
          case of a pure pid() exactly 1). The specification of
          matched processes is <c>{matched, Node, N}</c>. If the
          remote processor call, <c>rpc</c>, to a remote node fails,
          the <c>rpc</c> error message is delivered as a fourth
          argument and the number of matched processes is 0. Notice
          that the result <c>{ok, List}</c> can contain a list where
          <c>rpc</c> calls to one, many, or even all nodes failed.</p>
      </desc>
    </func>

    <func>
      <name>rtp(Name) -> ok | {error, Error}</name>
      <fsummary>Read saved match specifications from file.</fsummary>
      <type>
        <v>Name = string()</v>
        <v>Error = term()</v>
      </type>
      <desc>
        <p>Reads match specifications from a file
          (possibly) generated by <seealso marker="#wtp-1">
          <c>wtp/1</c></seealso>. Checks
          the syntax of all match specifications and verifies that
          they are correct. The error handling principle is "all or
          nothing", that is, if some of the match specifications are
          wrong, none of the specifications are added to the list of
          saved match specifications for the running system.</p>
        <p>The match specifications in the file are <em>merged</em>
          with the current match specifications, so that no duplicates
          are generated. To see what numbers were
          assigned to the specifications from the file, use
          <seealso marker="#ltp-0"><c>ltp/0</c></seealso>.</p>
        <p>The function returns an error, either because of I/O
          problems (like a non-existing or non-readable file) or because
          of file format problems. The errors from a bad format file
          are in a more or less textual format, which gives a hint
          to what is causing the problem.</p>
      </desc>
    </func>

    <func>
      <name>stop() -> ok</name>
      <fsummary>Stop the <c>dbg</c>server and the tracing of all processes.
      </fsummary>
      <desc>
        <p>Stops the <c>dbg</c> server and clears all trace flags for
          all processes and all local trace patterns for all functions. Also
          shuts down all trace clients and closes all trace ports.</p>
        <p>Notice that no global trace patterns are affected by this
          function.</p>
      </desc>
    </func>

    <func>
      <name>stop_clear() -> ok</name>
      <fsummary>Stop the <c>dbg</c>server and the tracing of all processes,
        and clear trace patterns.</fsummary>
      <desc>
        <p>Same as <seealso marker="#stop/0"><c>stop/0</c></seealso>,
          but also clears all trace patterns on global functions calls.</p>
      </desc>
    </func>

    <func>
      <name>stop_trace_client(Pid) -> ok</name>
      <fsummary>Stop a trace client gracefully.</fsummary>
      <type>
        <v>Pid = pid()</v>
      </type>
      <desc>
        <p>Shuts down a previously started trace
          client. The <c>Pid</c> argument is the process ID returned from the
          <seealso marker="#trace_client-2"><c>trace_client/2</c></seealso> or
          <seealso marker="#trace_client-3"><c>trace_client/3</c></seealso>
          call.</p>
      </desc>
    </func>

    <func>
      <name>tp(Module,MatchSpec)</name>
      <fsummary>Set pattern for traced global function calls.</fsummary>
      <desc>
        <p>Same as <c>tp({Module, '_', '_'}, MatchSpec)</c>.</p>
      </desc>
    </func>

    <func>
      <name>tp(Module,Function,MatchSpec)</name>
      <fsummary>Set pattern for traced global function calls.</fsummary>
      <desc>
        <p>Same as <c>tp({Module, Function, '_'}, MatchSpec)</c>.</p>
      </desc>
    </func>

    <func>
      <name>tp(Module, Function, Arity, MatchSpec)</name>
      <fsummary>Set pattern for traced global function calls.</fsummary>
      <desc>
        <p>Same as <c>tp({Module, Function, Arity}, MatchSpec)</c>.</p>
      </desc>
    </func>

    <func>
      <name>tp({Module, Function, Arity}, MatchSpec) -> {ok, MatchDesc} |
        {error, term()}</name>
      <fsummary>Set pattern for traced global function calls.</fsummary>
      <type>
        <v>Module = atom() | '_'</v>
        <v>Function = atom() | '_'</v>
        <v>Arity = integer() |'_'</v>
        <v>MatchSpec = integer() | Built-inAlias | [] | match_spec()</v>
	<v>Built-inAlias = x | c | cx</v>
        <v>MatchDesc = [MatchInfo]</v>
        <v>MatchInfo = {saved, integer()} | MatchNum</v>
        <v>MatchNum = {matched, node(), integer()} | {matched, node(), 0,
          RPCError}</v>
      </type>
      <desc>
        <p>Enables call trace for one or more functions. All
          exported functions matching argument <c>{Module, Function, Arity}</c>
          are concerned, but the
          <c>match_spec()</c> can further narrow down the set of function
          calls generating trace messages.</p>
        <p>For a description of the <c>match_spec()</c> syntax, see
          section <seealso marker="erts:match_spec">Match Specifications in
          Erlang</seealso> in the <c>ERTS</c> User's Guide.
          The most common generic match specifications used can be
          found as <c>Built-inAlias</c>; for details, see
          <seealso marker="#ltp-0"><c>ltp/0</c></seealso>.</p>
        <p>The <c>Module</c>, <c>Function</c>, and/or <c>Arity</c> parts of the
          tuple can be specified as the atom <c>'_'</c>, which is a "wildcard"
          matching all modules/functions/arities. Notice that if the
          <c>Module</c> is specified as <c>'_'</c>, the <c>Function</c> and
          <c>Arity</c> parts must also be specified as <c>'_'</c>. The same
          holds for the <c>Function</c> relation to the <c>Arity</c>.</p>
        <p>All nodes added with <seealso marker="#n-1"><c>n/1</c></seealso> or
          <seealso marker="#tracer-3"><c>tracer/3</c></seealso>
          are affected by this call. If <c>Module</c> is not <c>'_'</c>,
          the module ia loaded on all nodes.</p>
        <p>The function returns either an error tuple or a tuple
          <c>{ok, List}</c>. The <c>List</c> consists of specifications of how
          many functions that matched, in the same way as the processes and
          ports are presented in the return value of
          <seealso marker="#p-2"><c>p/2</c></seealso>.</p>
        <p>The return value can include a tuple <c>{saved, N}</c>
          if the <c>MatchSpec</c> is other
          than <c>[]</c>. The integer <c>N</c> can then be used in the
          following calls to this function and will stand as an
          "alias" for the specified expression. There are also some
          built-in aliases for common expressions; for details, see
          <seealso marker="#ltp-0"><c>ltp/0</c></seealso>.</p>
        <p>If an error is returned, the reason can be errors in
          compilation of the match specification. Such errors are
          presented as a list of tuples <c>{error, string()}</c>, where
          the string is a textual explanation of the compilation
          error, for example:</p>
        <pre>
(x@y)4> <input>dbg:tp({dbg,ltp,0},[{[],[],[{message, two, arguments}, {noexist}]}]).</input>
{error,
 [{error,"Special form 'message' called with wrong number of
          arguments in {message,two,arguments}."},
  {error,"Function noexist/1 does_not_exist."}]}</pre>
      </desc>
    </func>

    <func>
      <name>tpe(Event, MatchSpec) -> {ok, MatchDesc} | {error, term()}</name>
      <fsummary>Set pattern for traced event.</fsummary>
      <type>
        <v>Event = send | 'receive'</v>
        <v>MatchSpec = integer() | Built-inAlias | [] | match_spec()</v>
        <v>Built-inAlias = x | c | cx</v>
        <v>MatchDesc = [MatchInfo]</v>
        <v>MatchInfo = {saved, integer()} | MatchNum</v>
        <v>MatchNum = {matched, node(), 1} | {matched, node(), 0, RPCError}</v>
      </type>
      <desc>
        <p>Associates a match specification with trace event
          <c>send</c> or <c>'receive'</c>. By default all executed <c>send</c>
          and <c>'receive'</c> events are traced if enabled for a process.
          A match specification can be used to filter traced events
          based on sender, receiver, and/or message content.</p>
        <p>For a description of the <c>match_spec()</c> syntax, see
          section <seealso marker="erts:match_spec">Match Specifications in
          Erlang</seealso> in the <c>ERTS</c> User's Guide.</p>
        <list type="bulleted">
          <item>
            <p>For <c>send</c>, the matching is done on the list
              <c>[Receiver, Msg]</c>. <c>Receiver</c> is the process
              or port identity of the receiver and <c>Msg</c> is the
              message term. The pid of the sending process can be
              accessed with the guard function <c>self/0</c>.</p>
          </item>
          <item>
            <p>For <c>'receive'</c>, the matching is done on the list
              <c>[Node, Sender, Msg]</c>.
              <c>Node</c> is the node name of the sender. <c>Sender</c> is the
              process or port identity of the sender, or the atom
              <c>undefined</c> if the sender is unknown (which can
              be the case for remote senders). <c>Msg</c> is the
              message term. The pid of the receiving process can be
              accessed with the guard function <c>self/0</c>.</p>
          </item>
        </list>
        <p>All nodes added with <seealso marker="#n-1"><c>n/1</c></seealso> or
          <seealso marker="#tracer-3"><c>tracer/3</c></seealso>
          are affected by this call.</p>
        <p>The return value is the same as for
          <seealso marker="#tp-2"><c>tp/2</c></seealso>. The number of matched
          events is never higher than 1, as <c>tpe/2</c> does not
          accept any form of wildcards for argument <c>Event</c>.</p>
      </desc>
    </func>

    <func>
      <name>tpl(Module,MatchSpec)</name>
      <fsummary>Set pattern for traced local (and global) function calls.
      </fsummary>
      <desc>
        <p>Same as <c>tpl({Module, '_', '_'}, MatchSpec)</c>.</p>
      </desc>
    </func>

    <func>
      <name>tpl(Module,Function,MatchSpec)</name>
      <fsummary>Set pattern for traced local (and global) function calls.
      </fsummary>
      <desc>
        <p>Same as <c>tpl({Module, Function, '_'}, MatchSpec)</c>.</p>
      </desc>
    </func>

    <func>
      <name>tpl(Module, Function, Arity, MatchSpec)</name>
      <fsummary>Set pattern for traced local (and global) function calls.
      </fsummary>
      <desc>
        <p>Same as <c>tpl({Module, Function, Arity}, MatchSpec)</c>.</p>
      </desc>
    </func>

    <func>
      <name>tpl({Module, Function, Arity}, MatchSpec) -> {ok, MatchDesc} |
        {error, term()}</name>
      <fsummary>Set pattern for traced local (and global) function calls.
      </fsummary>
      <desc>
        <p>Works as <seealso marker="#tp-2"><c>tp/2</c></seealso>, but enables
          tracing for local calls (and local functions) as well as for
          global calls (and functions).</p>
      </desc>
    </func>

    <func>
      <name>trace_client(Type, Parameters) -> pid()</name>
      <fsummary>Start a trace client that reads messages created by a trace
        port driver.</fsummary>
      <type>
        <v>Type = ip | file | follow_file</v>
        <v>Parameters = Filename | WrapFilesSpec | IPClientPortSpec</v>
        <v>Filename = string() | [string()] | atom()</v>
        <v>WrapFilesSpec = see trace_port/2</v>
        <v>Suffix = string()</v>
        <v>IpClientPortSpec = PortNumber | {Hostname, PortNumber}</v>
        <v>PortNumber = integer()</v>
        <v>Hostname = string()</v>
      </type>
      <desc>
        <p>Starts a trace client that reads the output
          created by a trace port driver and handles it in mostly the
          same way as a tracer process created by
          <seealso marker="#tracer-0"><c>tracer/0</c></seealso>.</p>
        <p>Allowed values for <c>Type</c>>:</p>
        <taglist>
          <tag><c>file</c></tag>
          <item>
            <p>The client reads all trace
              messages stored in the file named <c>Filename</c> or
              specified by <c>WrapFilesSpec</c> (must be the same as used
              when creating the trace, see
              <seealso marker="#trace_port/2"><c>trace_port/2</c></seealso>).
              and lets the default handler function format the
              messages on the console. This is one way to interpret the data
              stored in a file by the file trace port driver.</p>
          </item>
          <tag><c>follow_file</c></tag>
          <item>
            <p>The client behaves as
              in the <c>file</c> case, but keeps trying to read (and
              process) more data from the file until stopped by
              <seealso marker="#stop_trace_client-1">
              <c>stop_trace_client/1</c></seealso>.
              <c>WrapFilesSpec</c> is not allowed as second argument
              for this <c>Type</c>.</p>
          </item>
          <tag><c>ip</c></tag>
          <item>
            <p>The client connects to the
              TCP/IP port <c>PortNumber</c> on the host <c>Hostname</c>,
              from where it reads trace messages until the TCP/IP connection
              is closed. If no <c>Hostname</c> is specified, the local host
              is assumed.</p>
          </item>
        </taglist>
        <p>As an example, one can let trace messages be sent over the
          network to another Erlang node (preferably <em>not</em>
          distributed), where the formatting occurs:</p>
        <p>On the node <c>stack</c> there is an Erlang node
          <c>ant@stack</c>. In the shell, type the following:</p>
        <pre>
ant@stack> <input>dbg:tracer(port, dbg:trace_port(ip,4711)).</input>
&lt;0.17.0>
ant@stack> <input>dbg:p(self(), send).</input>
{ok,1}</pre>
        <p>All trace messages are now sent to the trace port driver,
          which in turn listens for connections on the TCP/IP port
          4711. If we want to see the messages on another node,
          preferably on another host, we do like this:</p>
        <pre>
-> <input>dbg:trace_client(ip, {"stack", 4711}).</input>
&lt;0.42.0></pre>
        <p>Assume we now send a message from the shell on the node
          <c>ant@stack</c>, where all sends from the shell are traced:</p>
        <pre>
ant@stack> <input>self() ! hello.</input>
hello</pre>
        <p>The following is diplayed at the console on the node that
          started the trace client:</p>
        <pre>
(&lt;0.23.0>) &lt;0.23.0> ! hello
(&lt;0.23.0>) &lt;0.22.0> ! {shell_rep,&lt;0.23.0>,{value,hello,[],[]}}</pre>
        <p>The last line is generated because of internal message passing
          in the Erlang shell. The process IDs will vary.</p>
      </desc>
    </func>

    <func>
      <name>trace_client(Type, Parameters, HandlerSpec) -> pid()</name>
      <fsummary>Start a trace client that reads messages created by a trace
        port driver, with a user-defined handler.</fsummary>
      <type>
        <v>Type = ip | file | follow_file</v>
        <v>Parameters = Filename | WrapFilesSpec | IPClientPortSpec</v>
        <v>Filename = string() | [string()] | atom()</v>
        <v>WrapFilesSpec = see trace_port/2</v>
        <v>Suffix = string()</v>
        <v>IpClientPortSpec = PortNumber | {Hostname, PortNumber}</v>
        <v>PortNumber = integer()</v>
        <v>Hostname = string()</v>
        <v>HandlerSpec = {HandlerFun, InitialData}</v>
        <v>HandlerFun = fun() (two arguments)</v>
        <v>InitialData = term()</v>
      </type>
      <desc>
        <p>Works as <seealso marker="#trace_client-2">
          <c>trace_client/2</c></seealso>,
          but allows you to write your own handler function. The handler
          function works mostly as the one described in
          <seealso marker="#tracer-2"><c>tracer/2</c></seealso>,
          but must also be prepared to handle
          trace messages of the form <c>{drop, N}</c>, where <c>N</c> is
          the number of dropped messages. This pseudo trace message
          occurs only if the <c>ip</c> trace driver is used.</p>
        <p>For trace type <c>file</c>, the pseudo trace message
          <c>end_of_trace</c> is displayed at the end of the trace. The
          return value from the handler function is in this case
          ignored.</p>
      </desc>
    </func>

    <func>
      <name>trace_port(Type, Parameters) -> fun()</name>
      <fsummary>Create and return a trace port generating <em>fun</em>.
      </fsummary>
      <type>
        <v>Type = ip | file</v>
        <v>Parameters = Filename | WrapFilesSpec | IPPortSpec</v>
        <v>Filename = string() | [string()] | atom()</v>
        <v>WrapFilesSpec = {Filename, wrap, Suffix} | {Filename, wrap, Suffix,
          WrapSize} | {Filename, wrap, Suffix, WrapSize, WrapCnt}</v>
        <v>Suffix = string()</v>
        <v>WrapSize = integer() >= 0 | {time, WrapTime}</v>
        <v>WrapTime = integer() >= 1</v>
        <v>WrapCnt = integer() >= 1</v>
        <v>IpPortSpec = PortNumber | {PortNumber, QueSize}</v>
        <v>PortNumber = integer()</v>
        <v>QueSize = integer()</v>
      </type>
      <desc>
        <p>Creates a trace port generating <em>fun</em>.
          The <em>fun</em> takes no arguments and returns a newly opened
          trace port. The return value from this function is suitable as
          a second parameter to
          <seealso marker="#tracer-2"><c>tracer/2</c></seealso>, that is,
          <c>dbg:tracer(port, dbg:trace_port(ip, 4711))</c>.</p>
        <p>A trace port is an
          Erlang port to a dynamically linked-in driver that handles
          trace messages directly, without the overhead of sending them
          as messages in the Erlang virtual machine.</p>
        <p>Two trace drivers are provided, the
          <c>file</c> and the <c>ip</c> trace drivers. The <c>file</c> driver
          sends all trace messages into one or more binary files,
          from where they later can be fetched and processed with
          <seealso marker="#trace_client-2"><c>trace_client/2</c></seealso>.
          The <c>ip</c> driver opens a TCP/IP
          port where it listens for connections. When a client
          (preferably started by calling <seealso marker="#trace_client-2">
          <c>trace_client/2</c></seealso> on
          another Erlang node) connects, all trace messages are sent
          over the IP network for further processing by the remote
          client.</p>
        <p>Using a trace port significantly lowers the overhead
          imposed by using tracing.</p>
        <p>The file trace driver expects a filename or a wrap files 
          specification as parameter. A file is written with a high
          degree of buffering, so all trace messages are <em>not</em>
          guaranteed to be saved in the file if a system crash occurs.
          That is the price to pay for low tracing overhead.</p>
        <p>A wrap files specification is used to limit the disk
          space consumed by the trace. The trace is written to a
          limited number of files, each with a limited size.
          The actual filenames are <c>Filename ++ SeqCnt ++ Suffix</c>,
          where <c>SeqCnt</c> counts as a decimal string
          from <c>0</c> to <c>WrapCnt</c> and then around again from
          <c>0</c>. The following applies:</p>
        <list type="bulleted">
          <item>
            <p>When a trace term written to the current file makes it
              longer than <c>WrapSize</c>, that file is closed.</p>
          </item>
          <item>
            <p>If the number of files in this wrap trace is as many as
              <c>WrapCnt</c>, the oldest file is deleted and then a new
              file is opened to become the current.</p>
          </item>
          <item>
            <p>Thus, when a wrap trace has been stopped, at most
              <c>WrapCnt</c> trace files are saved with a size of at least
              <c>WrapSize</c> (but not much bigger), except for 
              the last file that can even be empty.</p>
          </item>
        </list>
        <p>The default values
          are <c>WrapSize = 128*1024</c> and <c>WrapCnt = 8</c>.</p>
        <p>The <c>SeqCnt</c> values in the filenames are all in the
          range <c>0</c> through <c>WrapCnt</c> with a gap in the
          circular sequence. The gap is needed to find the end of the
          trace.</p>
        <p>If the <c>WrapSize</c> is specified as 
          <c>{time, WrapTime}</c>, the current file is closed when it
          has been open more than <c>WrapTime</c> milliseconds,
          regardless if the file is empty or not.</p>
        <p>The <c>ip</c> trace driver has a queue of <c>QueSize</c> messages
          waiting to be delivered. If the driver cannot deliver messages
          as fast as they are produced by the runtime system, a special
          message is sent, which indicates how many messages that are
          dropped. That message arrives at the handler function specified in
          <seealso marker="#trace_client-3"><c>trace_client/3</c></seealso>
          as the tuple <c>{drop, N}</c>, where <c>N</c> is the number of
          consecutive messages
          dropped. For heavy tracing, drops are likely to occur,
          and they surely occur if no client is reading the trace
          messages.</p>
      </desc>
    </func>

    <func>
      <name>trace_port_control(Operation)</name>
      <fsummary>Same as trace_port_control(node(),Operation).</fsummary>
      <desc>
        <p>Same as <seealso marker="#trace_port_control/2">
          <c>trace_port_control(node(),Operation)</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>trace_port_control(Nodename,Operation) -> ok | {ok, Result} |
        {error, Reason}</name>
      <fsummary>Perform a control operation on the active trace port driver on
        the specified node.</fsummary>
      <type>
        <v>Nodename = atom()</v>
      </type>
      <desc>
        <p>Performs a control operation on the
          active trace port driver on the specified node
          (<c>Nodename</c>). The allowed operations and theír return values
          depend on which trace driver is used.</p>
        <p>Returns either <c>ok</c> or <c>{ok, Result}</c>
          if the operation is successful. Returns <c>{error, Reason}</c>
          if the current tracer is a process
          or if it is a port not supporting the operation.</p>
        <p>Allowed values for <c>Operation</c>:</p>
        <taglist>
          <tag><c>flush</c></tag>
          <item>
            <p>This function is used to flush the internal buffers
              held by a trace port driver. Only the
              <c>file</c> trace driver supports this operation.
              Returns <c>ok</c>.</p>
          </item>
          <tag><c>get_listen_port</c></tag>
          <item>
            <p>Returns <c>{ok, IpPort}</c>, where <c>IpPort</c> is
              the IP port number used by the driver listen socket.
              Only the <c>ip</c> trace driver supports this operation.</p>
          </item>
        </taglist>
      </desc>
    </func>

    <func>
      <name>tracer() -> {ok, pid()} | {error, already_started}</name>
      <fsummary>Start a tracer server that handles trace messages.</fsummary>
      <desc>
        <p>Starts a server on the local node that will
          be the recipient of all trace messages. All the following calls to
          <seealso marker="#p-2"><c>p/2</c></seealso> result in messages sent
          to the newly started trace server.</p>
        <p>A trace server started in this way simply displays the
          trace messages in a formatted way in the Erlang shell (that is,
          use <seealso marker="stdlib:io#format/1"><c>io:format</c></seealso>).
          For information on how the trace
          message handler can be customized, see
          <seealso marker="#tracer-2"><c>tracer/2</c></seealso>.</p>
        <p>To start a similar tracer on a remote node, use
          <seealso marker="#n-1"><c>n/1</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>tracer(Type, Data) -> {ok, pid()} | {error, Error}</name>
      <fsummary>Start a tracer server with more parameters.</fsummary>
      <type>
        <v>Type = port | process | module</v>
        <v>Data = PortGenerator | HandlerSpec | ModuleSpec</v>
        <v>PortGenerator = fun() (no arguments)</v>
        <v>Error = term()</v>
        <v>HandlerSpec = {HandlerFun, InitialData}</v>
        <v>HandlerFun = fun() (two arguments)</v>
        <v>ModuleSpec = fun() (no arguments) | {TracerModule, TracerState}</v>
        <v>ModuleModule = atom()</v>
        <v>InitialData = TracerState = term()</v>
      </type>
      <desc>
        <p>Starts a tracer server with more
          parameters on the local node. The first parameter,
          <c>Type</c>, indicates if trace messages are to be handled
          by a receiving process (<c>process</c>), by a tracer port
          (<c>port</c>), or by a tracer module
          (<c>module</c>). For information about tracer ports, see
          <seealso marker="#trace_port-2"><c>trace_port/2</c></seealso>.
          For information about tracer modules, see
          <seealso marker="erts:erl_tracer"><c>erts:erl_tracer</c></seealso>.
        </p>
        <p>Allowed values for <c>Type</c>>:</p>
        <taglist>
          <tag><c>process</c></tag>
          <item>
            <p>A message handler function can
              be specified (<c>HandlerSpec</c>). The handler function, which
              is to be a <c>fun</c> taking two arguments, will be called
              for each trace message, with the first argument containing the
              message as it is and the second argument containing the return
              value from the last invocation of the fun. The initial value
              of the second parameter is specified in the <c>InitialData</c>
              part of the <c>HandlerSpec</c>. The <c>HandlerFun</c> can
              choose any appropriate action to take when invoked, and can
              save a state for the next invocation by returning it.</p>
          </item>
          <tag><c>port</c></tag>
          <item>
            <p>The second parameter is to
              be a <em>fun</em> that takes no arguments and returns a
              newly opened trace port when called. Such a <em>fun</em> is
              preferably generated by calling
              <seealso marker="#trace_port-2"><c>trace_port/2</c></seealso>.</p>
          </item>
          <tag><c>module</c></tag>
          <item>
            <p>The second parameter is to
              be either a tuple describing the
              <seealso marker="erts:erl_tracer"><c>erts:erl_tracer</c></seealso>
              module to be used for tracing and the state to be used for
              that tracer module, or a fun returning the same tuple.</p>
          </item>
        </taglist>
        <p>If an error is returned, either a tracer
          server is already running (<c>{error,already_started}</c>) or
          the <c>HandlerFun</c> throws an exception.</p>
        <p>To start a similar tracer on a remote node, use
          <seealso marker="#tracer-3"><c>tracer/3</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>tracer(Nodename, Type, Data) -> {ok, Nodename} | {error, Reason}
      </name>
      <fsummary>Start a tracer server on a specified node with more parameters.
      </fsummary>
      <type>
        <v>Nodename = atom()</v>
      </type>
      <desc>
        <p>Equivalent to <seealso marker="#tracer-2">
          <c>tracer/2</c></seealso>, but acts on the
          specified node. A tracer is started on the node (<c>Nodename</c>)
          and the node is added to the list of traced nodes.</p>
        <note>
          <p>This function is not equivalent to
            <seealso marker="#n-1"><c>n/1</c></seealso>. While
            <seealso marker="#n-1"><c>n/1</c></seealso> starts a process
            tracer that redirects all trace
            information to a process tracer on the local node (that is, the
            trace control node), <seealso marker="#tracer-3">
            <c>tracer/3</c></seealso> starts a tracer of any
            type that is independent of the tracer on the trace control
            node.</p>
        </note>
        <p>For details, see
          <seealso marker="#tracer-2"><c>tracer/2</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>wtp(Name) -> ok | {error, IOError}</name>
      <fsummary>Write all saved and built-in match specifications to a file.
      </fsummary>
      <type>
        <v>Name = string()</v>
        <v>IOError = term()</v>
      </type>
      <desc>
        <p>Saves all match specifications saved
          during the session (during calls to
          <seealso marker="#tp-2"><c>tp/2</c></seealso>)
          and built-in match specifications in a text
          file with the name designated by <c>Name</c>. The file
          format is textual, so it can be edited with an
          ordinary text editor, and then restored with
          <seealso marker="#rtp-1"><c>rtp/1</c></seealso>.</p>
        <p>Each match specification in the file ends with a full stop
          (<c>.</c>) and new (syntactically correct) match
          specifications can be added to the file manually.</p>
        <p>The function returns <c>ok</c>, or an error tuple where the
          second element contains the I/O error that made the
          writing impossible.</p>
      </desc>
    </func>
  </funcs>

  <section>
    <marker id="simple_example"></marker>
    <title>Simple Examples - Tracing from the Shell</title>
    <p>The simplest way of tracing from the Erlang shell is to use
      <seealso marker="#c/3"><c>dbg:c/3</c></seealso> or
      <seealso marker="#c/4"><c>dbg:c/4</c></seealso>, for example, tracing the
      <seealso marker="#get_tracer/0"><c>get_tracer/0</c></seealso>function:</p>

    <pre>
(tiger@durin)84> <input>dbg:c(dbg,get_tracer,[]).</input>
(&lt;0.154.0>) &lt;0.152.0> ! {&lt;0.154.0>,{get_tracer,tiger@durin}}
(&lt;0.154.0>) out {dbg,req,1}
(&lt;0.154.0>) &lt;&lt; {dbg,{ok,&lt;0.153.0>}}
(&lt;0.154.0>) in {dbg,req,1}
(&lt;0.154.0>) &lt;&lt; timeout
{ok,&lt;0.153.0>}
(tiger@durin)85></pre>

    <p>Another way of tracing from the shell is to explicitly start a
      <em>tracer</em> and then set the <em>trace flags</em> of your
      choice on the processes you want to trace, for example,
      trace messages and process events:</p>

    <pre>
(tiger@durin)66> <input>Pid = spawn(fun() -> receive {From,Msg} -> From ! Msg end end).</input>
&lt;0.126.0>
(tiger@durin)67> <input>dbg:tracer().</input>
{ok,&lt;0.128.0>}
(tiger@durin)68> <input>dbg:p(Pid,[m,procs]).</input>
{ok,[{matched,tiger@durin,1}]}
(tiger@durin)69> <input>Pid ! {self(),hello}.</input>
(&lt;0.126.0>) &lt;&lt; {&lt;0.116.0>,hello}
{&lt;0.116.0>,hello}
(&lt;0.126.0>) &lt;&lt; timeout
(&lt;0.126.0>) &lt;0.116.0> ! hello
(&lt;0.126.0>) exit normal
(tiger@durin)70> <input>flush().</input>
Shell got hello
ok
(tiger@durin)71></pre>

    <p>If you set the <c>call</c> trace flag, you must also set a
      <em>trace pattern</em> for the functions you want to trace:</p>

    <pre>
(tiger@durin)77> <input>dbg:tracer().</input>
{ok,&lt;0.142.0>}
(tiger@durin)78> <input>dbg:p(all,call).</input>
{ok,[{matched,tiger@durin,3}]}
(tiger@durin)79> <input>dbg:tp(dbg,get_tracer,0,[]).</input>
{ok,[{matched,tiger@durin,1}]}
(tiger@durin)80> <input>dbg:get_tracer().</input>
(&lt;0.116.0>) call dbg:get_tracer()
{ok,&lt;0.143.0>}
(tiger@durin)81> <input>dbg:tp(dbg,get_tracer,0,[{'_',[],[{return_trace}]}]).</input>
{ok,[{matched,tiger@durin,1},{saved,1}]}
(tiger@durin)82> <input>dbg:get_tracer().</input>
(&lt;0.116.0>) call dbg:get_tracer()
(&lt;0.116.0>) returned from dbg:get_tracer/0 -> {ok,&lt;0.143.0>}
{ok,&lt;0.143.0>}
(tiger@durin)83></pre>
  </section>

  <section>
    <marker id="advanced"></marker>
    <title>Advanced Topics - Combining with seq_trace</title>
    <p>The <c>dbg</c> module is primarily targeted towards
      tracing through the <seealso marker="erts:erlang#trace/3">
      <c>erlang:trace/3</c></seealso> function.
      It is sometimes desired to trace messages in a more delicate way, which
      can be done with the help of the
      <seealso marker="kernel:seq_trace"><c>kernel:seq_trace</c></seealso>
      module.</p>

    <p><c>seq_trace</c> provides sequential tracing (known in the
      AXE 10 world, and sometimes called "forlopp tracing"). <c>dbg</c>
      can interpret messages generated from <c>seq_trace</c> and the
      same tracer function for both types of tracing can be used. The
      <c>seq_trace</c> messages can even be sent to a trace port for
      further analysis.</p>

    <p>As a match specification can turn on sequential tracing, the
      combination of <c>dbg</c> and <c>seq_trace</c> can be powerful.
      The follwing brief example shows a session where sequential
      tracing is used:</p>

    <pre>
1> <input>dbg:tracer().</input>
{ok,&lt;0.30.0>}
2> <input>{ok, Tracer} = dbg:get_tracer().</input>
{ok,&lt;0.31.0>}
3> <input>seq_trace:set_system_tracer(Tracer).</input>
false
4> <input>dbg:tp(dbg, get_tracer, 0, [{[],[],[{set_seq_token, send, true}]}]).</input>
{ok,[{matched,nonode@nohost,1},{saved,1}]}
5> <input>dbg:p(all,call).</input>
{ok,[{matched,nonode@nohost,22}]}
6> <input>dbg:get_tracer(), seq_trace:set_token([]).</input>
(&lt;0.25.0>) call dbg:get_tracer()
SeqTrace [0]: (&lt;0.25.0>) &lt;0.30.0> ! {&lt;0.25.0>,get_tracer} [Serial: {2,4}]
SeqTrace [0]: (&lt;0.30.0>) &lt;0.25.0> ! {dbg,{ok,&lt;0.31.0>}} [Serial: {4,5}]
{1,0,5,&lt;0.30.0>,4}</pre>

    <p>This session sets the system tracer to the same process as
      the ordinary tracer process (that is, &lt;0.31.0&gt;) and sets the
      trace pattern for the <c>dbg:get_tracer</c> function to one that
      has the action of setting a sequential token. When the function
      is called by a traced process (all processes are traced in this
      case), the process gets "contaminated" by the token and
      <c>seq_trace</c> messages are sent both for the server request
      and the response. The <c>seq_trace:set_token([])</c> after the
      call clears the <c>seq_trace</c> token, so no messages are sent
      when the answer propagates through the shell to the console port.
      The output would otherwise have been more noisy.</p>
  </section>

  <section>
    <title>Note of Caution</title>
    <p>When tracing function calls on a group leader process (an I/O process),
      there is risk of causing a deadlock. This occurs if a group leader
      process generates a trace message and the tracer process, by calling
      the trace handler function, sends an I/O request to the same group leader.
      The problem only occurs if the trace handler prints to the terminal
      using an <c>io</c> function, such as
      <seealso marker="stdlib:io#format-2"><c>io:format/2</c></seealso>.</p>
    <p>Notice that when
      <seealso marker="#p/2"><c>dbg:p(all,call)</c></seealso> is called,
      I/O processes are also traced.</p>

    <p>Example:</p>

    <pre>
%% Using a default line editing shell
1> <input>dbg:tracer(process, {fun(Msg,_) -> io:format("~p~n", [Msg]), 0 end, 0}).</input>
{ok,&lt;0.37.0>}
2> <input>dbg:p(all, [call]).</input>
{ok,[{matched,nonode@nohost,25}]}
3> <input>dbg:tp(mymod,[{'_',[],[]}]).</input>
{ok,[{matched,nonode@nohost,0},{saved,1}]}
4> <input>mymod:</input> % TAB pressed here
%% -- Deadlock --</pre>

    <p>Another example:</p>

    <pre>
%% Using a shell without line editing (oldshell)
1> <input>dbg:tracer(process).</input>
{ok,&lt;0.31.0>}
2> <input>dbg:p(all, [call]).</input>
{ok,[{matched,nonode@nohost,25}]}
3> <input>dbg:tp(lists,[{'_',[],[]}]).</input>
{ok,[{matched,nonode@nohost,0},{saved,1}]}
% -- Deadlock --</pre>

    <p>A deadlock occurs in the first example because when TAB is pressed
      to expand the function name, the group leader (which handles character
      input) calls <c>mymod:module_info()</c>. This generates a trace message
      which, in turn, causes the tracer process to send an I/O request to the
      group leader (by calling <c>io:format/2</c>).</p>

    <p>In the second example, the default trace handler function is used.
      This handler prints to the terminal by sending I/O requests to the
      <c>user</c> process. When Erlang is started in oldshell mode, the
      shell process has <c>user</c> as its group leader and so has the
      tracer process in this example. As <c>user</c> calls functions in
      <c>lists</c>, a deadlock occurs when the first I/O request is sent.</p>

    <p><em>Suggestions for how to avoid deadlock:</em></p>

    <list type="bulleted">
      <item>
        <p>Do not trace the group leader of the tracer process.
          If tracing has been switched on for all processes, call
          <seealso marker="#p/2"><c>dbg:p(TracerGLPid,clear)</c></seealso>
          to stop tracing the group leader (<c>TracerGLPid</c>).
          <c>process_info(TracerPid,group_leader)</c>
          tells you which process this is (<c>TracerPid</c> is returned from
          <seealso marker="#get_tracer/0"><c>dbg:get_tracer/0</c>)</seealso>.
        </p>
      </item>
      <item>
        <p>Do not trace the <c>user</c> process if using the default trace
          handler function.</p>
      </item>
      <item>
        <p>In your own trace handler function, either call
          <seealso marker="erts:erlang#display/1">
          <c>erlang:display/1</c></seealso>
          instead of an <c>io</c> function, or, if <c>user</c> is not used
          as group leader, print to <c>user</c> instead of the default group
          leader. Example: <c>io:format(user,Str,Args)</c>.</p>
      </item>
    </list>
  </section>
</erlref>

