<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>2003</year><year>2016</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    
    </legalnotice>

    <title>megaco_encoder</title>
    <prepared>Micael Karlberg</prepared>
    <responsible>Micael Karlberg</responsible>
    <docno></docno>
    <approved>Micael Karlberg</approved>
    <checked></checked>
    <date>2016-12-14</date>
    <rev>%VSN%</rev>
    <file>megaco_encoder.xml</file>
  </header>
  <module>megaco_encoder</module>
  <modulesummary>Megaco encoder behavior.</modulesummary>
  <description>
    <p>The functions in this module are to be exported from a
      <c><![CDATA[megaco_encoder]]></c> callback module.</p>
  </description>

  <datatypes>
    <datatype>
      <name name="action_reply() = #'ActionReply'{}"/>
    </datatype>
    <datatype>
      <name name="action_request() = #'ActionRequest'{}"/>
    </datatype>
    <datatype>
      <name name="megaco_message() = #'MegacoMessage{}'"/>
    </datatype>
    <datatype>
      <name name="transaction() =
        {segmentReply, segment_reply()} |
        {transactionPending, transaction_reply()} |
        {transactionReply, transaction_pending()} |
        {transactionRequest, transaction_request()} |
        {transactionResponseAck, transaction_response_ack()}"/>
    </datatype>
    <datatype>
      <name name="segment_reply() = #'SegmentReply'{}"/>
    </datatype>
    <datatype>
      <name name="transaction_ack() = #'TransactionAck'{}"/>
    </datatype>
    <datatype>
      <name name="transaction_pending() = #'TransactionPending'{}"/>
    </datatype>
    <datatype>
      <name name="transaction_reply() = #'TransactionReply'{}"/>
    </datatype>
    <datatype>
      <name name="transaction_request() = #'TransactionRequest'{}"/>
    </datatype>
    <datatype>
      <name name="transaction_response_ack() = [transaction_ack()]"/>
      <desc>
      <marker id="encode_message"></marker>
      </desc>
    </datatype>
  </datatypes>

  <funcs>
    <func>
      <name>Module:encode_message(EncodingConfig, Version, Message)
        -> {ok, Bin} | Error</name>
      <fsummary>Encode a Megaco message.</fsummary>
      <type>
        <v>EncodingConfig = list()</v>
        <v>Version = integer()</v>
        <v>Message = megaco_message()</v>
        <v>Bin = binary()</v>
        <v>Error = term()</v>
      </type>
      <desc>
        <p>Encodes a Megaco message.</p>
	<marker id="decode_message"></marker>
      </desc>
    </func>

    <func>
      <name>Module:decode_message(EncodingConfig, Version, Bin)
        -> {ok, Message} | Error</name>
      <fsummary>Decode a Megaco message.</fsummary>
      <type>
        <v>EncodingConfig = list()</v>
        <v>Version = integer() | dynamic</v>
        <v>Message = megaco_message()</v>
        <v>Bin = binary()</v>
        <v>Error = term()</v>
      </type>
      <desc>
        <p>Decodes a megaco message.</p>
        <p>Notice that if argument <c>Version</c> is <c><![CDATA[dynamic]]></c>,
          the decoder is to try to figure out the actual version from the
          message itself and then use the proper decoder, for example,
          version 1. If argument <c>Version</c> is an integer,
          this is the expected version of the message and
          the decoder for that version is to be used.</p>
	<marker id="decode_mini_message"></marker>
      </desc>
    </func>

    <func>
      <name>Module:decode_mini_message(EncodingConfig, Version, Bin)
        -> {ok, Message} | Error</name>
      <fsummary>Perform a minimal decode of a Megaco message.</fsummary>
      <type>
        <v>EncodingConfig = list()</v>
        <v>Version = integer() | dynamic</v>
        <v>Message = megaco_message()</v>
        <v>Bin = binary()</v>
        <v>Error = term()</v>
      </type>
      <desc>
        <p>Performs a minimal decode of a Megaco message.</p>
        <p>A successfull result is a <c><![CDATA[MegacoMessage]]></c>
          in which only the version and the MID have been initiated.
          This function is used by the <c>megaco_messenger</c> module when the
          <c><![CDATA[decode_message/3]]></c> function fails to figure out the
          MID (the actual sender) of the message.</p>
        <p>Notice that a successful decode only returns a
          partially initiated message.</p>
	<marker id="encode_transaction"></marker>
      </desc>
    </func>

    <func>
      <name>Module:encode_transaction(EncodingConfig, Version, Transaction)
        -> OK | Error</name>
      <fsummary>Encode a Megaco transaction.</fsummary>
      <type>
        <v>EncodingConfig = list()</v>
        <v>Version = integer()</v>
        <v>Transaction = transaction()</v>
        <v>OK = {ok, Bin}</v>
        <v>Bin = binary()</v>
        <v>Error = {error, Reason}</v>
        <v>Reason = not_implemented | OtherReason</v>
        <v>OtherReason = term()</v>
      </type>
      <desc>
        <p>Encodes a Megaco transaction. If this, for whatever reason,
          is not supported, the function is to return the error reason
          <c>not_implemented</c>.</p>
        <p>Notice that this functionality is used both when the transaction
          sender is used and for segmentation. So, for either of those to work,
          this function <em>must</em> be fully supported.</p>
	<marker id="encode_action_requests"></marker>
      </desc>
    </func>

    <func>
      <name>Module:encode_action_requests(EncodingConfig, Version, ARs)
        -> OK | Error</name>
      <fsummary>Encode Megaco action requests.</fsummary>
      <type>
        <v>EncodingConfig = list()</v>
        <v>Version = integer()</v>
        <v>ARs = action_requests()</v>
        <v>action_requests() = [action_request()]</v>
        <v>OK = {ok, Bin}</v>
        <v>Bin = binary()</v>
        <v>Error = {error, Reason}</v>
        <v>Reason = not_implemented | OtherReason</v>
        <v>OtherReason = term()</v>
      </type>
      <desc>
        <p>Encodes Megaco action requests. This function is called when
          the user calls the function
          <seealso marker="megaco#encode_actions">
          <c>megaco:encode_actions/3</c></seealso>.
          If that function is never used or if the codec cannot support this
          (the encoding of individual actions), the function is to return
          the error reason <c>not_implemented</c>.</p>
	<marker id="encode_action_reply"></marker>
      </desc>
    </func>

    <func>
      <name>Module:encode_action_reply(EncodingConfig, Version, AR)
        -> OK | Error</name>
      <fsummary>Encode a Megaco action reply.</fsummary>
      <type>
        <v>EncodingConfig = list()</v>
        <v>Version = integer()</v>
        <v>AR = action_reply()</v>
        <v>OK = {ok, Bin}</v>
        <v>Bin = binary()</v>
        <v>Error = {error, Reason}</v>
        <v>Reason = not_implemented | OtherReason</v>
        <v>OtherReason = term()</v>
      </type>
      <desc>
        <p>Encodes a Megaco action reply. If this, for whatever reason,
          is not supported, the function is to return the error reason
          <c>not_implemented</c>.</p>
        <p>Notice that this function is used when segmentation has been
          configured. So, for this to work, this function <em>must</em> be
          fully supported.</p>
      </desc>
    </func>
  </funcs>

</erlref>

