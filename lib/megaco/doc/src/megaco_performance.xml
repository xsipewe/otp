<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE chapter SYSTEM "chapter.dtd">

<chapter>
  <header>
    <copyright>
      <year>2002</year><year>2016</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.

    </legalnotice>

    <title>Performance Comparison</title>
    <prepared>H&aring;kan Mattsson</prepared>
    <responsible>H&aring;kan Mattsson</responsible>
    <docno></docno>
    <approved>H&aring;kan Mattsson</approved>
    <checked></checked>
    <date>2016-12-12</date>
    <rev>%VSN%</rev>
    <file>megaco_performance.xml</file>
  </header>

  <section>
    <title>Comparison of Encoders/Decoders</title>
    <p>The Megaco/H.248 standard defines both a plain text encoding and a
      binary encoding (ASN.1 BER) and we have implemented encoders and
      decoders for both. We supplies a number of different encoding/decoding
      modules and the users can implement their own (like our <c>erl_dist</c>
      module). Using a non-standard encoding format has obvious drawbacks,
      but can be useful in some configurations.</p>

    <p>To compare our different encoders/decoders,
      we have made four different measurements of our Erlang/OTP
      implementation of the Megaco/H.248 protocol stack.
      The result of each one is summarized in the table below.</p>

    <p>The results shown in the table are the fastest
      of these configurations for each codec. The figures presented are
      the average of all used messages.</p>

    <p>For comparison, the table also includes the following:</p>
    <list type="bulleted">
      <item>
        <p>Performance figures with
          Megaco (including the measurement software) and ASN1 applications
          HIPE-compiled (the second figure in the time columns). Notice that
          <c>per bin</c> decode had some issues, so those figures are not
          included.</p>
      </item>
      <item>
        <p>Performance figures where the flex driver was built as
          <c>non-reentrant</c> flex (the third figure in the time columns,
          only valid for text codecs using the flex-scanner).</p>
      </item>
    </list>

    <table>
      <row>
        <cell align="left" valign="middle"><em>Codec and config</em></cell>
        <cell align="center" valign="middle"><em>Size</em></cell>
        <cell align="center" valign="middle"><em>Encode</em></cell>
        <cell align="center" valign="middle"><em>Decode</em></cell>
        <cell align="center" valign="middle"><em>Total</em></cell>
      </row>

      <!-- PRETTY -->
      <row>
        <cell align="left" valign="middle">pretty</cell>
        <cell align="right" valign="middle">336</cell>
        <cell align="right" valign="middle">20 / 13</cell>
        <cell align="right" valign="middle">75 / 40</cell>
        <cell align="right" valign="middle">95 / 53</cell>
      </row>
      <row>
        <cell align="left" valign="middle">pretty [flex]</cell>
        <cell align="right" valign="middle">336</cell>
        <cell align="right" valign="middle">20 / 13 / 20</cell>
        <cell align="right" valign="middle">39 / 33 / 38</cell>
        <cell align="right" valign="middle">59 / 46 / 58</cell>
      </row>

      <!-- COMPACT -->
      <row>
        <cell align="left" valign="middle">compact</cell>
        <cell align="right" valign="middle">181</cell>
        <cell align="right" valign="middle">17 / 10</cell>
        <cell align="right" valign="middle">62 / 35</cell>
        <cell align="right" valign="middle">79 / 45</cell>
      </row>
      <row>
        <cell align="left" valign="middle">compact [flex]</cell>
        <cell align="right" valign="middle">181</cell>
        <cell align="right" valign="middle">17 / 10 / 17</cell>
        <cell align="right" valign="middle">37 / 31 / 36</cell>
	<cell align="right" valign="middle">54 / 41 / 53</cell>
      </row>

      <!-- PER -->
      <row>
        <cell align="left" valign="middle">per bin</cell>
        <cell align="right" valign="middle">91</cell>
        <cell align="right" valign="middle">60 / 29</cell>
        <cell align="right" valign="middle">64 / -</cell>
        <cell align="right" valign="middle">124 / -</cell>
      </row>
      <row>
        <cell align="left" valign="middle">per bin [driver]</cell>
        <cell align="right" valign="middle">91</cell>
        <cell align="right" valign="middle">39 / 24</cell>
        <cell align="right" valign="middle">42 / 26</cell>
        <cell align="right" valign="middle">81 / 50</cell>
      </row>
      <row>
        <cell align="left" valign="middle">per bin [native]</cell>
        <cell align="right" valign="middle">91</cell>
        <cell align="right" valign="middle">45 / 21</cell>
        <cell align="right" valign="middle">48 / -</cell>
        <cell align="right" valign="middle">93 / -</cell>
      </row>
      <row>
        <cell align="left" valign="middle">per bin [driver, native]</cell>
        <cell align="right" valign="middle">91</cell>
        <cell align="right" valign="middle">25 / 15</cell>
        <cell align="right" valign="middle">27 / 18</cell>
        <cell align="right" valign="middle">52 / 33</cell>
      </row>

      <!-- BER -->
      <row>
        <cell align="left" valign="middle">ber bin</cell>
        <cell align="right" valign="middle">165</cell>
        <cell align="right" valign="middle">32 / 19</cell>
        <cell align="right" valign="middle">38 / 21</cell>
        <cell align="right" valign="middle">70 / 40</cell>
      </row>
      <row>
        <cell align="left" valign="middle">ber bin [driver]</cell>
        <cell align="right" valign="middle">165</cell>
        <cell align="right" valign="middle">32 / 19</cell>
        <cell align="right" valign="middle">33 / 20</cell>
        <cell align="right" valign="middle">65 / 39</cell>
      </row>
      <row>
        <cell align="left" valign="middle">ber bin [native]</cell>
        <cell align="right" valign="middle">165</cell>
        <cell align="right" valign="middle">17 / 11</cell>
        <cell align="right" valign="middle">25 / 13</cell>
        <cell align="right" valign="middle">42 / 24</cell>
      </row>
      <row>
        <cell align="left" valign="middle">ber bin [driver, native]</cell>
        <cell align="right" valign="middle">165</cell>
        <cell align="right" valign="middle">17 / 11</cell>
        <cell align="right" valign="middle">17 / 12</cell>
        <cell align="right" valign="middle">34 / 23</cell>
      </row>

      <!-- ERLANG -->
      <row>
        <cell align="left" valign="middle">erl_dist</cell>
        <cell align="right" valign="middle">875</cell>
        <cell align="right" valign="middle">5 / 5</cell>
        <cell align="right" valign="middle">10 / 10</cell>
        <cell align="right" valign="middle">15 / 15</cell>
      </row>
      <row>
        <cell align="left" valign="middle">erl_dist [megaco_compressed]</cell>
        <cell align="right" valign="middle">405</cell>
        <cell align="right" valign="middle">6 / 4</cell>
        <cell align="right" valign="middle">7 / 4</cell>
        <cell align="right" valign="middle">13 / 8</cell>
      </row>
      <row>
        <cell align="left" valign="middle">erl_dist [compressed]</cell>
        <cell align="right" valign="middle">345</cell>
        <cell align="right" valign="middle">47 / 47</cell>
        <cell align="right" valign="middle">20 / 20</cell>
        <cell align="right" valign="middle">67 / 67</cell>
      </row>
      <row>
        <cell align="left" valign="middle">erl_dist [megaco_compressed, compressed]</cell>
        <cell align="right" valign="middle">200</cell>
        <cell align="right" valign="middle">34 / 33</cell>
        <cell align="right" valign="middle">11 / 9</cell>
        <cell align="right" valign="middle">45 / 42</cell>
      </row>

      <tcaption>Codec Performance</tcaption>
    </table>
  </section>

  <section>
    <title>System Performance Characteristics</title>
    <p>This is primarily a way to show the effects of using the
      reentrant flex scanner instead of the non-reentrant.</p>
    <p>As can be seen from the figures above, there is no real difference
      between a non-reentrant and a reentrant flex scanner regarding
      the decode times of an individual message.</p>
    <p>The real difference is instead in system characteristics, which
      is best shown with the MStone1 test.</p>
    <p>When running SMP Erlang on a multi-core machine, the "throughput"
      is significantly higher. The MStone1 test is an extreme test,
      but it shows what is gained by using the reentrant flex scanner.</p>
    <image file="mstone1.jpg">
        <icaption>MStone1 with mstone1.sh -d flex -s 4</icaption>
    </image>
  </section>

  <section>
    <title>Description of Encoders/Decoders</title>
    <p>In Appendix A of the Megaco/H.248 specification
      (<url href="https://tools.ietf.org/html/rfc3525">RFC 3525</url>),
      about 30 messages show a representative call flow. We have also
      added a few extra version 1, version 2, and version 3 messages.
      We have used these messages as basis for our measurements.
      Our figures have not been weighted regarding how frequent
      different kinds of messages are sent between the media
      gateway and its controller.</p>
    <p>The test compares the following encoders/decoders:</p>
    <list type="bulleted">
      <item>
        <p><em>pretty</em> - Pretty printed text. In the text encoding,
          the protocol stack implementors can use a mix of short and long
          keywords, and to add
          white spaces to improve readability. The pretty-text encoding
          uses long keywords and an indentation style like the
          text examples in the Megaco/H.248 specification.</p>
      </item>
      <item>
        <p><em>compact</em> - The compact text encoding uses the shortest
          possible keywords and no optional white spaces.</p>
      </item>
      <item>
        <p><em>ber</em> - ASN.1 BER.</p>
      </item>
      <item>
        <p><em>per</em> - ASN.1 PER. Not standardized as a valid
          Megaco/H.248 encoding, but included for completeness
          as its encoding is extremely compact.</p>
      </item>
      <item>
        <p><em>erl_dist</em> - Erlang's native distribution format. Not
          standardized as a valid Megaco/H.248 encoding, but included
          as a reference because its well-known performance characteristics.
          Erlang is a dynamically typed language and any Erlang data
          structure can be serialized to the erl_dist format by using
          built-in functions.</p>
      </item>
    </list>
    <p>The encoded messages have been collected in one directory per
      encoding type, containing one file per encoded message.</p>
    <p>The following text message examples show the difference between
      the pretty and compact versions. First the pretty printed, well-indented
      version with long keywords:</p>
    <pre>
MEGACO/1 [124.124.124.222] 
  Transaction = 9998 { 
    Context = - { 
      ServiceChange = ROOT { 
        Services { 
          Method = Restart, 
          ServiceChangeAddress = 55555, 
          Profile = ResGW/1, 
          Reason = "901 MG Cold Boot"
        }
      }  
    }
  }</pre>
    <p>The corresponding compact version without indentation and with
      short keywords is as follows:</p>
    <pre>
!/1 [124.124.124.222]
T=9998{C=-{SC=ROOT{SV{MT=RS,AD=55555,PF=ResGW/1,RE="901 MG Cold Boot"}}}}</pre>
  </section>

  <section>
    <title>Setup</title>
    <p>The measurements were performed on a HP xw4600 workstation with
      an Intel Core 2 Quad CPU Q9550 @ 2.83 GHz, with 4 GB memory and
      running Ubuntu 10.04 x86_64, kernel 2.6.32-22-generic.
      Software versions were OTP R13B04 (megaco-3.14).</p>
  </section>

  <section>
    <title>Summary</title>
    <p>In our measurements we have seen that there are no significant
      differences in message sizes between ASN.1 BER and the compact
      text format. Some care should be taken when using the pretty-text
      style (which is used in all the examples included in the protocol
      specification and preferred during debugging sessions), as the
      messages can be large. If the message size is a
      serious issue, our per encoder is to be used, as the ASN.1 PER
      format is much more compact than all other alternatives. Its
      major drawback is that it is has not been approved as a valid
      Megaco/H.248 message encoding.</p>

    <p>For pure encode/decode performance, the following apply:</p>
    <list type="bulleted"> 
      <item>
        <p>Our fastest binary encoder (ber) is about equal
          to our fastest text encoder (compact).</p>
      </item>
      <item>
        <p>Our fastest binary decoder (ber) is about 54% (61%) faster than our
          fastest text decoder (compact).</p>
      </item>
    </list> 

    <p>If the pure encode/decode performance really is a serious issue, our
      erl_dist encoder can be used, as the encoding/decoding of the
      erlang distribution format is much faster than all the other
      alternatives. Its major drawback is that it is has not been approved
      as a valid Megaco/H.248 message encoding.</p>

    <p>There is no performance advantage of building (and using) a
      non-reentrant flex scanner over a reentrant flex scanner (if flex
      supports building such a scanner).</p>

    <note>
      <p>These performance figures are related to our
        implementation in Erlang/OTP. Measurements of other implementations
        using other tools and techniques can of course result in other
        figures.</p>
    </note>
  </section>
</chapter>

