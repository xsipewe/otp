<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>2000</year><year>2016</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    
    </legalnotice>

    <title>megaco_tcp</title>
    <prepared>Lars Thors&eacute;n</prepared>
    <responsible>Lars Thors&eacute;n</responsible>
    <docno></docno>
    <approved>Lars Thors&eacute;n</approved>
    <checked></checked>
    <date>2016-12-14</date>
    <rev>%VSN%</rev>
    <file>megaco_tcp.xml</file>
  </header>
  <module>megaco_tcp</module>
  <modulesummary>Interface module to TPKT transport protocol for Megaco/H.248.
  </modulesummary>
  <description>
    <p>This module contains the public interface to the TPKT (TCP/IP) version
      transport protocol for Megaco/H.248.</p>
  </description>

  <funcs>
    <func>
      <name>start_transport() -> {ok, TransportRef}</name>
      <fsummary></fsummary>
      <type>
        <v>TransportRef = pid()</v>
      </type>
      <desc>
        <p>Starts the TCP/IP transport service. To stop the transport service,
          use <c>exit(TransportRef, Reason)</c>.</p>
      </desc>
    </func>

    <func>
      <name>listen(TransportRef, ListenPortSpecList) -> ok</name>
      <fsummary></fsummary>
      <type>
        <v>TransportRef = pid() | regname()</v>
        <v>OptionListPerPort = [Option]</v>
        <v>Option = {port, integer()} |{options, list()}
          |{receive_handle, term()}</v>
      </type>
      <desc>
        <p>Starts a new TPKT listening socket
          for TCP/IP. The option list contains the socket
          definitions.</p>
      </desc>
    </func>

    <func>
      <name>connect(TransportRef, OptionList) -> {ok, Handle, ControlPid}
        | {error, Reason}</name>
      <fsummary></fsummary>
      <type>
        <v>TransportRef = pid() | regname()</v>
        <v>OptionList = [Option]</v>
        <v>Option = {host, Ipaddr} | {port, integer()}  |{options, list()}
          |{receive_handle, term()} |{module, atom()}</v>
        <v>Handle = socket_handle()</v>
        <v>ControlPid = pid()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Opens a TPKT connection.</p>
        <p>A user can provide an own callback module using option
          <c><![CDATA[module]]></c>. The function
          <c><![CDATA[receive_message/4]]></c>
          or <c><![CDATA[process_received_message/4]]></c> of this
          module is called
          when a new message is received (which one depends on the message 
          size: small - receive_message, large - process_received_message).
          Defaults to <c>megaco</c>.</p>
      </desc>
    </func>

    <func>
      <name>close(Handle) -> ok</name>
      <fsummary></fsummary>
      <type>
        <v>Handle = socket_handle()</v>
      </type>
      <desc>
        <p>Closes an active TPKT connection.</p>
      </desc>
    </func>

    <func>
      <name>socket(Handle) -> Socket</name>
      <fsummary></fsummary>
      <type>
        <v>Handle = socket_handle()</v>
        <v>Socket = inet_socket()</v>
      </type>
      <desc>
        <p>Converts a <c>socket_handle()</c> to an <c>inet_socket()</c>.</p>
        <p><c>inet_socket()</c> is a plain socket. For more information, see
          the <seealso marker="kernel:inet"><c>kernel:inet</c></seealso>
          module.</p>
      </desc>
    </func>

    <func>
      <name>send_message(Handle, Message) -> ok</name>
      <fsummary></fsummary>
      <type>
        <v>Handle = socket_handle()</v>
        <v>Message = binary() | iolist()</v>
      </type>
      <desc>
        <p>Sends a message on a connection.</p>
      </desc>
    </func>

    <func>
      <name>block(Handle) -> ok</name>
      <fsummary></fsummary>
      <type>
        <v>Handle = socket_handle()</v>
      </type>
      <desc>
        <p>Stops receiving incoming messages on the socket.</p>
      </desc>
    </func>

    <func>
      <name>unblock(Handle) -> ok</name>
      <fsummary></fsummary>
      <type>
        <v>Handle = socket_handle()</v>
      </type>
      <desc>
        <p>Starts to receive incoming messages from the socket again.</p>
        <marker id="upgrade_receive_handle"></marker>
      </desc>
    </func>

    <func>
      <name>upgrade_receive_handle(ControlPid) -> ok</name>
      <fsummary></fsummary>
      <type>
        <v>ControlPid = pid()</v>
      </type>
      <desc>
        <p>Updates the receive handle of the control process, for example,
          after having changed protocol version.</p>
        <marker id="stats"></marker>
      </desc>
    </func>

    <func>
      <name>get_stats() -> {ok, TotalStats} | {error, Reason}</name>
      <name>get_stats(SendHandle) -> {ok, SendHandleStats} | {error, Reason}
      </name>
      <name>get_stats(SendHandle, Counter) -> {ok, CounterStats}
        | {error, Reason}</name>
      <fsummary></fsummary>
      <type>
        <v>TotalStats = [send_handle_stats()]</v>
        <v>total_stats() = {send_handle(), [stats()]}</v>
        <v>SendHandle = send_handle()</v>
        <v>SendHandleStats = [stats()]</v>
        <v>Counter = tcp_stats_counter()</v>
        <v>CounterStats = integer()</v>
        <v>stats() = {tcp_stats_counter(), integer()}</v>
        <v>tcp_stats_counter() = medGwyGatewayNumInMessages
          | medGwyGatewayNumInOctets | medGwyGatewayNumOutMessages
          | medGwyGatewayNumOutOctets | medGwyGatewayNumErrors</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Retreives the TCP-related (SNMP) statistics counters.</p>
      </desc>
    </func>

    <func>
      <name>reset_stats() -> void()</name>
      <name>reset_stats(SendHandle) -> void()</name>
      <fsummary></fsummary>
      <type>
        <v>SendHandle = send_handle()</v>
      </type>
      <desc>
        <p>Resets all TCP-related (SNMP) statistics counters.</p>
      </desc>
    </func>
  </funcs>

</erlref>

