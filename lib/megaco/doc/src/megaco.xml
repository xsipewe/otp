<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>2000</year><year>2016</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.

    </legalnotice>

    <title>megaco</title>
    <prepared>H&aring;kan Mattsson</prepared>
    <responsible>H&aring;kan Mattsson</responsible>
    <docno></docno>
    <approved>H&aring;kan Mattsson</approved>
    <checked></checked>
    <date>2016-12-14</date>
    <rev>%VSN%</rev>
    <file>megaco.xml</file>
  </header>
  <module>megaco</module>
  <modulesummary>Main API of the Megaco application.</modulesummary>
  <description>
    <p>Interface module for the Megaco application.</p>
  </description>

  <datatypes>
    <datatype>
      <name name="action_reply() = #'ActionReply'{}"/>
    </datatype>
    <datatype>
      <name name="action_request() = #'ActionRequest'{}"/>
    </datatype>
    <datatype>
      <name name="deviceName() = pathName()"/>
    </datatype>
    <datatype>
      <name name="domainName() = #'DomainName'{}"/>
    </datatype>
    <datatype>
      <name name="error_desc() = #'ErrorDescriptor'{}"/>
    </datatype>
    <datatype>
      <name name="ip4Address() = #'IP4Address'{}"/>
    </datatype>
    <datatype>
      <name name="ip6Address() = #'IP6Address'{}"/>
    </datatype>
    <datatype>
      <name name="megaco_incr_timer() = #megaco_incr_timer{}"/>
      <desc>
        <p>The record <c><![CDATA[megaco_incr_timer]]></c> contains the
          following fields:</p>
        <taglist>
          <tag><c><![CDATA[wait_for = integer() >= 0]]></c></tag>
          <item>
            <p>The actual timer time.</p>
          </item>
          <tag><c><![CDATA[factor = integer() >= 0]]></c></tag>
          <item>
            <p>The factor when calculating the new timer time
              (<c><![CDATA[wait_for]]></c>).</p>
          </item>
          <tag><c><![CDATA[incr = integer()]]></c></tag>
          <item>
            <p>The increment value when calculating the new timer time
              (<c><![CDATA[wait_for]]></c>). Notice that this value <em>can</em>
              be negative and that a timer restart can therefore lead to a
              <c><![CDATA[wait_for]]></c> value of zero. It is up to the user
              to be aware of the consequences of a <c><![CDATA[wait_for]]></c>
              value of zero.</p>
          </item>
          <tag><c><![CDATA[max_retries = infinity | infinity_restartable |
            integer() >= 0]]></c></tag>
          <item>
            <p>The maximum number of repetitions of the timer.</p>
            <p>There is a special case for this field. When the
              <c><![CDATA[max_retries]]></c> has the value
              <c><![CDATA[infinity_restartable]]></c>,
              it means that the timer is restartable as long as some
              external event occurs (for example, receipt of a pending 
              message). But the timer never
              restarts "by itself", that is, when the timer expires
              (whatever the time-out time), so does the timer.
              Whenever the timer is restarted, the time-out time
              is calculated in the usual way. Also, as mentioned
              above, beware the consequences of setting the value to
              <c><![CDATA[infinity]]></c> if <c>incr</c> has been set to
              a negative value.</p>
          </item>
        </taglist>
      </desc>
    </datatype>
    <datatype>
      <name name="megaco_mid() = ip4Address() | ip6Address() | domainName() |
        deviceName() | mtpAddress()"/>
      <desc>
        <marker id="megaco_timer"></marker>
      </desc>
    </datatype>
    <datatype>
      <name name="megaco_timer() = infinity | integer() >= 0 |
        megaco_incr_timer()"/>
    </datatype>
    <datatype>
      <name name="mtpAddress() = octetString(2..4)"/>
    </datatype>
    <datatype>
      <name name="pathName() = ia5String(1..64)"/>
    </datatype>
    <datatype>
      <name name="property_group() = [property_parm()]"/>
    </datatype>
    <datatype>
      <name name="property_groups() = [property_group()]"/>
    </datatype>
    <datatype>
      <name name="property_parm() = #'PropertyParm'{}"/>
    </datatype>
    <datatype>
      <name name="resend_indication() = flag | boolean()"/>
    </datatype>
    <datatype>
      <name name="sdp() = sdp_a() | sdp_a_ptime() | sdp_a_rtpmap() | sdp_b() |
        sdp_c() | sdp_e() | sdp_i() | sdp_k() | sdp_m() | sdp_o() | sdp_p() |
        sdp_r() | sdp_s() | sdp_t() | sdp_u() | sdp_z()"/>
    </datatype>
    <datatype>
      <name name="sdp_a() = #megaco_sdp_a{)"/>
      <desc><p>Session attribute.</p></desc>
    </datatype>
    <datatype>
      <name name="sdp_a_fmtp() = #megaco_sdp_a_fmtp{}"/>
    </datatype>
    <datatype>
      <name name="sdp_a_ptime() = #megaco_sdp_a_ptime{}"/>
    </datatype>
    <datatype>
      <name name="sdp_a_quality() = #megaco_sdp_a_quality{}"/>
    </datatype>
    <datatype>
      <name name="sdp_a_rtpmap() = #megaco_sdp_a_rtpmap{}"/>
    </datatype>
    <datatype>
      <name name="sdp_b() = #megaco_sdp_b{}"/>
      <desc><p>Bandwidth information.</p></desc>
    </datatype>
    <datatype>
      <name name="sdp_c() = #megaco_sdp_c{}"/>
      <desc><p>Connection information.</p></desc>
    </datatype>
    <datatype>
      <name name="sdp_e() = #megaco_sdp_e{}"/>
      <desc><p>Email address.</p></desc>
    </datatype>
    <datatype>
      <name name="sdp_i() = #megaco_sdp_i{}"/>
      <desc><p>Session information.</p></desc>
    </datatype>
    <datatype>
      <name name="sdp_k() = #megaco_sdp_k{}"/>
      <desc><p>Encryption key.</p></desc>
    </datatype>
    <datatype>
      <name name="sdp_m() = #megaco_sdp_m{}"/>
      <desc><p>Media name and transport address.</p></desc>
    </datatype>
    <datatype>
      <name name="sdp_o() = #megaco_sdp_o{}"/>
      <desc><p>Owner/creator and session identifier.</p></desc>
    </datatype>
    <datatype>
      <name name="sdp_p() = #megaco_sdp_p{}"/>
      <desc><p>Phone number.</p></desc>
    </datatype>
    <datatype>
      <name name="sdp_property_group() = [sdp_property_parm()]"/>
    </datatype>
    <datatype>
      <name name="sdp_property_groups() = [sdp_property_group()]"/>
    </datatype>
    <datatype>
      <name name="sdp_property_parm() = sdp() | property_parm()"/>
    </datatype>
    <datatype>
      <name name="sdp_r() = #megaco_sdp_r{}"/>
      <desc><p>Repeat times.</p></desc>
    </datatype>
    <datatype>
      <name name="sdp_s() = #megaco_sdp_s{}"/>
      <desc><p>Session name.</p></desc>
    </datatype>
    <datatype>
      <name name="sdp_t() = #megaco_sdp_t{}"/>
      <desc><p>Time the session is active.</p></desc>
    </datatype>
    <datatype>
      <name name="sdp_u() = #megaco_sdp_u{}"/>
      <desc><p>URI of description.</p></desc>
    </datatype>
    <datatype>
      <name name="sdp_v() = #megaco_sdp_v{}"/>
      <desc><p>Protocol version.</p></desc>
    </datatype>
    <datatype>
      <name name="sdp_z() = #megaco_sdp_z{}"/>
      <desc><p>Time zone adjustment.</p></desc>
    </datatype>
    <datatype>
      <name name="segment_no() = integer()"/>
    </datatype>
    <datatype>
      <name name="transaction_reply() = #'TransactionReply'{}"/>
      <desc>
      <marker id="start"></marker>
      </desc>
    </datatype>
  </datatypes>

  <funcs>
    <func>
      <name>start() -> ok | {error, Reason}</name>
      <fsummary>Starts the Megaco application.</fsummary>
      <type>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Starts the Megaco application.</p>
        <p>Users can either explicitly be registered with
          <c>megaco:start_user/2</c> and/or be statically configured by
          setting the application environment variable <c>users</c> to a
          list of <c>{UserMid, Config}</c> tuples. For details, see
          <seealso marker="#start_user/2"><c>start_user/2</c></seealso>.
        </p>
        <marker id="stop"></marker>
      </desc>
    </func>

    <func>
      <name>stop() -> ok | {error, Reason}</name>
      <fsummary>Stops the Megaco application.</fsummary>
      <type>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Stops the Megaco application.</p>
        <marker id="start_user"></marker>
      </desc>
    </func>

    <func>
      <name>start_user(UserMid, Config) -> ok | {error, Reason}</name>
      <fsummary>Initial configuration of a user.</fsummary>
      <type>
        <v>UserMid = megaco_mid()</v>
        <v>Config = [{user_info_item(), user_info_value()}]</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Initial configuration of a user.</p>
        <p>Requires the Megaco application to be started. A user is
          either a Media Gateway (MG) or a Media Gateway Controller
          (MGC). One Erlang node can host many users.</p>
        <p>A user is identified by its <c>UserMid</c>, which must be a legal
          Megaco Message Identifier (MID).</p>
        <p><c>Config</c> is a list of <c>{Item, Value}</c> tuples.
          For information about which items and values that are valid, see
          <seealso marker="#user_info/2"><c>user_info/2</c></seealso>.
        </p>
        <marker id="stop_user"></marker>
      </desc>
    </func>

    <func>
      <name>stop_user(UserMid) -> ok | {error, Reason}</name>
      <fsummary>Delete the configuration of a user.</fsummary>
      <type>
        <v>UserMid = megaco_mid()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Deletes the configuration of a user.</p>
        <p>Requires that the user does not have any active connection.</p>
        <marker id="user_info"></marker>
      </desc>
    </func>

    <func>
      <name>user_info(UserMid) -> [{Item, Value}]</name>
      <name>user_info(UserMid, Item) -> Value | exit(Reason)</name>
      <fsummary>Lookup user information.</fsummary>
      <type>
        <v>Handle = user_info_handle()</v>
        <v>UserMid = megaco_mid()</v>
        <v>Item = user_info_item()</v>
        <v>Value = user_info_value()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Lookup user information.</p>
        <p>The following <c>Item</c>s are valid:</p>
        <marker id="ui_connections"></marker>
        <taglist>
          <tag><c><![CDATA[connections]]></c></tag>
          <item>
            <p>Lists all active connections for this user. Returns a
              list of <c>megaco_conn_handle</c> records.</p>
            <marker id="ui_receive_handle"></marker>
          </item>
          <tag><c><![CDATA[receive_handle]]></c></tag>
          <item>
            <p>Constructs a <c>megaco_receive_handle</c> record from user
              config.</p>
            <marker id="ui_trans_id"></marker>
          </item>
          <tag><c><![CDATA[trans_id]]></c></tag>
          <item>
            <p>Current transaction ID.</p>
            <p>A positive integer or the atom
              <c><![CDATA[undefined_serial]]></c>
              (if no messages have been sent).</p>
            <marker id="ui_min_trans_id"></marker>
          </item>
          <tag><c><![CDATA[min_trans_id]]></c></tag>
          <item>
            <p>First transaction ID.</p>
            <p>A positive integer. Defaults to 1.</p>
            <marker id="ui_max_trans_id"></marker>
          </item>
          <tag><c><![CDATA[max_trans_id]]></c></tag>
          <item>
            <p>Last transaction ID.</p>
            <p>A positive integer or <c><![CDATA[infinity]]></c>.
              Defaults to <c><![CDATA[infinity]]></c>.</p>
            <marker id="ui_request_timer"></marker>
          </item>
          <tag><c><![CDATA[request_timer]]></c></tag>
          <item>
            <p>Waits for reply.</p>
            <p>The timer is cancelled when a reply is received.</p>
            <p>When a pending message is received, the timer is
              cancelled and the <c><![CDATA[long_request_timer]]></c> is
              started instead
              (see below). No resends are performed from this point
              (as we now know that the other side has received the
              request).</p>
            <p>When the timer reaches an intermediate expire, the request
              is resent and the timer is restarted.</p>
            <p>When the timer reaches the final expire, either the
              <seealso marker="#call/3"><c>call//3</c></seealso> function
              returns with <c><![CDATA[{error, timeout}]]></c> or the
              <seealso marker="megaco_user#trans_reply">
              <c>megaco_user:handle_trans_reply/4,5</c></seealso>
              callback function is called with
              <c><![CDATA[UserReply = {error, timeout}]]></c> (if the
              <seealso marker="#cast/3"><c>cast//3</c></seealso> function
              was used).</p>
            <p>A <seealso marker="megaco_timer">Megaco timer</seealso>.
              Defaults to <c><![CDATA[#megaco_incr_timer{}]]></c>.</p>
            <marker id="ui_long_request_timer"></marker>
          </item>
          <tag><c><![CDATA[long_request_timer]]></c></tag>
          <item>
            <p>Waits for reply after having received a pending message.</p>
            <p>When the timer reaches an intermediate expire, the timer
              is restarted.</p>
            <p>When a pending message is received, and the
              <c><![CDATA[long_request_timer]]></c>
              is <em>not</em> "on its final leg", the timer is
              restarted, and if <c><![CDATA[long_request_resend = true]]></c>,
              the request is resent.</p>
            <p>A <seealso marker="megaco_timer">Megaco timer</seealso>.
              Defaults to <c><![CDATA[60 seconds]]></c>.</p>
            <marker id="ui_long_request_resend"></marker>
          </item>
          <tag><c><![CDATA[long_request_resend]]></c></tag>
          <item>
            <p>Specifies whether the request is to be
              resent until the reply is received,
              <em>even</em> though a pending message has been received.</p>
            <p>Normally, after a pending message has been received,
              the request is not resent
              (as a pending message is an indication that the
              request has been received). However, as the reply (to the
              request) can be lost, this behavior has its values.</p>
            <p>It is clearly pointless to set this value to <em>true</em>
              unless the <c><![CDATA[long_request_timer]]></c> (see above)
              is also set to an incremental timer
              (<c><![CDATA[#megaco_incr_timer{}]]></c>).</p>
            <p>A <c><![CDATA[boolean]]></c>
              defaults to <c><![CDATA[false]]></c>.</p>
            <marker id="ui_reply_timer"></marker>
          </item>
          <tag><c><![CDATA[reply_timer]]></c></tag>
          <item>
            <p>Waits for an acknowledgement.</p>
            <p>When a request is received, some information
              related to the reply is stored internally (for example, the
              binary of the reply). This information lives until either an
              acknowledgement is received or this timer expires. For example,
              if the same request is received again (for example, a request
              with the same transaction ID), the (stored) reply
              is (re)sent automatically by Megaco.</p>
            <p>If the timer is of type <c><![CDATA[#megaco_incr_timer{}]]></c>, 
              then for each intermediate time-out, the reply is resent
              (this is valid until the acknowledge is received or
              the timer expires).</p>
            <p>A <seealso marker="megaco_timer">Megaco timer</seealso>.
              Defaults to 30000.</p>
            <marker id="ui_request_keep_alive_timeout"></marker>
          </item>
          <tag><c><![CDATA[request_keep_alive_timeout]]></c></tag>
          <item>
            <p>Time-out time for the request-keep-alive timer.</p>
            <p>This timer is started when the <em>first</em> reply to an
              asynchronous request (issued using the
              <seealso marker="#cast"><c>cast/3</c></seealso>
              function) arrives. As long as this timer is running, replies
              are delivered through the
              <seealso marker="megaco_user#trans_reply">
              <c>megaco_user:handle_trans_reply/4,5</c></seealso>
              callback function, with their "arrival number"
              (see <c><![CDATA[UserReply]]></c> of the
              <seealso marker="megaco_user#trans_reply">
              <c>megaco_user:handle_trans_reply/4,5</c></seealso>
              callback function).</p>
            <p>Replies arriving after the timer has expired are delivered using
              the <seealso marker="megaco_user#unexpected_trans">
              <c>megaco_user:handle_unexpected_trans/3,4</c></seealso> 
              callback function.</p>
            <p>The time-out time can have the values:
              <c><![CDATA[plain | integer() >= 0]]></c>.</p>
            <p>Defaults to <c><![CDATA[plain]]></c>.</p>
            <marker id="ui_call_proxy_gc_timeout"></marker>
          </item>
          <tag><c><![CDATA[call_proxy_gc_timeout]]></c></tag>
          <item>
            <p>Time-out time for the call proxy.</p>
            <p>When a request is sent using the
              <seealso marker="#call"><c>call/3</c></seealso>
              function, a proxy process is started to handle
              all replies. When the reply has been received and delivered
              to the user, the proxy process continues to exist for as long
              as this option specifies. Any received messages are passed on
              to the user through the
              <seealso marker="megaco_user#handle_unexpected_trans">
              <c>megaco_user:handle_unexpected_trans</c></seealso>
              callback function.</p>
            <p>The time-out time is in milliseconds. A value of 0 (zero) means
              that the proxy process exits directly after the reply is
              delivered.</p>
            <p>An integer >= 0. Defaults to 5000 (= 5 seconds).</p>
            <marker id="ui_auto_ack"></marker>
          </item>
          <tag><c><![CDATA[auto_ack]]></c></tag>
          <item>
            <p>Automatically sends a transaction acknowledgement when the
              transaction reply has been received
              (see <c><![CDATA[trans_ack]]></c> below).</p>
            <p>This is used for <em>three-way-handshake</em>.</p>
            <p>A <c><![CDATA[boolean]]></c>.
              Defaults to <c><![CDATA[false]]></c>.</p>
            <marker id="ui_trans_ack"></marker>
          </item>
          <tag><c><![CDATA[trans_ack]]></c></tag>
          <item>
            <p>Specifies whether acknowledgements are to be accumulated or
              not.</p>
            <p>This property is only valid if <c><![CDATA[auto_ack]]></c>
              is <c>true</c>.</p>
            <p>If <c><![CDATA[auto_ack]]></c> is <c>true</c> and
              <c><![CDATA[trans_ack]]></c> is <c><![CDATA[false]]></c>,
              acknowledgements are sent immediately.</p>
            <p>If <c><![CDATA[trans_ack]]></c> is <c><![CDATA[true]]></c>,
              acknowledgements are instead sent to the transaction
              sender process for accumulation and later sending (see
              <c><![CDATA[trans_ack_maxcount]]></c>,
              <c><![CDATA[trans_req_maxcount]]></c>,
              <c><![CDATA[trans_req_maxsize]]></c>,
              <c><![CDATA[trans_ack_maxcount]]></c>, and
              <c><![CDATA[trans_timer]]></c>).</p>
            <p>For more information, see
              <seealso marker="megaco_run#transaction_sender">
              <c>megaco_run:transaction sender</c></seealso>.</p>
            <p>A <c><![CDATA[boolean]]></c>.
              Defaults to <c><![CDATA[false]]></c>.</p>
            <marker id="ui_trans_ack_maxcount"></marker>
          </item>
          <tag><c><![CDATA[trans_ack_maxcount]]></c></tag>
          <item>
            <p>Maximum number of accumulated acknowledgements. At most this
              many acknowledgements
              are accumulated by the transaction sender (if started and
              configured to accumulate ackknowledgements).</p>
            <p>For more information, see
              <seealso marker="megaco_run#transaction_sender">
              <c>megaco_run:transaction sender</c></seealso>.</p>
            <p>An <c><![CDATA[integer]]></c>. Defaults to 10.</p>
            <marker id="ui_trans_req"></marker>
          </item>
          <tag><c><![CDATA[trans_req]]></c></tag>
          <item>
            <p>Specifies whether requests are to be accumulated or not.</p>
            <p>If <c><![CDATA[trans_req]]></c> is <c><![CDATA[false]]></c>,
              request(s) are sent immediately (in its own message).</p>
            <p>If <c><![CDATA[trans_req]]></c> is <c>true</c>, request(s)
              are instead sent to the transaction sender process for
              accumulation and later sending (see
              <c><![CDATA[trans_ack_maxcount]]></c>,
              <c><![CDATA[trans_req_maxcount]]></c>,
              <c><![CDATA[trans_req_maxsize]]></c>,
              <c><![CDATA[trans_ack_maxcount]]></c>, and
              <c><![CDATA[trans_timer]]></c>).</p>
            <p>For more information, see
              <seealso marker="megaco_run#transaction_sender">
              <c>megaco_run:transaction sender</c></seealso>.</p>
            <p>A <c><![CDATA[boolean]]></c>.
              Defaults to <c><![CDATA[false]]></c>.</p>
            <marker id="ui_trans_req_maxcount"></marker>
          </item>
          <tag><c><![CDATA[trans_req_maxcount]]></c></tag>
          <item>
            <p>Maximum number of accumulated requests. At most this many
              requests are accumulated by the transaction sender
              (if started and configured to accumulate requests).</p>
            <p>For more information, see
              <seealso marker="megaco_run#transaction_sender">
              <c>megaco_run:transaction sender</c></seealso>.</p>
            <p>An <c><![CDATA[integer]]></c>. Defaults to 10.</p>
            <marker id="ui_trans_req_maxsize"></marker>
          </item>
          <tag><c><![CDATA[trans_req_maxsize]]></c></tag>
          <item>
            <p>Maximum size of the accumulated requests. At most this many
              requests are accumulated by the transaction sender
              (if started and configured to accumulate requests).</p>
            <p>For more information, see
              <seealso marker="megaco_run#transaction_sender">
              <c>megaco_run:transaction sender</c></seealso>.</p>
            <p>An <c><![CDATA[integer]]></c>. Defaults to 2048.</p>
            <marker id="ui_trans_timer"></marker>
          </item>
          <tag><c><![CDATA[trans_timer]]></c></tag>
          <item>
            <p>Transaction sender time-out time. Has two functions:</p>
            <list type="bulleted">
              <item>
                <p>If the value is 0, transactions are not accumulated (for
                  example, the transaction sender process is not started).</p>
              </item>
              <item>
                <p>If the value is &gt; 0 and <c><![CDATA[auto_ack]]></c>
                  and <c><![CDATA[trans_ack]]></c> both are <c>true</c>, or
                  if <c><![CDATA[trans_req]]></c> is <c>true</c>,
                  then the transaction sender is started and transactions
                  (which depend on the values of <c><![CDATA[auto_ack]]></c>,
                  <c><![CDATA[trans_ack]]></c>, and
                  <c><![CDATA[trans_req]]></c>) are accumulated
                  for later sending.</p>
              </item>
            </list>
            <p>For more information, see
              <seealso marker="megaco_run#transaction_sender">
              <c>megaco_run:transaction sender</c></seealso>.</p>
            <p>An <c><![CDATA[integer]]></c>. Defaults to 0.</p>
            <marker id="ui_pending_timer"></marker>
          </item>
          <tag><c><![CDATA[pending_timer]]></c></tag>
          <item>
            <p>Automatically sends pending if the timer expires before a
              transaction reply has been sent. This timer is also called
              provisional response timer.</p>
            <p>A <seealso marker="megaco_timer">Megaco timer</seealso>.
              Defaults to 30000.</p>
            <marker id="ui_sent_pending_limit"></marker>
          </item>
          <tag><c><![CDATA[sent_pending_limit]]></c></tag>
          <item>
            <p>Sent pending limit (see <c>MGOriginatedPendingLimit</c>
              and <c>MGCOriginatedPendingLimit</c> of the Megaco root package).
              This parameter specifies how many pending messages that can
              be sent (for a given received transaction request).
              When the limit is exceeded, the transaction is aborted (see
              <seealso marker="megaco_user#request_abort">
              <c>megaco_user:handle_trans_request_abort</c></seealso>)
              and an error message is sent to the other side.</p>
            <p>Notice that this has no effect on the actual sending of
              pending transactions. This is either implicit (for example, when
              receiving a resent transaction request for a request that
              is being processed) or controlled by the <c>pending_timer</c>,
              see above.</p>
            <p>A positive integer or <c><![CDATA[infinity]]></c>.
              Defaults to <c><![CDATA[infinity]]></c>.</p>
            <marker id="ui_recv_pending_limit"></marker>
          </item>
          <tag><c><![CDATA[recv_pending_limit]]></c></tag>
          <item>
            <p>Receive pending limit (see <c>MGOriginatedPendingLimit</c>
              and <c>MGCOriginatedPendingLimit</c> of the Megaco root package).
              This parameter specifies how many pending messages that can
              be received (for a sent transaction request).
              When the limit is exceeded, the transaction is considered
              lost, and an error is returned to the user (through the
              <seealso marker="megaco_user#trans_reply">
              <c>megaco_user:handle_trans_reply/4,5</c></seealso>
              callback function.</p>
            <p>A positive integer or <c><![CDATA[infinity]]></c>.
              Defaults to <c><![CDATA[infinity]]></c>.</p>
            <marker id="ui_send_mod"></marker>
          </item>
          <tag><c><![CDATA[send_mod]]></c></tag>
          <item>
            <p>Sends a callback module that exports <c>send_message/2</c>. The
              function <c>SendMod:send_message(SendHandle, Binary)</c> is
              invoked when the bytes needs to be transmitted to the
              remote user.</p>
            <p>An <c><![CDATA[atom]]></c>.
              Defaults to <c><![CDATA[megaco_tcp]]></c>.</p>
            <marker id="ui_encoding_mod"></marker>
          </item>
          <tag><c><![CDATA[encoding_mod]]></c></tag>
          <item>
            <p>Encoding callback module that exports <c>encode_message/2</c>
              and <c>decode_message/2</c>. The function
              <c>EncodingMod:encode_message(EncodingConfig, MegacoMessage)</c>
              is invoked whenever a <c>MegacoMessage</c>
              record needs to be translated into an Erlang binary. The function
              <c>EncodingMod:decode_message(EncodingConfig, Binary)</c> is
              invoked whenever an Erlang binary needs to be
              translated into a <c>MegacoMessage</c> record.</p>
            <p>An <c><![CDATA[atom]]></c>.
              Defaults to <c><![CDATA[megaco_pretty_text_encoder]]></c>.</p>
            <marker id="ui_encoding_config"></marker>
          </item>
          <tag><c><![CDATA[encoding_config]]></c></tag>
          <item>
            <p>Encoding module config.</p>
            <p>A <c><![CDATA[list]]></c>. Defaults to <c><![CDATA[[]]]></c>.</p>
            <marker id="ui_protocol_version"></marker>
          </item>
          <tag><c><![CDATA[protocol_version]]></c></tag>
          <item>
            <p>Actual protocol version.</p>
            <p>An <c><![CDATA[integer]]></c>. Defaults to 1.</p>
            <marker id="ui_strict_version"></marker>
          </item>
          <tag><c><![CDATA[strict_version]]></c></tag>
          <item>
            <p>Strict version control, that is, when a message is received,
              verify that the version is the one that was negotiated.</p>
            <p>A <c><![CDATA[boolean]]></c>. Defaults to <c>true</c>.</p>
            <marker id="ui_reply_data"></marker>
          </item>
          <tag><c><![CDATA[reply_data]]></c></tag>
          <item>
            <p>Default reply data.</p>
            <p>Any term. Defaults to the atom <c><![CDATA[undefined]]></c>.</p>
            <marker id="ui_user_mod"></marker>
          </item>
          <tag><c><![CDATA[user_mod]]></c></tag>
          <item>
            <p>Name of the user callback module. For more information, see the
              <seealso marker="megaco_user"><c>megaco_user</c></seealso>
              module.</p>
            <marker id="ui_user_args"></marker>
          </item>
          <tag><c><![CDATA[user_args]]></c></tag>
          <item>
            <p>Lists extra arguments to the user callback functions.
              For more information, see the
              <seealso marker="megaco_user"><c>megaco_user</c></seealso>
              module.</p>
            <marker id="ui_threaded"></marker>
          </item>
          <tag><c><![CDATA[threaded]]></c></tag>
          <item>
            <p>If a received message contains several transaction requests,
              this option specifies whether the requests are to be handled
              sequentially in the same process (<c><![CDATA[false]]></c>),
              or if each request is to be handled by its own process
              (<c><![CDATA[true]]></c>, that is,
              a separate process is spawned for each request).</p>
            <p>A <c><![CDATA[boolean]]></c>.
              Defaults to <c><![CDATA[false]]></c>.</p>
            <marker id="ui_resend_indication"></marker>
          </item>
          <tag><c><![CDATA[resend_indication]]></c></tag>
          <item>
            <p>Specifies weather the transport module
              is to be told if a message send is a resend or not.</p>
            <p>If <c>false</c>, Megaco messages are sent using the
              <seealso marker="megaco_transport#send_message">
              <c>megaco_transport:send_message</c></seealso> function.</p>
            <p>If <c>true</c>, Megaco message <c>resends</c> is made using
              the <seealso marker="megaco_transport#resend_message">
              <c>megaco_transport:resend_message</c></seealso>
              function. The initial message send is still done using the
              <seealso marker="megaco_transport#send_message">
              <c>megaco_transport:send_message</c></seealso> function.</p>
            <p>The special value <c>flag</c> instead means that the
              function <seealso marker="megaco_transport#send_message">
              <c>megaco_transport:send_message/3</c></seealso> is to be
              used.</p>
            <p>A <c>resend_indication()</c>.
              Defaults to <c><![CDATA[false]]></c>.</p>
            <marker id="ui_segment_reply_ind"></marker>
          </item>
          <tag><c><![CDATA[segment_reply_ind]]></c></tag>
          <item>
            <p>Specifies whether the user is to be notified of received
              segment replies or not.</p>
            <p>For more information, see the
              <seealso marker="megaco_user#segment_reply">
              <c>megaco_user:handle_segment_reply</c></seealso> 
              callback function.</p>
            <p>A <c><![CDATA[boolean]]></c>.
              Defaults to <c><![CDATA[false]]></c>.</p>
            <marker id="ui_segment_recv_timer"></marker>
          </item>
          <tag><c><![CDATA[segment_recv_timer]]></c></tag>
          <item>
            <p>This timer is started when the segment indicated by the
              <c><![CDATA[segmentation complete token]]></c> is received,
              but all segments have not yet been received.</p>
            <p>When the timer finally expires, a <c>megaco segments not
              received</c> (459) error message is sent to the other side
              and the user is notified with a
              <c><![CDATA[segment timeout]]></c>
              <c><![CDATA[UserReply]]></c> in either the
              <seealso marker="megaco_user#trans_reply">
              <c>megaco_user:handle_trans_reply</c></seealso> callback
              function or the return value of the
              <seealso marker="#call"><c>call/3</c></seealso>
              function.</p>
            <p>A <seealso marker="megaco_timer">Megaco timer</seealso>.
              Defaults to <c><![CDATA[10000]]></c>.</p>
            <marker id="ui_segment_send"></marker>
          </item>
          <tag><c><![CDATA[segment_send]]></c></tag>
          <item>
            <p>Specifies whether outgoing messages are to be segmented or
              not:</p>
            <taglist>
              <tag><c><![CDATA[none]]></c></tag>
              <item>
                <p>Do not segment outgoing reply messages. This is useful when
                  either it is known that messages are never to large or
                  that the transport protocol can handle such things
                  on its own (for example, TCP or SCTP).</p>
              </item>
              <tag><c><![CDATA[integer() > 0]]></c></tag>
              <item>
                <p>Outgoing reply messages are segmented as needed
                  (see <c><![CDATA[max_pdu_size]]></c> below).
                  This value, K, specifies
                  the outstanding window, that is, how many segments can be
                  outstanding (not acknowledged) at any given time.</p>
              </item>
              <tag><c><![CDATA[infinity]]></c></tag>
              <item>
                <p>Outgoing reply messages are segmented as needed
                  (see <c><![CDATA[max_pdu_size]]></c> below). Segment messages
                  are sent all at once (that is, no acknowledgement
                  before sending the next segment).</p>
              </item>
            </taglist>
            <p>Defaults to <c><![CDATA[none]]></c>.</p>
            <marker id="ui_max_pdu_size"></marker>
          </item>
          <tag><c><![CDATA[max_pdu_size]]></c></tag>
          <item>
            <p>Maximum message size. If the encoded message (PDU) exceeds
              this size, the message is to be segmented, and then
              encoded.</p>
            <p>A positive integer or <c><![CDATA[infinity]]></c>.
              Defaults to <c><![CDATA[infinity]]></c>.</p>
          </item>
        </taglist>
        <marker id="update_user_info"></marker>
      </desc>
    </func>

    <func>
      <name>update_user_info(UserMid, Item, Value)
        -> ok | {error, Reason}</name>
      <fsummary>Update information about a user.</fsummary>
      <type>
        <v>UserMid = megaco_mid() </v>
        <v>Item = user_info_item()</v>
        <v>Value = user_info_value()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Updates information about a user.</p>
        <p>Requires that the user is started. See
          <seealso marker="#user_info/2"><c>user_info/2</c></seealso>
          about which items and values that are valid.</p>
        <marker id="conn_info"></marker>
      </desc>
    </func>

    <func>
      <name>conn_info(ConnHandle) -> [{Item, Value}]</name>
      <name>conn_info(ConnHandle, Item) -> Value | exit(Reason)</name>
      <fsummary>Lookup information about an active connection.</fsummary>
      <type>
        <v>ConnHandle = #megaco_conn_handle{}</v>
        <v>Item = conn_info_item()</v>
        <v>Value = conn_info_value()</v>
        <v>Reason = {no_such_connection, ConnHandle} | term()</v>
      </type>
      <desc>
        <p>Lookup information about an active connection.</p>
        <p>Requires that the connection is active.</p>
        <marker id="ci_control_pid"></marker>
        <p>The following <c>Item</c>s are valid:</p>
        <taglist>
          <tag><c><![CDATA[control_pid]]></c></tag>
          <item>
            <p>The process identifier of the controlling process for a
              connection.</p>
            <marker id="ci_send_handle"></marker>
          </item>
          <tag><c><![CDATA[send_handle]]></c></tag>
          <item>
            <p>Opaque send handle whose contents is internal for the
              send module. Can be any term.</p>
            <marker id="ci_local_mid"></marker>
          </item>
          <tag><c><![CDATA[local_mid]]></c></tag>
          <item>
            <p>The local MID (of the connection, that is, the own MID).
              <c><![CDATA[megaco_mid()]]></c>.</p>
            <marker id="ci_remote_mid"></marker>
          </item>
          <tag><c><![CDATA[remote_mid]]></c></tag>
          <item>
            <p>The remote MID (of the connection).
              <c><![CDATA[megaco_mid()]]></c>.</p>
            <marker id="ci_receive_handle"></marker>
          </item>
          <tag><c><![CDATA[receive_handle]]></c></tag>
          <item>
            <p>Constructs a <c>megaco_receive_handle</c> record.</p>
            <marker id="ci_trans_id"></marker>
          </item>
          <tag><c><![CDATA[trans_id]]></c></tag>
          <item>
            <p>Next transaction ID. A positive integer or the atom
              <c><![CDATA[undefined_serial]]></c> (only in case of error).</p>
            <p>Notice that transaction IDs are (currently) maintained
              on a per user basis, so there is no way to be sure that
              the returned value will be used for a transaction
              sent on this connection (if a user has several
              connections, which is not unlikely).</p>
            <marker id="ci_max_trans_id"></marker>
          </item>
          <tag><c><![CDATA[max_trans_id]]></c></tag>
          <item>
            <p>Last transaction ID.</p>
            <p>A positive integer or <c><![CDATA[infinity]]></c>.
              Defaults to <c><![CDATA[infinity]]></c>.</p>
            <marker id="ci_request_time"></marker>
          </item>
          <tag><c><![CDATA[request_timer]]></c></tag>
          <item>
            <p>Waits for reply.</p>
            <p>The timer is cancelled when a reply is received.</p>
            <p>When a pending message is received, the timer is cancelled
              and the <c><![CDATA[long_request_timer]]></c> is started instead
              (see below). No resends are performed from this point
              (as we now know that the other side has received the
              request).</p>
            <p>When the timer reaches an intermediate expire, the request
              is resent and the timer is restarted.</p>
            <p>When the timer reaches the final expire, either the
              <seealso marker="#call/3"><c>call/3</c></seealso>
              function returns with
              <c><![CDATA[{error, timeout}]]></c> or the
              <seealso marker="megaco_user#trans_reply">
              <c>megaco_user:handle_trans_reply/4,5</c></seealso>
              callback function is
              called with <c><![CDATA[UserReply = {error, timeout}]]></c> (if
              the <seealso marker="#cast/3"><c>cast/3</c></seealso>
              function was used).</p>
            <p>A <seealso marker="megaco_timer">Megaco timer</seealso>.
              Defaults to <c>#megaco_incr_timer{}</c>.</p>
            <marker id="ci_long_request_timer"></marker>
          </item>
          <tag><c><![CDATA[long_request_timer]]></c></tag>
          <item>
            <p>Waits for reply after having received a pending message.</p>
            <p>When the timer reaches an intermediate expire, the timer is
              restarted.</p>
            <p>When a pending message is received, and the
              <c><![CDATA[long_request_timer]]></c>
              is <em>not</em> "on its final leg", the timer is
              restarted and, if <c><![CDATA[long_request_resend = true]]></c>,
              the request is resent.</p>
            <p>A <seealso marker="megaco_timer">Megaco timer</seealso>.
              Defaults to <c><![CDATA[60 seconds]]></c>.</p>
            <marker id="ci_request_keep_alive_timeout"></marker>
          </item>
          <tag><c><![CDATA[request_keep_alive_timeout]]></c></tag>
          <item>
            <p>Specifies the time-out time for the request-keep-alive timer.</p>
            <p>This timer is started when the <em>first</em> reply to an
              asynchronous request (issued using the
              <seealso marker="#cast"><c>cast/3</c></seealso> function)
              arrives. As long as this timer is running, replies are
              delivered through the
              <seealso marker="megaco_user#trans_reply">
              <c>megaco_user:handle_trans_reply/4,5</c></seealso>
              callback function, with their "arrival number"
              (see <c><![CDATA[UserReply]]></c> of the
              <seealso marker="megaco_user#trans_reply">
              <c>megaco_user:handle_trans_reply/4,5</c></seealso>
              callback function).</p>
            <p>Replies arriving after the timer has expired are
              delivered using the
              <seealso marker="megaco_user#unexpected_trans">
              <c>megaco_user:handle_unexpected_trans/3,4</c></seealso>
              callback function.</p>
            <p>The time-out time can have the values
              <c><![CDATA[plain | integer() >= 0]]></c>.</p>
            <p>Defaults to <c><![CDATA[plain]]></c>.</p>
            <marker id="ci_long_request_resend"></marker>
          </item>
          <tag><c><![CDATA[long_request_resend]]></c></tag>
          <item>
            <p>Specifies whether the request is to be
              resent until the reply is received
              <em>even</em> though a pending message has been received.</p>
            <p>Normally, after a pending message has been received,
              the request is not resent
              (as a pending message is an indication that the
              request has been received). However, as the reply (to the
              request) can be lost, this behavior has its values.</p>
            <p>It is clearly pointless to set this value to <c>true</c>
              unless <c><![CDATA[long_request_timer]]></c> (see above)
              is also set to an incremental timer
              (<c><![CDATA[#megaco_incr_timer{}]]></c>).</p>
            <p>A <c><![CDATA[boolean]]></c>.
              Defaults to <c><![CDATA[false]]></c>.</p>
            <marker id="ci_reply_timer"></marker>
          </item>
          <tag><c><![CDATA[reply_timer]]></c></tag>
          <item>
            <p>Waits for an acknowledgement.</p>
            <p>When a request is received, some information
              related to the reply is stored internally (for example, the
              binary of the reply). This information lives until either an
              acknowledgement is received or this timer expires. For example,
              if the same request is received again (for example, a request
              with the same transaction ID), the (stored) reply is
              (re)sent automatically by Megaco.</p>
            <p>If the timer is of type <c><![CDATA[#megaco_incr_timer{}]]></c>,
              then for each intermediate time-out, the reply is resent
              (this is valid until the acknowledgement is received or
              the timer expires).</p>
            <p>A <seealso marker="megaco_timer">Megaco timer</seealso>.
              Defaults to 30000.</p>
            <marker id="ci_call_proxy_gc_timeout"></marker>
          </item>
          <tag><c><![CDATA[call_proxy_gc_timeout]]></c></tag>
          <item>
            <p>Time-out time for the call proxy.</p>
            <p>When a request is sent using the
              <seealso marker="#call"><c>call/3</c></seealso> function,
              a proxy process is started to handle
              all replies. When the reply has been received and delivered
              to the user, the proxy process continues to exist for as long
              as this option specifies. Any received messages are passed on
              to the user through the
              <seealso marker="megaco_user#handle_unexpected_trans">
              <c>megaco_user:handle_unexpected_trans</c></seealso>
              callback function.</p>
            <p>The time-out time is in milliseconds. A value of 0 (zero) means
              that the proxy process exits directly after the reply is
              delivered.</p>
            <p>An integer >= 0. Defaults to 5000 (= 5 seconds).</p>
            <marker id="ci_auto_ack"></marker>
          </item>
          <tag><c><![CDATA[auto_ack]]></c></tag>
          <item>
            <p>Automatic sends transaction acknowledgement when the transaction
              reply has been received (see <c><![CDATA[trans_ack]]></c> below).
            </p>
            <p>This is used for <em>three-way-handshake</em>.</p>
            <p>A <c><![CDATA[boolean]]></c>.
              Defaults to <c><![CDATA[false]]></c>.</p>
            <marker id="ci_trans_ack"></marker>
          </item>
          <tag><c><![CDATA[trans_ack]]></c></tag>
          <item>
            <p>Specifies whether acknowledgements are to be accumulated or
              not.</p>
            <p>This property is only valid if <c><![CDATA[auto_ack]]></c> is
              <c>true</c>.</p>
            <p>If <c><![CDATA[auto_ack]]></c> is <c>true</c> and if
              <c><![CDATA[trans_ack]]></c> is <c><![CDATA[false]]></c>,
              acknowledgements are sent immediately.
              If <c><![CDATA[trans_ack]]></c> is
              <c><![CDATA[true]]></c>, then acknowledgements are instead sent
              to the transaction
              sender process for accumulation and later sending (see
              <c><![CDATA[trans_ack_maxcount]]></c>,
              <c><![CDATA[trans_req_maxcount]]></c>,
              <c><![CDATA[trans_req_maxsize]]></c>,
              <c><![CDATA[trans_ack_maxcount]]></c>, and
              <c><![CDATA[trans_timer]]></c>).</p>
            <p>For more information, see
              <seealso marker="megaco_run#transaction_sender">
              <c>megaco_run:transaction sender</c></seealso>.</p>
            <p>A <c><![CDATA[boolean]]></c>.
              Defaults to <c><![CDATA[false]]></c>.</p>
            <marker id="ci_trans_ack_maxcount"></marker>
          </item>
          <tag><c><![CDATA[trans_ack_maxcount]]></c></tag>
          <item>
            <p>Maximum number of accumulated acknowledgements. At most this
              many acknowledgements
              are accumulated by the transaction sender (if started and
              configured to accumulate acknowledgements).</p>
            <p>For more information, see
              <seealso marker="megaco_run#transaction_sender">
              <c>megaco_run:transaction sender</c></seealso>.</p>
            <p>An integer. Defaults to 10.</p>
            <marker id="ci_trans_req"></marker>
          </item>
          <tag><c><![CDATA[trans_req]]></c></tag>
          <item>
            <p>Specifies whether requests are to be accumulated or not.</p>
            <p>If <c><![CDATA[trans_req]]></c> is <c><![CDATA[false]]></c>,
              request(s) are sent immediately (in its own message).</p>
            <p>If <c><![CDATA[trans_req]]></c> is <c>true</c>, request(s) are
              instead sent to the transaction sender process for
              accumulation and later sending (see
              <c><![CDATA[trans_ack_maxcount]]></c>,
              <c><![CDATA[trans_req_maxcount]]></c>,
              <c><![CDATA[trans_req_maxsize]]></c>,
              <c><![CDATA[trans_ack_maxcount]]></c>, and
              <c><![CDATA[trans_timer]]></c>).</p>
            <p>For more information, see
              <seealso marker="megaco_run#transaction_sender">
              <c>megaco_run:transaction sender</c></seealso>.</p>
            <p>A <c><![CDATA[boolean]]></c>.
              Defaults to <c><![CDATA[false]]></c>.</p>
            <marker id="ci_trans_req_maxcount"></marker>
          </item>
          <tag><c><![CDATA[trans_req_maxcount]]></c></tag>
          <item>
            <p>Maximum number of accumulated requests. At most this many
              requests are accumulated by the transaction sender
              (if started and configured to accumulate requests).</p>
            <p>For more information, see
              <seealso marker="megaco_run#transaction_sender">
              <c>megaco_run:transaction sender</c></seealso>.</p>
            <p>An <c><![CDATA[integer]]></c>. Defaults to 10.</p>
            <marker id="ci_trans_req_maxsize"></marker>
          </item>
          <tag><c><![CDATA[trans_req_maxsize]]></c></tag>
          <item>
            <p>Maximum size of the accumulated requests. At most this many
              requests are accumulated by the transaction sender
              (if started and configured to accumulate requests).</p>
            <p>For more information, see
              <seealso marker="megaco_run#transaction_sender">
              <c>megaco_run:transaction sender</c></seealso>.</p>
            <p>An <c><![CDATA[integer]]></c>. Defaults to 2048.</p>
            <marker id="ci_trans_timer"></marker>
          </item>
          <tag><c><![CDATA[trans_timer]]></c></tag>
          <item>
            <p>Transaction sender time-out time. Has two functions:</p>
            <list type="bulleted">
              <item>
                <p>If the value is 0, transactions are not accumulated (for
                  example, the transaction sender process is not started).</p>
              </item>
              <item> 
                <p>If the value is &gt; 0 and <c><![CDATA[auto_ack]]></c>
                  and <c><![CDATA[trans_ack]]></c> are <c>true</c> or if
                  <c><![CDATA[trans_req]]></c> is <c>true</c>,
                  then the transaction sender is started and transactions
                  (which depend on the values of <c><![CDATA[auto_ack]]></c>,
                  <c><![CDATA[trans_ack]]></c>, and
                  <c><![CDATA[trans_req]]></c>) are accumulated
                  for later sending.</p>
              </item>
            </list>
            <p>For more information, see
              <seealso marker="megaco_run#transaction_sender">
              <c>megaco_run:transaction sender</c></seealso>.</p>
            <p>An <c><![CDATA[integer]]></c>. Defaults to 0.</p>
            <marker id="ci_pending_timer"></marker>
          </item>
          <tag><c><![CDATA[pending_timer]]></c></tag>
          <item>
            <p>Automatic sends transaction pending if the timer expires
              before a transaction reply has been sent. This timer is
              also called provisional response timer.</p>
            <p>A <seealso marker="megaco_timer">Megaco timer</seealso>.
              Defaults to 30000.</p>
            <marker id="ci_sent_pending_limit"></marker>
          </item>
          <tag><c><![CDATA[sent_pending_limit]]></c></tag>
          <item>
            <p>Sent pending limit (see <c>MGOriginatedPendingLimit</c>
              and <c>MGCOriginatedPendingLimit</c> of the Megaco root package).
              This parameter specifies how many pending messages that can
              be sent (for a given received transaction request).
              When the limit is exceeded, the transaction is aborted
              (see <seealso marker="megaco_user#request_abort">
              <c>megaco_user:handle_trans_request_abort</c></seealso>)
              and an error message is sent to the other side.</p>
            <p>Notice that this has no effect on the actual sending of
              pending transactions. This is either implicit (for example, when
              receiving a resent transaction request for a request that
              is being processed) or controlled by the <c>pending_timer</c>,
              see above.</p>
            <p>A positive integer or <c><![CDATA[infinity]]></c>.
              Defaults to <c><![CDATA[infinity]]></c>.</p>
            <marker id="ci_recv_pending_limit"></marker>
          </item>
          <tag><c><![CDATA[recv_pending_limit]]></c></tag>
          <item>
            <p>Receive pending limit (see <c>MGOriginatedPendingLimit</c>
              and <c>MGCOriginatedPendingLimit</c> of the Megaco root package).
              This parameter specifies how many pending messages that can
              be received (for a sent transaction request).
              When the limit is exceeded, the transaction is considered
              lost, and an error is returned to the user (through the
              <seealso marker="megaco_user#trans_reply">
              <c>megaco_user:handle_trans_reply/4,5</c></seealso>
              callback function.</p>
            <p>A positive integer or <c><![CDATA[infinity]]></c>.
              Defaults to <c><![CDATA[infinity]]></c>.</p>
            <marker id="ci_send_mod"></marker>
          </item>
          <tag><c><![CDATA[send_mod]]></c></tag>
          <item>
            <p>Sends callback module that exports <c>send_message/2</c>.
              The <c>SendMod:send_message(SendHandle, Binary)</c> function is
              invoked when the bytes needs to be transmitted to
              the remote user.</p>
            <p>An <c><![CDATA[atom]]></c>.
              Defaults to <c><![CDATA[megaco_tcp]]></c>.</p>
            <marker id="ci_encoding_mod"></marker>
          </item>
          <tag><c><![CDATA[encoding_mod]]></c></tag>
          <item>
            <p>Encoding callback module that exports <c>encode_message/2</c>
              and <c>decode_message/2</c>. The
              <c>EncodingMod:encode_message(EncodingConfig, MegacoMessage)</c>
              function is invoked whenever a <c>MegacoMessage</c> record needs
              to be translated into an Erlang binary. The
              <c>EncodingMod:decode_message(EncodingConfig, Binary)</c>
              function is invoked whenever an Erlang binary needs to be
              translated into a <c>MegacoMessage</c> record.</p>
            <p>An <c><![CDATA[atom]]></c>.
              Defaults to <c><![CDATA[megaco_pretty_text_encoder]]></c>.</p>
            <marker id="ci_encoding_confi"></marker>
          </item>
          <tag><c><![CDATA[encoding_config]]></c></tag>
          <item>
            <p>Encoding module config.</p>
            <p>A <c><![CDATA[list]]></c>. Defaults to <c>[]</c>.</p>
            <marker id="ci_protocol_version"></marker>
          </item>
          <tag><c><![CDATA[protocol_version]]></c></tag>
          <item>
            <p>Actual protocol version.</p>
            <p>A positive integer. Defaults to 1.</p>
            <marker id="ci_strict_version"></marker>
          </item>
          <tag><c><![CDATA[strict_version]]></c></tag>
          <item>
            <p>Strict version control, that is, when a message is received,
              verify that the version is the one that was negotiated.</p>
            <p>A <c><![CDATA[boolean]]></c>. Defaults to <c>true</c>.</p>
            <marker id="ci_reply_data"></marker>
          </item>
          <tag><c><![CDATA[reply_data]]></c></tag>
          <item>
            <p>Default reply data.</p>
            <p>Any term. Defaults to the atom <c><![CDATA[undefined]]></c>.</p>
            <marker id="ci_threaded"></marker>
          </item>
          <tag><c><![CDATA[threaded]]></c></tag>
          <item>
            <p>If a received message contains several transaction requests,
              this option specifies whether the requests are to be handled
              sequentially in the same process (<c><![CDATA[false]]></c>),
              or if each request is to be handled by its own process
              (<c><![CDATA[true]]></c>,
              that is, a separate process is spawned for each request).</p>
            <p>A <c><![CDATA[boolean]]></c>.
              Defaults to <c><![CDATA[false]]></c>.</p>
            <marker id="ci_resend_indication"></marker>
          </item>
          <tag><c><![CDATA[resend_indication]]></c></tag>
          <item>
            <p>Specifies whether the transport module is to
              be told if a message send is a resend or not.</p>
            <p>If <c>false</c>, Megaco messages are sent using the
              <seealso marker="megaco_transport#send_message">
              <c>megaco_transport:send_message/2</c></seealso> function.</p>
            <p>If <em>true</em>, Megaco message <c>re-sends</c> is made
              using the <seealso marker="megaco_transport#resend_message">
              <c>megaco_transport:resend_message</c></seealso>
              function. The initial message send is still done using the
              <seealso marker="megaco_transport#send_message">
              <c>megaco_transport:send_message</c></seealso> function.</p>
            <p>The special value <c>flag</c> instead specifies that the
              function <seealso marker="megaco_transport#send_message">
              <c>megaco_transport:send_message/3</c></seealso>
              is to be used.</p>
            <p>A <c>resend_indication()</c>.
              Defaults to <c><![CDATA[false]]></c>.</p>
            <marker id="ci_segment_reply_ind"></marker>
          </item>
          <tag><c><![CDATA[segment_reply_ind]]></c></tag>
          <item>
            <p>Specifies whether the user is to be notified of received
              segment replies or not.</p>
            <p>For more information, see the
              <seealso marker="megaco_user#segment_reply">
              <c>megaco_user:handle_segment_reply</c></seealso>
              callback function.</p>
            <p>A <c><![CDATA[boolean]]></c>.
              Defaults to <c><![CDATA[false]]></c>.</p>
            <marker id="ci_segment_recv_timer"></marker>
          </item>
          <tag><c><![CDATA[segment_recv_timer]]></c></tag>
          <item>
            <p>This timer is started when the segment indicated by the
              <c><![CDATA[segmentation complete token]]></c> (for example, the
              last segment that makes up the reply) is received, but all
              segments have not yet been received.</p>
            <p>When the timer finally expires, a <c>megaco segments not
              received</c> (459) error message is sent to the other side
              and the user is notified with a
              <c><![CDATA[segment timeout]]></c> <c><![CDATA[UserReply]]></c>
              in either the <seealso marker="megaco_user#trans_reply">
              <c>megaco_user:handle_trans_reply</c></seealso>
              callback function or the return value of the
              <seealso marker="#call"><c>call/3</c></seealso>
              function.</p>
            <p>A <seealso marker="megaco_timer">Megaco timer</seealso>.
              Defaults to <c><![CDATA[10000]]></c>.</p>
            <marker id="ci_segment_send"></marker>
          </item>
          <tag><c><![CDATA[segment_send]]></c></tag>
          <item>
            <p>Specifies whether outgoing messages are to be segmented or
              not:</p>
            <taglist>
              <tag><c><![CDATA[none]]></c></tag>
              <item>
                <p>Do not segment outgoing reply messages. This is useful when
                  either it is known that messages are never to large or
                  that the transport protocol can handle such things
                  on its own (for example, TCP or SCTP).</p>
              </item>
              <tag><c><![CDATA[integer() > 0]]></c></tag>
              <item>
                <p>Outgoing reply messages are segmented as needed
                  (see <c><![CDATA[max_pdu_size]]></c> below). This value, K,
                  indicates the outstanding window, that is, how many segments
                  can be outstanding (not acknowledged) at any given time.</p>
              </item>
              <tag><c><![CDATA[infinity]]></c></tag>
              <item>
                <p>Outgoing reply messages are segmented as needed
                  (see <c><![CDATA[max_pdu_size]]></c> below). Segment messages
                  are sent all at once (that is, no acknowledgement
                  before sending the next segment).</p>
              </item>
            </taglist>
            <p>Defaults to <c><![CDATA[none]]></c>.</p>
            <marker id="ci_max_pdu_size"></marker>
          </item>
          <tag><c><![CDATA[max_pdu_size]]></c></tag>
          <item>
            <p>Maximum message size. If the encoded message (PDU) exceeds
              this size, the message is to be segmented, and then
              encoded.</p>
            <p>A positive integer or <c><![CDATA[infinity]]></c>.
              Defaults to <c><![CDATA[infinity]]></c>.</p>
          </item>
        </taglist>
        <marker id="update_conn_info"></marker>
      </desc>
    </func>

    <func>
      <name>update_conn_info(ConnHandle, Item, Value)
        -> ok | {error, Reason}</name>
      <fsummary>Update information about an active connection.</fsummary>
      <type>
        <v>ConnHandle = #megaco_conn_handle{}</v>
        <v>Item = conn_info_item()</v>
        <v>Value = conn_info_value()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Updates information about an active connection.</p>
        <p>Requires that the connection is activated. See
          <seealso marker="#conn_info"><c>conn_info/2</c></seealso>
          about which items and values that are valid.</p>
        <marker id="system_info"></marker>
      </desc>
    </func>

    <func>
      <name>system_info() -> [{Item, Value}] | exit(Reason)</name>
      <name>system_info(Item) -> Value | exit(Reason)</name>
      <fsummary>Lookup system information.</fsummary>
      <type>
        <v>Item = system_info_item()</v>
      </type>
      <desc>
        <p>Lookup system information.</p>
        <p>The following <c>Item</c>s are valid:</p>
        <taglist>
          <tag><c><![CDATA[text_config]]></c></tag>
          <item>
            <p>The text encoding config.</p>
          </item>
          <tag><c><![CDATA[connections]]></c></tag>
          <item>
            <p>Lists all active connections. Returns a list of
              <c>megaco_conn_handle</c> records.</p>
          </item>
          <tag><c><![CDATA[users]]></c></tag>
          <item>
            <p>Lists all active users. Returns a list of
              <c>megaco_mid()</c>s.</p>
          </item>
          <tag><c><![CDATA[n_active_requests]]></c></tag>
          <item>
            <p>Returns an integer representing the number of requests
              that have originated from this Erlang node and still are
              active (and therefore consumes system resources).</p>
          </item>
          <tag><c><![CDATA[n_active_replies]]></c></tag>
          <item>
            <p>Returns an integer representing the number of replies
              that have originated from this Erlang node and still are
              active (and therefore consumes system resources).</p>
          </item>
          <tag><c><![CDATA[n_active_connections]]></c></tag>
          <item>
            <p>Returns an integer representing the number of active
              connections.</p>
          </item>
        </taglist>
        <marker id="info"></marker>
      </desc>
    </func>

    <func>
      <name>info() -> Info</name>
      <fsummary>All the information of the application.</fsummary>
      <type>
        <v>Info = [{Key, Value}]</v>
      </type>
      <desc>
        <p>Produces a list of information about the Megaco
          application, for example, users and their config, connections
          and their config, and statistics.</p>
        <p>This information can be produced by the functions
          <seealso marker="#user_info"><c>user_info</c></seealso>,
          <seealso marker="#conn_info"><c>conn_info</c></seealso>,
          <seealso marker="#system_info"><c>system_info</c></seealso>, and
          <seealso marker="#get_stats">get_stats</seealso>,
          but this is a simple way to get it all at once.</p>
        <marker id="connect"></marker>
      </desc>
    </func>

    <func>
      <name>connect(ReceiveHandle, RemoteMid, SendHandle, ControlPid)
        -> {ok, ConnHandle} | {error, Reason}</name>
      <name>connect(ReceiveHandle, RemoteMid, SendHandle, ControlPid, Extra)
        -> {ok, ConnHandle} | {error, Reason}</name>
      <fsummary>Establish a "virtual" connection.</fsummary>
      <type>
        <v>ReceiveHandle = #megaco_receive_handle{}</v>
        <v>RemoteMid = preliminary_mid | megaco_mid()</v>
        <v>SendHandle = term()</v>
        <v>ControlPid = pid()</v>
        <v>ConnHandle = #megaco_conn_handle{}</v>
        <v>Reason = connect_reason() | handle_connect_reason() | term()</v>
	<v>connect_reason() = {no_such_user, LocalMid}
          | {already_connected, ConnHandle} | term()</v>
	<v>handle_connect_error() = {connection_refused, ConnData, ErrorInfo}
          | term()</v>
	<v>LocalMid = megaco_mid()</v>
	<v>ConnData = term()</v>
	<v>ErrorInfo = term()</v>
        <v>Extra = term()</v>
      </type>
      <desc>
        <p>Establishes a "virtual" connection.</p>
        <p>Activates a connection to a remote user. When this is done,
          the connection can be used to send messages (with
          <c>SendMod:send_message/2</c>). The <c>ControlPid</c> is the
          identifier of a process that controls the connection. That process
          will be supervised and if it dies, this will be detected and the
          <c>UserMod:handle_disconnect/2</c> callback function is
          invoked. For more information about the callback argument, see the
          <seealso marker="megaco_user"><c>megaco_user</c></seealso> module.
          The connection can also explicitly be deactivated by invoking
          <seealso marker="#disconnect/2"><c>disconnect/2</c></seealso>.</p>
        <p>The <c>ControlPid</c> can be the identity of a process residing on
          another Erlang node. This is useful when you want to
          distribute a user over several Erlang nodes. Then one of the
          nodes has the physical connection. When a user
          residing on one of the other nodes needs to send a request (with
          <seealso marker="#call/3"><c>call/3</c></seealso> or
          <seealso marker="#cast/3"><c>cast/3</c></seealso>), the message is
          encoded on the originating Erlang node, and then
          forwarded to the node with the physical connection. When the
          reply arrives, it is forwarded back to the originator.
          The distributed connection can explicitly be deactivated by
          a local call to
          <seealso marker="#disconnect/2"><c>disconnect/2</c></seealso>
          or implicitly when
          the physical connection is deactivated (with <c>disconnect/2</c>,
          killing the controlling process, halting the other node, and so
          on).</p>
        <p>The call of this function triggers the
          <c>UserMod:handle_connect/2</c> callback function to be invoked.
          For more information about the callback arguments, see the
          <seealso marker="megaco_user"><c>megaco_user</c></seealso> module.</p>
        <p>A connection can be established in several ways:</p>
        <taglist>
          <tag><c><![CDATA[provisioned MID]]></c></tag>
          <item>
            <p>The MG can explicitly invoke megaco:connect/4 and use
              a provisioned MID of the MGC as the RemoteMid.</p>
          </item>
          <tag><c><![CDATA[upgrade preliminary MID]]></c></tag>
          <item>
            <p>The MG may explicitly invoke
              <seealso marker="#connect/4"><c>connect/4</c></seealso> with the
              atom <c>preliminary_mid</c> as a temporary MID of the MGC,
              send an intial message, the Service Change Request, to
              the MGC, and then wait for an initial message, the
              Service Change Reply. When the reply arrives, the Megaco
              application picks the MID of the MGC from the
              message header and automatically upgrades the connection
              to be a "normal" connection.</p>
            <p>By using this method of establishing the connection, the
              <c>UserMod:handle_connect/2</c> callback function is to be
              invoked twice. First with
              a <c>ConnHandle</c> with the <c>remote_mid</c> field set to
              <c>preliminary_mid</c>, and then when the connection upgrade is
              done with the <c>remote_mid</c> field set to the actual MID of
              the MGC.</p>
          </item>
          <tag><c><![CDATA[automatic]]></c></tag>
          <item>
            <p>When the MGC receives its first message, the Service
              Change Request, the Megaco application
              automatically establishes the connection by using the MG
              MID found in the message header as the remote MID.</p>
          </item>
          <tag><c><![CDATA[distributed]]></c></tag>
          <item>
            <p>When a user (MG/MGC) is distributed over several nodes,
              it is required that the node hosting the connection
              already has activated the connection and that it is
              in the "normal" state. The <c>RemoteMid</c> must be a real
              Megaco MID and not a <c>preliminary_mid</c>.</p>
          </item>
        </taglist>
        <p>An initial <c>megaco_receive_handle</c> record can be obtained with
          <seealso marker="#user_info">
          <c>user_info(UserMid, receive_handle)</c></seealso>.</p>
        <p>The send handle is provided by the preferred transport
          module, for example,
          <seealso marker="megaco_tcp"><c>megaco_tcp</c></seealso> or
          <seealso marker="megaco_udp"><c>megaco_udp</c></seealso>.</p>
	<p>The connect is done in two steps: first an internal
          <c>connection setup</c> and then by calling the user
          <seealso marker="megaco_user#connect">
          <c>megaco_user:handle_connect</c></seealso>
          callback function. The first step can result in
          an error with <c>Reason = connect_reason()</c> and the second in
          an error with <c>Reason = handle_connect_reason()</c>:</p>
	<taglist>
	  <tag><c>connect_reason()</c></tag>
	  <item>
	    <p>An error with this reason is generated by the
              Megaco application itself.</p>
	  </item>
	  <tag><c>handle_connect_reason()</c></tag>
	  <item>
	    <p>An error with this reason is caused by the user
              <seealso marker="megaco_user#connect">
              <c>megaco_user:handle_connect</c></seealso>
              callback function either returning an error
              or an invalid value.</p>
	  </item>
	</taglist>
        <p><c><![CDATA[Extra]]></c> can be any <c><![CDATA[term()]]></c>
          except the atom <c><![CDATA[ignore_extra]]></c>.
          It is passed (back) to the user through the
          <seealso marker="megaco_user#connect">
          <c>megaco_user:handle_connect/3</c></seealso> callback function.</p>
        <marker id="disconnect"></marker>
      </desc>
    </func>

    <func>
      <name>disconnect(ConnHandle, DiscoReason)
        -> ok | {error, ErrReason}</name>
      <fsummary>Tear down a "virtual" connection.</fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
        <v>DiscoReason = term()</v>
        <v>ErrReason = term()</v>
      </type>
      <desc>
        <p>Tears down a "virtual" connection.</p>
        <p>Causes the <c>UserMod:handle_disconnect/2</c> callback function to
          be invoked. For more information about the callback arguments, see
          the <seealso marker="megaco_user"><c>megaco_user</c></seealso>
          callback function.</p>
        <marker id="call"></marker>
      </desc>
    </func>

    <func>
      <name>call(ConnHandle, Actions, Options)
        -> {ProtocolVersion, UserReply}</name>
      <fsummary>Sends one or more transaction request(s) and waits for the
        reply.</fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
        <v>Actions = action_reqs() | [action_reqs()]</v>
        <v>action_reqs() = binary() | [action_request()]</v>
        <v>Options = [send_option()]</v>
        <v>send_option() = {request_timer, megaco_timer()}
          | {long_request_timer, megaco_timer()}
          | {send_handle, term()}
          | {protocol_version, integer()}
          | {call_proxy_gc_timeout, call_proxy_gc_timeout()}</v>
        <v>ProtocolVersion = integer()</v>
        <v>UserReply = user_reply() | [user_reply()]</v>
        <v>user_reply() = success() | failure()</v>
        <v>success() = {ok, result()} | {ok, result(), extra()}</v>
        <v>result() = message_result() | segment_result()</v>
        <v>message_result() = action_reps()</v>
        <v>segment_result() = segments_ok()</v>
        <v>failure() = {error, reason()} | {error, reason(), extra()}</v>
        <v>reason() = message_reason() | segment_reason()
          | user_cancel_reason() | send_reason() | other_reason()</v>
        <v>message_reason() = error_desc()</v>
        <v>segment_reason() = {segment, segments_ok(), segments_err()}
          | {segment_timeout, missing_segments(), segments_ok(),
          segments_err()}</v>
        <v>segments_ok() = [segment_ok()]</v>
        <v>segment_ok() = {segment_no(), action_reps()}</v>
        <v>segments_err() = [segment_err()]</v>
        <v>segment_err() = {segment_no(), error_desc()}</v>
        <v>missing_segments() = [segment_no()]</v>
        <v>user_cancel_reason() = {user_cancel, reason_for_user_cancel()}</v>
        <v>reason_for_user_cancel() = term()</v>
        <v>send_reason() = send_cancelled_reason() | send_failed_reason()</v>
        <v>send_cancelled_reason() = {send_message_cancelled,
          reason_for_send_cancel()}</v>
        <v>reason_for_send_cancel() = term()</v>
        <v>send_failed_reason() = {send_message_failed,
          reason_for_send_failure()}</v>
        <v>reason_for_send_failure() = term()</v>
        <v>other_reason() = {wrong_mid, WrongMid, RightMid, TR} | term()</v>
        <v>WrongMid = mid()</v>
        <v>RightMid = mid()</v>
        <v>TR = transaction_reply()</v>
        <v>action_reps() = [action_reply()]</v>
        <v>call_proxy_gc_timeout() = integer() >= 0</v>
        <v>extra() = term()</v>
      </type>
      <desc>
        <p>Sends one or more transaction request(s) and waits for the
          reply.</p>
        <p>When sending one transaction in a message,
          <c><![CDATA[Actions]]></c> is to be
          <c><![CDATA[action_reqs()]]></c> (<c><![CDATA[UserReply]]></c> will
          then be <c><![CDATA[user_reply()]]></c>). When sending several
          transactions in a message, <c><![CDATA[Actions]]></c> is to be
          <c><![CDATA[[action_reqs()]]]></c> (<c><![CDATA[UserReply]]></c>
          will then be <c><![CDATA[[user_reply()]]]></c>).
          Each element of the list is part of one transaction.</p>
        <p>For some of <em>our</em> codecs (not binary), it is also possible
          to pre-encode the actions, in which case <c><![CDATA[Actions]]></c>
          will be either a <c><![CDATA[binary()]]></c> or
          <c><![CDATA[[binary()]]]></c>.</p>
        <p>The function returns when the reply arrives, when the
          request timer eventually times out, or when the outstanding
          requests are explicitly cancelled.</p>
        <p>The default values of the send options are obtained by
          <c><![CDATA[megaco:conn_info(ConnHandle, Item)]]></c>. However,
          the send options above can explicitly be overridden.</p>
        <p>The <c><![CDATA[ProtocolVersion]]></c> is the version
          encoded in the reply message.</p>
        <p>At <c><![CDATA[success()]]></c>, the <c><![CDATA[UserReply]]></c>
          contains a list of <c>ActionReply</c> records,
          possibly containing error indications:</p>
        <list type="bulleted">
          <item>
            <p><c><![CDATA[message_error()]]></c> - The remote
              user has replied with an explicit <c>transactionError</c>.</p>
          </item>
          <item>
            <p><c><![CDATA[user_cancel_error()]]></c> - The
              request has been canceled by the user.
              <c><![CDATA[reason_for_user_cancel()]]></c> is the reason
              specified in the call to the
              <seealso marker="#cancel"><c>cancel</c></seealso> function.</p>
          </item>
          <item>
            <p><c><![CDATA[send_error()]]></c> - The send
              function of the Megaco transport callback module failed to send
              the request. There are two cases:
              <c><![CDATA[send_cancelled_reason()]]></c> and
              <c><![CDATA[send_failed_reason()]]></c>.
              The first is the result of the send function returning
              <c><![CDATA[{cancel, Reason}]]></c>. The second is another kind
              of erroneous return value. For more information, see the
              <seealso marker="megaco_transport#send_message">
              <c>megaco_transport:send_message</c></seealso> function.</p>
          </item>
          <item>
            <p><c><![CDATA[other_error()]]></c> - Another error,
              such as time-out.</p>
          </item>
        </list>
        <p>For more information about the <c>extra()</c> part of the
          result, see the Note in the beginning of the
          <seealso marker="megaco_user#extra_argument">
          <c>megaco_user</c></seealso> module.</p>
        <marker id="cast"></marker>
      </desc>
    </func>

    <func>
      <name>cast(ConnHandle, Actions, Options) -> ok | {error, Reason}</name>
      <fsummary>Sends one or more transaction request(s) but does NOT wait
        for a reply.</fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
        <v>Actions = action_reqs() | [action_reqs()]</v>
        <v>action_reqs() = binary() | [action_request()]</v>
        <v>Options = [send_option()]</v>
        <v>send_option() = {request_keep_alive_timeout,
          request_keep_alive_timeout()} | {request_timer, megaco_timer()}
          | {long_request_timer, megaco_timer()} | {send_handle, term()}
          | {reply_data, reply_data()} | {protocol_version, integer()}</v>
        <v>request_keep_alive_timeout() = plain | integer() >= 0</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Sends one or more transaction request(s) but does <em>not</em>
          wait for a reply.</p>
        <p>When sending one transaction in a message,
          <c><![CDATA[Actions]]></c> is to be
          <c><![CDATA[action_reqs()]]></c>. When sending several transactions
          in a message, <c><![CDATA[Actions]]></c> is to be
          <c><![CDATA[[action_reqs()]]]></c>. Each element of the
          list is part of one transaction.</p>
        <p>For some of <em>our</em> codecs (not binary), it is also possible
          to pre-encode the actions, in which case <c><![CDATA[Actions]]></c>
          will be either a <c><![CDATA[binary()]]></c> or
          <c><![CDATA[[binary()]]]></c>.</p>
        <p>The default values of the send options are obtained by
          <seealso marker="#conn_info">
          <c>megaco:conn_info(ConnHandle, Item)</c></seealso>.
          However, the send options above can explicitly be overridden.</p>
        <p>The <c>ProtocolVersion</c> is the version encoded
          in the reply message.</p>
        <p>The <c>UserMod:handle_trans_reply/4</c> callback function is invoked
          when the reply arrives, when the request timer eventually
          times out, or when the outstanding requests are explicitly
          cancelled. For more information about the callback arguments, see the
          <seealso marker="megaco_user"><c>megaco_user</c></seealso> module.</p>
        <p>Given as <c>UserData</c> argument to
          <c>UserMod:handle_trans_reply/4</c>.</p>
        <marker id="encode_actions"></marker>
      </desc>
    </func>

    <func>
      <name>encode_actions(ConnHandle, Actions, Options)
        -> {ok, BinOrBins} | {error, Reason}</name>
      <fsummary>Encode action requests for one or more transaction request(s).
      </fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
        <v>Actions = action_reqs() | [action_reqs()]</v>
        <v>action_reqs() = [#'ActionRequest'{}]</v>
        <v>Options = [send_option()]</v>
        <v>send_option() = {request_timer, megaco_timer()} | {long_request_timer, megaco_timer()} | {send_handle, term()} | {protocol_version, integer()}</v>
        <v>BinOrBins = binary() | [binary()]</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Encodes lists of action requests for one or more transaction
          request(s).</p>
        <p>When encoding action requests for one transaction,
          <c><![CDATA[Actions]]></c> is to be <c><![CDATA[action_reqs()]]></c>.
          When encoding action requests for several transactions,
          <c><![CDATA[Actions]]></c> is to be
          <c><![CDATA[[action_reqs()]]]></c>. Each element
          of the list is part of one transaction.</p>
        <marker id="token_tag2string"></marker>
      </desc>
    </func>

    <func>
      <name>token_tag2string(Tag) -> Result</name>
      <name>token_tag2string(Tag, EncoderMod) -> Result</name>
      <name>token_tag2string(Tag, EncoderMod, Version) -> Result</name>
      <fsummary>Convert a token tag to a string.</fsummary>
      <type>
        <v>Tag = atom()</v>
        <v>EncoderMod = pretty | compact | encoder_module()</v>
        <v>encoder_module() = megaco_pretty_text_encoder
          | megaco_compact_text_encoder | atom()</v>
        <v>Version = int_version() | atom_version()</v>
        <v>int_version() = 1 | 2 | 3</v>
        <v>atom_version() = v1 | v2 | v3 | prev3c | prev3b</v>
        <v>Result = string() | {error, Reason}</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Converts a token tag to a string.</p>
        <p><c>EncoderMod</c> defaults to <c>pretty</c>.</p>
        <p>If no or an unknown version is specified,
          the <em>best</em> version is used, which is <c>v3</c>.</p>
        <p>If no match is found for <c><![CDATA[Tag]]></c>,
          <c><![CDATA[Result]]></c> is the
          empty string (<c><![CDATA[[]]]></c>).</p>
        <marker id="cancel"></marker>
      </desc>
    </func>

    <func>
      <name>cancel(ConnHandle, CancelReason) -> ok | {error, ErrReason}</name>
      <fsummary>Cancel all outstanding messages for this connection.</fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
        <v>CancelReason = term()</v>
        <v>ErrReason = term()</v>
      </type>
      <desc>
        <p>Cancels all outstanding messages for this connection.</p>
        <p>This causes outstanding
          <seealso marker="call/3"><c>call/3</c></seealso> requests to return.
          The <c>UserMod:handle_reply/4</c> and
          <c>UserMod:handle_trans_ack/4</c> callback functions are also
          invoked where it applies. For more information about the callback
          arguments, see the
          <seealso marker="megaco_user"><c>megaco_user</c></seealso> module.</p>
        <marker id="process_received_message"></marker>
      </desc>
    </func>

    <func>
      <name>process_received_message(ReceiveHandle, ControlPid, SendHandle,
        BinMsg) -> ok</name>
      <name>process_received_message(ReceiveHandle, ControlPid, SendHandle,
        BinMsg, Extra) -> ok</name>
      <fsummary>Process a received message.</fsummary>
      <type>
        <v>ReceiveHandle = #megaco_receive_handle{}</v>
        <v>ControlPid = pid()</v>
        <v>SendHandle = term()</v>
        <v>BinMsg = binary()</v>
        <v>Extra = term()</v>
      </type>
      <desc>
        <p>Processes a received message.</p>
        <p>This function is intended to be invoked by some
          transport modules when receiving an incoming message.
          The user decides which transport to use.</p>
        <p>The message is delivered as an Erlang binary and is decoded
          by the encoding module stated in the receive handle together
          with its encoding config (also in the receive
          handle). Depending on the outcome of the decoding, various
          callback functions will be invoked. For more information about
          the callback arguments, see the
          <seealso marker="megaco_user"><c>megaco_user</c></seealso> module.</p>
        <p>Argument <c>Extra</c> is only an opaque data structure passed to
          the user through the callback functions in the
          <seealso marker="megaco_user"><c>megaco_user</c></seealso> module.
          Notice however that if <c>Extra</c> has the value
          <c>extra_undefined</c>, the argument is ignored (same as if
          <c>process_received_message/4</c> had been called).
          For more information about the behavior of the callback module,
          see the <seealso marker="megaco_user">
          <c>megaco_user</c></seealso> module.</p>
        <p>Notice that all processing is done in the context of the calling
          process. A transport module can call this function through one of the
          <c><![CDATA[spawn]]></c> functions (for example,
          <c><![CDATA[spawn_opt]]></c>). See also
          <seealso marker="#receive_message/4">
          <c>receive_message/4,5</c></seealso>.</p>
        <p>If the message cannot be decoded, the following callback
          function is invoked:</p>
        <list type="bulleted">
          <item><c>UserMod:handle_syntax_error/3</c></item>
        </list>
        <p>If the decoded message instead of transactions contains a
          message error, the following callback function is invoked:</p>
        <list type="bulleted">
          <item><c>UserMod:handle_message_error/3</c></item>
        </list>
        <p>If the decoded message is received before the
          connection is established, a new "virtual" connection is
          established. This is typically the case for the Media
          Gateway Controller (MGC) upon the first Service Change.
          When this occurs, the following callback function is invoked:</p>
        <list type="bulleted">
          <item><c>UserMod:handle_connect/2</c></item>
        </list>
        <p>For each transaction request in the decoded message the
          following callback function is invoked:</p>
        <list type="bulleted">
          <item><c>UserMod:handle_trans_request/3</c></item>
        </list>
        <p>For each transaction reply in the decoded message, the reply
          is returned to the user. Either the originating function
          <seealso marker="#call/3"><c>call/3</c></seealso> returns,
          or, if the originating function was <c>case/3</c>,
          the following callback function is invoked:</p>
        <list type="bulleted">
          <item><c>UserMod:handle_trans_reply/4</c></item>
        </list>
        <p>When a transaction acknowledgement is received, it is
          possible that the user has decided not to bother about the
          acknowledgement. However, if the return value from
          <c>UserMod:handle_trans_request/3</c> indicates that the
          acknowledgement is important, the following callback function
          is invoked:</p>
        <list type="bulleted">
          <item><c>UserMod:handle_trans_ack/4</c></item>
        </list>
        <p>For more information about the callback arguments, see the
          <seealso marker="megaco_user"><c>megaco_user</c></seealso> module.</p>
        <marker id="receive_message"></marker>
      </desc>
    </func>

    <func>
      <name>receive_message(ReceiveHandle, ControlPid, SendHandle, BinMsg)
        -> ok</name>
      <name>receive_message(ReceiveHandle, ControlPid, SendHandle, BinMsg,
        Extra) -> ok</name>
      <fsummary>Process a received message.</fsummary>
      <type>
        <v>ReceiveHandle = #megaco_receive_handle{}</v>
        <v>ControlPid = pid()</v>
        <v>SendHandle = term()</v>
        <v>BinMsg = binary()</v>
        <v>Extra = term()</v>
      </type>
      <desc>
        <p>Processes a received message.</p>
        <p>This is a callback function intended to be invoked by some
          transport modules when receiving an incoming message.
          The user decides which transport to use.</p>
        <p>In principle, this function calls the
          <c><![CDATA[process_received_message/4]]></c> function through a
          <c><![CDATA[spawn]]></c> to perform the actual processing.</p>
        <p>For more information, see the
          <seealso marker="#process_received_message">
          <c>process_received_message/4</c></seealso> function.</p>
        <marker id="parse_digit_map"></marker>
      </desc>
    </func>

    <func>
      <name>parse_digit_map(DigitMapBody)
        -> {ok, ParsedDigitMap} | {error, Reason}</name>
      <fsummary>Parse a digit map body.</fsummary>
      <type>
        <v>DigitMapBody = string()</v>
        <v>ParsedDigitMap = parsed_digit_map()</v>
        <v>parsed_digit_map() = term()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Parses a digit map body, represented as a list of
          characters, into a list of state transitions suited to
          be evaluated by <seealso marker="#eval_digit_map/1">
          <c>eval_digit_map/1,2</c></seealso>.</p>
        <marker id="eval_digit_map"></marker>
      </desc>
    </func>

    <func>
      <name>eval_digit_map(DigitMap) -> {ok, MatchResult} | {error, Reason}
      </name>
      <name>eval_digit_map(DigitMap, Timers)
        -> {ok, MatchResult} | {error, Reason}</name>
      <fsummary>Collect digit map letters according to the digit map.</fsummary>
      <type>
        <v>DigitMap = #'DigitMapValue'{} | parsed_digit_map()</v>
        <v>parsed_digit_map() = term()</v>
        <v>ParsedDigitMap = term()</v>
        <v>Timers = ignore() | reject()</v>
        <v>ignore() = ignore | {ignore, digit_map_value()}</v>
        <v>reject() = reject | {reject, digit_map_value()}
          | digit_map_value()</v>
        <v>MatchResult = {Kind, Letters} | {Kind, Letters, Extra}</v>
        <v>Kind = kind()</v>
        <v>kind() = full | unambiguous</v>
        <v>Letters = [letter()]</v>
        <v>letter() = $0..$9 | $a .. $k</v>
        <v>Extra = letter()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Collects digit map letters according to the digit map.</p>
        <p>When evaluating a digit map, a state machine waits for
          time-outs and letters reported by
          <seealso marker="#report_digit_event/2">
          <c>report_digit_event/2</c></seealso>. The length of the various
          time-outs are defined in the <c>digit_map_value()</c> record.</p>
        <p>When a complete sequence of valid events has been received,
          the result is returned as a list of letters.</p>
        <p>There are two options for handling syntax errors (that is,
          when an unexpected event is received when the digit map
          evaluator expects some other event). The unexpected
          events can either be ignored or rejected. The latter means
          that the evaluation is aborted and an error is returned.</p>
        <marker id="report_digit_event"></marker>
      </desc>
    </func>

    <func>
      <name>report_digit_event(DigitMapEvalPid, Events) -> ok | {error, Reason}
      </name>
      <fsummary>Send one or more events to the event collector process.
      </fsummary>
      <type>
        <v>DigitMapEvalPid = pid()</v>
        <v>Events = Event | [Event]</v>
        <v>Event = letter() | pause() | cancel()</v>
        <v>letter() = $0..$9 | $a .. $k | $A .. $K</v>
        <v>pause() = one_second() | ten_seconds()</v>
        <v>one_second() = $s | $S</v>
        <v>ten_seconds() = $l | $L</v>
        <v>cancel() = $z | $Z | cancel</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Sends one or more events to the event collector process.</p>
        <p>Sends one or more events to a process that is evaluating a
          digit map, that is, a process that is executing
          <seealso marker="#eval_digit_map/1,2">
          <c>eval_digit_map/1,2</c></seealso>.</p>
        <p>Notice that the events <c><![CDATA[$s | $S]]></c>,
          <c><![CDATA[l | $L]]></c>, and <c><![CDATA[$z | $Z]]></c> have
          nothing to do with the timers using the same characters.</p>
        <marker id="test_digit_event"></marker>
      </desc>
    </func>

    <func>
      <name>test_digit_event(DigitMap, Events)
        -> {ok, Kind, Letters} | {error, Reason}</name>
      <fsummary>Feed digit map collector with events and return the result.
      </fsummary>
      <type>
        <v>DigitMap = #'DigitMapValue'{} | parsed_digit_map()</v>
        <v>parsed_digit_map() = term()</v>
        <v>ParsedDigitMap = term()</v>
        <v>Timers = ignore() | reject()</v>
        <v>ignore() = ignore | {ignore, digit_map_value()}</v>
        <v>reject() = reject | {reject, digit_map_value()}
          | digit_map_value()</v>
        <v>DigitMapEvalPid = pid()</v>
        <v>Events = Event | [Event]</v>
        <v>Event = letter() | pause() | cancel()</v>
        <v>Kind = kind()</v>
        <v>kind() = full | unambiguous</v>
        <v>Letters = [letter()]</v>
        <v>letter() = $0..$9 | $a .. $k | $A .. $K</v>
        <v>pause() = one_second() | ten_seconds()</v>
        <v>one_second() = $s | $S</v>
        <v>ten_seconds() = $l | $L</v>
        <v>cancel() = $z | $Z | cancel</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Feeds digit map collector with events and returns the result.</p>
        <p>This function starts the evaluation of a digit map with
          <seealso marker="#eval_digit_map/1">
          <c>eval_digit_map/1</c></seealso> and sends a sequence of events to
          <seealso marker="#report_digit_event/2">
          <c>report_digit_event/2</c></seealso> to simplify testing of
          digit maps.</p>
        <marker id="encode_sdp"></marker>
      </desc>
    </func>

    <func>
      <name>encode_sdp(SDP) -> {ok, PP} | {error, Reason}</name>
      <fsummary>Encode an SDP construct.</fsummary>
      <type>
        <v>SDP = sdp_property_parm() | sdp_property_group()
          | sdp_property_groups() | asn1_NOVALUE</v>
        <v>PP = property_parm() | property_group() | property_groups()
          | asn1_NOVALUE</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Encodes (generates) an SDP construct.</p>
        <p>If a <c><![CDATA[property_parm()]]></c> is found as part of the
          input (<c><![CDATA[SDP]]></c>), it is left unchanged.</p>
        <p>This function performs the following transformation:</p>
        <list type="bulleted">
          <item><c>sdp()</c> -&gt; <c>property_parm()</c>
          </item>
          <item><c>sdp_property_group()</c> -&gt; <c>property_group()</c>
          </item>
          <item><c>sdp_property_groups()</c> -&gt;  <c>property_groups()</c>
          </item>
        </list>
        <marker id="decode_sdp"></marker>
      </desc>
    </func>

    <func>
      <name>decode_sdp(PP) -> {ok, SDP} | {error, Reason}</name>
      <fsummary>Decode a property parameter construct.</fsummary>
      <type>
	<v>PP = property_parm() | property_group() | property_groups()
          | asn1_NOVALUE</v>
	<v>SDP = sdp() | decode_sdp_property_group()
          | decode_sdp_property_groups() | asn1_NOVALUE</v>
	<v>decode_sdp() = sdp() | {property_parm(), DecodeError}</v>
	<v>decode_sdp_property_group() = [decode_sdp()]</v>
	<v>decode_sdp_property_groups() = [decode_sdp_property_group()]</v>
	<v>DecodeError = term()</v>
	<v>Reason = term()</v>
      </type>
      <desc>
        <p>Decodes (parses) a property parameter construct.</p>
        <p>When decoding <c><![CDATA[property_group()]]></c> or
          <c><![CDATA[property_groups()]]></c>,
          those property parameter constructs that cannot be decoded
          (either because of a decode error or because they are unknown),
          are returned as a two-tuple. The first element
          is the (undecoded) property parameter and the other the reason.
          This means that the caller of this function has to expect not
          only SDP records, but also this two-tuple construct.</p>
        <p>This function performs the following transformation:</p>
        <list type="bulleted">
          <item><c>property_parm()</c> -&gt; <c>sdp()</c>
          </item>
          <item><c>property_group()</c> -&gt; <c>sdp_property_group()</c>
          </item>
          <item><c>property_groups()</c> -&gt; <c>sdp_property_groups()</c>
          </item>
        </list>
	<marker id="get_sdp_record_from_PG"></marker>
      </desc>
    </func>

    <func>
      <name>get_sdp_record_from_PropertGroup(Type, PG) -> [sdp()]</name>
      <fsummary>Get all SDP records of a certain type from a property group.
      </fsummary>
      <type>
        <v>Type = v | c | m | o | a | b | t | r | z | k | s | i | u | e | p</v>
        <v>PG = sdp_property_group()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Retrieves all the SDP records of type <c>Type</c> from
          property group <c>PG</c>.</p>
        <marker id="versions1"></marker>
        <marker id="versions2"></marker>
      </desc>
    </func>

    <func>
      <name>versions1() -> {ok, VersionInfo} | {error, Reason}</name>
      <name>versions2() -> {ok, Info} | {error, Reason}</name>
      <fsummary>Retreive various system and application information.</fsummary>
      <type>
        <v>VersionInfo = [version_info()]</v>
        <v>version_info() = term()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Retrieves some system and application information.</p>
        <p>The difference between the two functions is in how they get
          the modules to check. <c><![CDATA[versions1]]></c> uses the
          app file and <c><![CDATA[versions2]]></c> uses the function
          <c><![CDATA[application:get_key]]></c>.</p>
        <marker id="print_version_info"></marker>
      </desc>
    </func>

    <func>
      <name>print_version_info() -> void()</name>
      <name>print_version_info(VersionInfo) -> void()</name>
      <fsummary>Formated print of result of the versions functions.</fsummary>
      <type>
        <v>VersionInfo = [version_info()]</v>
        <v>version_info() = term()</v>
      </type>
      <desc>
        <p>Produces a formated printout of the versions information generated
          by the <c><![CDATA[versions1]]></c> and <c><![CDATA[versions2]]></c>
          functions.</p>
        <p>The function <c>print_version_info/0</c> uses the result of function
          <c>version1/0</c> as <c><![CDATA[VersionInfo]]></c>.</p>
        <p>Example:</p>
        <pre>
{ok, V} = megaco:versions1(), megaco:format_versions(V).</pre>
        <marker id="enable_trace"></marker>
      </desc>
    </func>

    <func>
      <name>enable_trace(Level, Destination) -> void()</name>
      <fsummary>Start Megaco tracing.</fsummary>
      <type>
        <v>Level = max | min | 0 &lt;= integer() &lt;= 100</v>
        <v>Destination = File | Port | HandlerSpec | io</v>
        <v>File = string()</v>
        <v>Port = integer()</v>
        <v>HandleSpec = {HandlerFun, Data}</v>
        <v>HandleFun = fun() (two arguments)</v>
        <v>Data = term()</v>
      </type>
      <desc>
        <p>Starts Megaco tracing at a specified
          <c><![CDATA[Level]]></c> and direct the result to the specified
          <c><![CDATA[Destination]]></c>.</p>
        <p>This function starts a tracer server and then sets the proper match
          spec (according to <c><![CDATA[Level]]></c>).</p>
        <p>In the case when <c><![CDATA[Destination]]></c> is
          <c><![CDATA[File]]></c>, the printable
          Megaco trace events are printed to the file <c><![CDATA[File]]></c>
          using plain <c><![CDATA[io:format/2]]></c>.</p>
        <p>In the case when <c><![CDATA[Destination]]></c> is
          <c><![CDATA[io]]></c>, the printable
          Megaco trace events are printed on stdout using plain
          <c><![CDATA[io:format/2]]></c>.</p>
        <p>For more information, see the
          <seealso marker="runtime_tools:dbg">
          <c>runtime_tools:dbg</c></seealso> module.</p>
        <marker id="disable_trace"></marker>
      </desc>
    </func>

    <func>
      <name>disable_trace() -> void()</name>
      <fsummary>Stop Megaco tracing.</fsummary>
      <desc>
        <p>Stops Megaco tracing.</p>
        <marker id="set_trace"></marker>
      </desc>
    </func>

    <func>
      <name>set_trace(Level) -> void()</name>
      <fsummary>Change Megaco trace level.</fsummary>
      <type>
        <v>Level = max | min | 0 &lt;= integer() &lt;= 100</v>
      </type>
      <desc>
        <p>Changes the Megaco trace level.</p>
        <p>It is assumed that tracing has been enabled (see
          <seealso marker="#enable_trace"><c>enable_trace/2</c></seealso>.</p>
        <marker id="stats"></marker>
        <marker id="get_stats"></marker>
      </desc>
    </func>

    <func>
      <name>get_stats() -> {ok, TotalStats} | {error, Reason}</name>
      <name>get_stats(GlobalCounter) -> {ok, CounterStats} | {error, Reason}
      </name>
      <name>get_stats(ConnHandle) -> {ok, ConnHandleStats} | {error, Reason}
      </name>
      <name>get_stats(ConnHandle, Counter) -> {ok, integer()} | {error, Reason}
      </name>
      <fsummary></fsummary>
      <type>
        <v>TotalStats = [total_stats()]</v>
        <v>total_stats() = {conn_handle(), [stats()]}
          | {global_counter(), integer()}</v>
        <v>GlobalCounter = global_counter()</v>
        <v>GlobalCounterStats = integer()</v>
        <v>ConnHandle = conn_handle()</v>
        <v>ConnHandleStats = [stats()]</v>
        <v>stats() = {counter(), integer()}</v>
        <v>Counter = counter()</v>
        <v>counter() = medGwyGatewayNumTimerRecovery
          | medGwyGatewayNumErrors</v>
        <v>global_counter() = medGwyGatewayNumErrors</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Retreives the (SNMP) statistic counters maintained by the
          Megaco application. The global
          counters handle events that cannot be attributed to
          a single connection (for example, protocol errors that occur
          before the connection has been set up properly).</p>
        <marker id="reset_stats"></marker>
      </desc>
    </func>

    <func>
      <name>reset_stats() -> void()</name>
      <name>reset_stats(ConnHandle) -> void()</name>
      <fsummary></fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
      </type>
      <desc>
        <p>Resets all related (SNMP) statistics counters.</p>
        <marker id="test_request"></marker>
      </desc>
    </func>

    <func>
      <name>test_request(ConnHandle, Version, EncodingMod, EncodingConfig,
        Actions) -> {MegaMsg, EncodeRes}</name>
      <fsummary>Tests if the Actions argument is correct.</fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
        <v>Version = integer()</v>
        <v>EncodingMod = atom()</v>
        <v>EncodingConfig = Encoding configuration</v>
        <v>Actions = A list</v>
        <v>MegaMsg = #'MegacoMessage'{}</v>
        <v>EncodeRes = {ok, Bin} | {error, Reason}</v>
        <v>Bin = binary()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Tests if argument <c>Actions</c> is correctly composed.</p>
        <p>This function is only intended for testing purposes. It is
          supposed to have the same kind of interface as the
          <seealso marker="#call"><c>call/3</c></seealso> or
          <seealso marker="#cast">cast/3</seealso> functions (with the
          additions of the <c><![CDATA[EncodingMod]]></c> and
          <c><![CDATA[EncodingConfig]]></c>
          arguments). It composes a complete Megaco message and
          attempts to encode it. The return value is a tuple of
          the composed Megaco message and the encode result.</p>
        <marker id="test_reply"></marker>
      </desc>
    </func>

    <func>
      <name>test_reply(ConnHandle, Version, EncodingMod, EncodingConfig,
        Reply) -> {MegaMsg, EncodeRes}</name>
      <fsummary>Test if the Reply argument is correct.</fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
        <v>Version = integer()</v>
        <v>EncodingMod = atom()</v>
        <v>EncodingConfig = A list</v>
        <v>Reply = actual_reply()</v>
        <v>MegaMsg = #'MegacoMessage'{}</v>
        <v>EncodeRes = {ok, Bin} | {error, Reason}</v>
        <v>Bin = binary()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Tests if argument <c>Reply</c> is correctly composed.</p>
        <p>This function is only intended for testing purposes. It is
          supposed to test the <c><![CDATA[actual_reply()]]></c> return
          value of the <seealso marker="megaco_user#trans_request">
          <c>megaco_user:handle_trans_request</c></seealso> and
          <seealso marker="megaco_user#trans_long_request">
          <c>megaco_user:handle_trans_long_request</c></seealso>
          callback functions (with the additions of the
          <c><![CDATA[EncodingMod]]></c> and
          <c><![CDATA[EncodingConfig]]></c> arguments). It composes a complete
          Megaco message end attempts to encode it. The return value is
          a tuple of the composed Megaco message and the encode result.</p>
      </desc>
    </func>
  </funcs>

</erlref>

