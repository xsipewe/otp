<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE chapter SYSTEM "chapter.dtd">

<chapter>
  <header>
    <copyright>
      <year>2000</year><year>2016</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    
    </legalnotice>

    <title>Internal Form and its Encodings</title>
    <prepared>H&aring;kan Mattsson</prepared>
    <responsible>H&aring;kan Mattsson</responsible>
    <docno></docno>
    <approved>H&aring;kan Mattsson</approved>
    <checked></checked>
    <date>2016-12-12</date>
    <rev>%VSN%</rev>
    <file>megaco_encode.xml</file>
  </header>
  <p>This version of the stack is compliant with:</p>
  <list type="bulleted">
    <item><url href="http://tools.ietf.org/html/rfc3525">
      Megaco/H.248 version 1, RFC 3525</url>
      updated according to Implementors Guide version 10-13
    </item>
    <item><url href="https://tools.ietf.org/html/draft-ietf-megaco-h248v2-04">
      Megaco/H.248 version 2</url>
      updated according to Implementors Guide version 10-13
    </item>
    <item><url href="https://www.itu.int/rec/T-REC-H.248.1">
      Megaco/H.248.1 version 3</url>
    </item>
  </list>

  <section>
    <title>Internal Form of Messages</title>
    <p>We use the same internal form for both the binary and text
      encoding. Our internal form of Megaco/H.248 messages is heavily
      influenced by the internal format used by ASN.1
      encoders/decoders:</p>
    <list type="bulleted">
      <item>
        <p>"SEQUENCE OF" is represented as a list.</p>
      </item>
      <item>
        <p>"CHOICE" is represented as a tagged tuple with size 2.</p>
      </item>
      <item>
        <p>"SEQUENCE" is represented as a record, defined in
          <c>megaco/include/megaco_message_v1.hrl</c>.</p>
      </item>
      <item>
        <p>"OPTIONAL" is represented as an ordinary field in a
          record that defaults to <c>asn1_NOVALUE</c>, meaning that the
          field has no value.</p>
      </item>
      <item>
        <p>"OCTET STRING" is represented as a list of unsigned integers.</p>
      </item>
      <item>
        <p>"ENUMERATED" is represented as a single atom.</p>
      </item>
      <item>
        <p>"BIT STRING" is represented as a list of atoms.</p>
      </item>
      <item>
        <p>"BOOLEAN" is represented as the atom <c>true</c> or <c>false</c>.</p>
      </item>
      <item>
        <p>"INTEGER" is represented as an integer.</p>
      </item>
      <item>
        <p>"IA5String" is represented as a list of integers,
          where each integer is the ASCII value of the corresponding
          character.</p>
      </item>
      <item>
        <p>"NULL" is represented as the atom <c>NULL</c>.</p>
      </item>
    </list>
    <p>To fully understand the internal form, you must get
      an ASN.1 specification for the Megaco/H.248 protocol,
      and apply the rules listed above.
      For more details about the semantics in mapping between
      ASN.1 and the corresponding internal form, see the
      <seealso marker="asn1">Asn1</seealso> application.</p>
    <p>Observe that the <c>TerminationId</c> record is not used in the
      internal form. It has been replaced with a <c>megaco_term_id</c> record
      (defined in <c>megaco/include/megaco.hrl</c>).</p>
  </section>

  <section>
    <title>The Different Encodings</title>
    <p>The Megaco/H.248 standard defines both a plain text encoding
      and a binary encoding (ASN.1 BER) and we have implemented
      encoders and decoders for both. We supply five
      different encoding/decoding modules.</p>
    <p>In the text encoding, implementors can use a mix of short and
      long keywords, and add white spaces to improve readability.
      We use the following terms:</p>
    <list type="bulleted">
      <item><p>"compact" for text messages with the shortest possible
        keywords and no optional white spaces</p>
      </item>
      <item><p>"pretty" for a well-indented text
        format using long keywords and an indentation style like the
        text examples in the Megaco/H.248 specification.</p>
      </item>
    </list>
    <p>The following text message examples show the difference between
      the pretty and compact versions. First the pretty printed, well-indented
      version with long keywords:</p>
    <pre>
MEGACO/1 [124.124.124.222]
Transaction = 9998 {
        Context = - {
                ServiceChange = ROOT {
                        Services {
                                Method = Restart,
                                ServiceChangeAddress = 55555,
                                Profile = ResGW/1,
                                Reason = "901 Cold Boot"
                        }
                }
        }
}</pre>
    <p>The corresponding compact version without indentation and with
      short keywords is as follows:</p>
    <pre>
!/1 [124.124.124.222]
T=9998{C=-{SC=ROOT{SV{MT=RS,AD=55555,PF=ResGW/1,RE="901 Cold Boot"}}}}</pre>
    <p>The following shows the programmers view of the same message;
      first a list of <c>ActionRequest</c> records are constructed and
      then it is sent with one of the send functions in the API:</p>
    <pre>
Prof = #'ServiceChangeProfile'{profileName = "resgw", version = 1},
Parm = #'ServiceChangeParm'{serviceChangeMethod  = restart,
                            serviceChangeAddress = {portNumber, 55555},
                            serviceChangeReason  = "901 Cold Boot",
                            serviceChangeProfile = Prof},
Req = #'ServiceChangeRequest'{terminationID = [?megaco_root_termination_id],
                              serviceChangeParms = Parm},
Actions = [#'ActionRequest'{contextId = ?megaco_null_context_id,
                            commandRequests = {serviceChangeReq, Req}}],
megaco:call(ConnHandle, Actions, Config).</pre>
    <p>The following is a printout of the entire internal form:</p>
    <pre>
{'MegacoMessage',
 asn1_NOVALUE,
 {'Message',
  1,
  {ip4Address,{'IP4Address', [124,124,124,222], asn1_NOVALUE}},
  {transactions,
   [
    {transactionRequest,
     {'TransactionRequest',
       9998,
       [{'ActionRequest',
         0,
         asn1_NOVALUE,
         asn1_NOVALUE,
         [
          {'CommandRequest',
           {serviceChangeReq,
            {'ServiceChangeRequest',
             [
              {megaco_term_id, false, ["root"]}],
              {'ServiceChangeParm',
               restart,
               {portNumber, 55555},
               asn1_NOVALUE,
               {'ServiceChangeProfile', "resgw", version = 1},
               "901 MG Cold Boot",
               asn1_NOVALUE,
               asn1_NOVALUE,
               asn1_NOVALUE
              }
            }
           },
           asn1_NOVALUE,
           asn1_NOVALUE
          }
         ]
        }
       ]
     }
    }
   ]
  }
 }
}</pre>
    <p>The following encoding modules are provided:
      </p>
    <list type="bulleted">
      <item>
        <p><c>megaco_pretty_text_encoder</c> - Encodes messages into
          pretty text format, decodes both pretty and compact text.</p>
      </item>
      <item>
        <p><c>megaco_compact_text_encoder</c> - Encodes messages into
          compact text format, decodes both pretty and compact text.</p>
      </item>
      <item>
        <p><c>megaco_binary_encoder</c> - Encodes/decodes ASN.1 BER messages.
          This encoder implements the fastest of the BER encoders/decoders.
          Recommended binary codec.</p>
      </item>
      <item>
        <p><c>megaco_ber_encoder</c> - Encodes/decodes ASN.1 BER messages.</p>
      </item>
      <item>
        <p><c>megaco_per_encoder</c> - Encodes/decodes ASN.1 PER
          messages. Notice that this format is not included in the
          Megaco standard.</p>
      </item>
      <item>
        <p><c>megaco_erl_dist_encoder</c> - Encodes messages into Erlang's
          distribution format. It is rather verbose, but encoding and
          decoding is extremely fast. Notice that this format is not
          included in the Megaco standard.</p>
      </item>
    </list>
  </section>

  <section>
    <marker id="erl_dist_config"></marker>
    <title>Configuration of Erlang Distribution Encoding Module</title>
    <p>The <c>encoding_config</c> of the <c>megaco_erl_dist_encoder</c>
      module can be any of the following:</p>
    <list type="bulleted">
      <item>
        <p><c><![CDATA[[]]]></c> - Encodes the messages to the standard
          distribution format. It is rather verbose but encoding and
          decoding is extremely fast.</p>
      </item>
      <item>
        <p><c><![CDATA[[megaco_compressed]]]></c> - Encodes the messages to the
          standard distribution format after an internal transformation.
          It is less verbose, but the total time of the encoding and
          decoding is somewhat slower (for more information, see section
          <seealso marker="megaco_performance">
          Performance Comparison</seealso>.</p>
      </item>
      <item>
        <p><c><![CDATA[[{megaco_compressed, Module}]]]></c> - Works as
          the <c>megaco_compressed</c> configuration parameter, but the
          users must here provide their own compress module. This module must
          implement the <seealso marker="megaco_edist_compress">
          <c>megaco_edist_compress</c></seealso> behavior.</p>
      </item>
      <item>
        <p><c><![CDATA[[compressed]]]></c> - Encodes the messages to a
          compressed form of the standard distribution format. It is less
          verbose, but encoding and decoding are slower.</p>
      </item>
    </list>
  </section>

  <section>
    <marker id="text_config"></marker>
    <title>Configuration of Text Encoding Module(s)</title>
    <p>When using text encoding(s), two different configurations control
      which software to use:</p>
    <list type="bulleted">
      <item>
        <p><c><![CDATA[[]]]></c> - An empty list indicates that the Erlang
          scanner is to be used.</p>
      </item>
      <item>
        <p><c><![CDATA[[{flex, port()}]]]></c> - Use the flex scanner when
          decoding (not optimized for SMP). For more information, see section
          <seealso marker="megaco_run#initial_config">
          Initial Configuration</seealso>.</p>
      </item>
      <item>
        <p><c><![CDATA[[{flex, ports()}]]]></c> - Use the flex scanner when
          decoding (optimized for SMP). For more information, see section
          <seealso marker="megaco_run#initial_config">
          Initial Configuration</seealso>.</p>
      </item>
    </list>
    <p>The flex scanner is a Megaco scanner written as a linked-in driver
      (in C). There are two ways to get this working:</p>
    <list type="bulleted">
      <item>
        <p>Let the Megaco stack start the flex scanner
          (load the driver).</p>
        <p>To achieve this, configure the Megaco stack as follows:</p>
        <list type="bulleted">
          <item>
            <p>Add the <c><![CDATA[{scanner, flex}]]></c> (or similar) directive
              to an Erlang system configuration file for the Megaco application
              (for details, see section
              <seealso marker="megaco_run#initial_config">
              Initial Configuration</seealso>.</p>
          </item>
          <item>
            <p>Retrieve the encoding-config using the
              <seealso marker="megaco#system_info">
              <c>megaco:system_info</c></seealso>
              function with <c>Item = text_config</c>.</p>
          </item>
          <item>
            <p>Update the receive handle with the encoding-config
              (field <c>encoding_config</c>).</p>
          </item>
        </list>
        <p>The benefit of this is that Megaco handles the starting, holding,
          and the supervision of the driver and port.</p>
      </item>
      <item>
        <p>The Megaco client (user) starts the flex scanner (loads the
          driver).</p>
        <p>When starting the flex scanner, a port to the linked-in driver is
          created. This port must be owned by a process, which must
          not die. If the process dies, the port terminates. Therefore,
          perform the following:</p>>
        <list type="bulleted">
          <item>
            <p>Create a permanent process. Ensure that this process is
              supervised (so that if it dies, this will be noticed).</p>
          </item>
          <item>
            <p>Let this process start the flex scanner by calling the
              <seealso marker="megaco_flex_scanner#start/0">
              <c>megaco_flex_scanner:start/0,1</c></seealso> function.</p>
          </item>
          <item>
            <p>Retrieve the encoding-config and when initiating
              the <c><![CDATA[megaco_receive_handle]]></c>, set the
              field <c>encoding_config</c> accordingly.</p>
          </item>
          <item>
            <p>Pass the <c><![CDATA[megaco_receive_handle]]></c> to the 
              transport module.</p>
          </item>
        </list>
      </item>
    </list>
  </section>

  <section>
    <marker id="binary_config"></marker>
    <title>Configuration of Binary Encoding module(s)</title>
    <p>When using binary encoding, the structure of the termination IDs
      must be specified.</p>
    <list type="bulleted">
      <item>
        <p><c><![CDATA[[native]]]></c> - Skips the transformation phase, that
          is, the decoded message(s) are not transformed into our internal
          form.</p>
      </item>
      <item>
        <p><c><![CDATA[[integer()]]]></c> - A list containing the size (the
          number of bits) of each level.
          Example: <c><![CDATA[[3,8,5,8]]]></c>.</p>
      </item>
      <item>
        <p><c><![CDATA[integer()]]></c> - The number of one byte (8 bits)
          levels. Notice that this is currently converted into the previous
          config.
          Example: <c><![CDATA[3]]></c> (<c><![CDATA[[8,8,8]]]></c>).</p>
      </item>
    </list>
  </section>

  <section>
    <marker id="handling_versions"></marker>
    <title>Handling Megaco Versions</title>
    <p>As version 3 implemented in this version of the Megaco
      application is preliminary, it is necessary to have a way
      to handle different version 3 implementations. Therefore,
      the encoding-config option <c><![CDATA[{version3, version3()}]]></c>
      has been introduced.
      This option, if present, must be <em>first</em> in the
      encoding-config list. Version 1 and 2 codecs ignore this option, if
      found.</p>
    <code type="none"><![CDATA[
version3() -> prev3a | prev3b | prev3c | v3    ]]></code>
    <list type="bulleted">
      <item>
        <p><c>prev3a</c></p>
        <p>Preliminary version 3, based on TD-33.</p>
      </item>
      <item>
        <p><c>prev3b</c></p>
        <p>Preliminary version 3, based on TD-33, but text encoding
          is updated with the final solution for priority in
          <c><![CDATA[contextProperty]]></c> (which is backward compatible
          with version 2).</p>
      </item>
      <item>
        <p><c>prev3c</c></p>
        <p>Preliminary version 3, based on the final version of the
          version 3 standard, but <em>excluding</em> segments.</p>
      </item>
      <item>
        <p><c>v3</c></p>
        <p>Full version 3. Includes segmentation. This is the default
          version 3 variant (that is, if a version 3 messages is to be
          encoded/decoded and no version 3 encoding-config is found,
          then <c>v3</c> is assumed).</p>
      </item>
    </list>
    <p>The different Megaco encoding versions can be handled in two ways.
      Either use <em>dynamic version detection</em> (only valid for
      for incoming messages) or use <em>explicit version</em> setting in
      the connection info.</p>
    <p>For incoming messages:</p>
    <list type="bulleted">
      <item>
        <p>Dynamic version detection</p>
        <p>Set the protocol version in the <c>megaco_receive_handle</c> to
          <c><![CDATA[dynamic]]></c> (this is the default).
          This works for codecs supporting partial decode of the version,
          currently text, and <c>ber_bin</c>
          (<c><![CDATA[megaco_binary_encoder]]></c> and
          <c><![CDATA[megaco_ber_bin_encoder]]></c>).
          This way the decoder detects which version is used and
          then uses the proper decoder.</p>
      </item>
      <item>
        <p>Explicit version</p>
        <p>Explicitly set the actual protocol version in the
          <c>megaco_receive_handle</c>.
          Start with version 1. When the initial service change has been
          performed and version 2 has been negotiated, upgrade the
          <c>megaco_receive_handle</c> of the transport process
          (<c>control_pid</c>) to  version 2. See
          <seealso marker="megaco_tcp#upgrade_receive_handle">
          <c>megaco_tcp:upgrade_receive_handle</c></seealso> and
          <seealso marker="megaco_udp#upgrade_receive_handle">
          <c>megaco_udp:upgrade_receive_handle</c></seealso>.</p>
        <p>Notice that if <c><![CDATA[udp]]></c> is used, the same transport
          process can be used for several connections. This can make upgrading
          impossible.</p>
        <p>For codecs not supporting partial decode of the version, currently
          <c><![CDATA[megaco_ber_encoder]]></c>,
          <c><![CDATA[megaco_per_encoder]]></c>,
          <c><![CDATA[megaco_per_bin_encoder]]></c>, and
          <c><![CDATA[dynamic]]></c> revert to version 1.</p>
      </item>
    </list>
    <p>For outgoing messages:</p>
    <list type="bulleted">
      <item>
        <p>Update the connection info <c>protocol_version</c>.</p>
      </item>
      <item>
        <p>Override the protocol version when sending a message by adding the
          <c><![CDATA[{protocol_version, integer()}]]></c> item to
          <c>Options</c>, see
          <seealso marker="megaco#call"><c>megaco:call</c></seealso> or
          <seealso marker="megaco#cast"><c>megaco:cast</c></seealso>.</p>
        <p>Notice that this does not affect the messages that are sent
          autonomously by the stack. They use the <c>protocol_version</c> of
          the connection info.</p>
      </item>
    </list>
  </section>

  <section>
    <title>Encoder Callback Functions</title>
    <p>The encoder callback interface is defined by the
      <c><![CDATA[megaco_encoder]]></c> behavior, see the
      <seealso marker="megaco_encoder"><c>megaco_encoder</c></seealso>
      module.</p>
  </section>
</chapter>

