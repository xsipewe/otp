<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE chapter SYSTEM "chapter.dtd">

<chapter>
  <header>
    <copyright>
      <year>2000</year><year>2016</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    
    </legalnotice>

    <title>Architecture</title>
    <prepared>H&aring;kan Mattsson</prepared>
    <responsible>H&aring;kan Mattsson</responsible>
    <docno></docno>
    <approved>H&aring;kan Mattsson</approved>
    <checked></checked>
    <date>2016-12-12</date>
    <rev>%VSN%</rev>
    <file>megaco_architecture.xml</file>
  </header>

  <section>
    <title>Network View</title>
    <p>Megaco is a (master/slave) protocol for control of gateway functions at
      the edge of the packet network. Examples of this is IP-PSTN trunking
      gateways and analog line gateways. The main function of Megaco is to
      allow gateway decomposition into a call agent (call control) part (known
      as Media Gateway Controller, MGC) - master, and a gateway interface
      part (known as Media Gateway, MG) - slave. The MG has no call control
      knowledge and only makes the connections and simple
      configurations.</p>
    <p>SIP and H.323 are peer-to-peer protocols for call control (valid only
      for some of the protocols within H.323), or more generally multimedia
      session protocols. They both operate at a different level (call control)
      from Megaco in a decomposed network, and are therefore not aware of
      whether Megaco is used underneath.</p>
    <image file="megaco_sys_arch.gif">
      <icaption>Network Architecture</icaption>
    </image>
    <p>Megaco and peer protocols are complementary in nature and entirely
      compatible within the same system. At a system level, Megaco allows
      for the following:</p>
    <list type="bulleted">
      <item>
        <p>Overall network cost and performance optimization</p>
      </item>
      <item>
        <p>Protection of investment by isolation of changes at the call 
          control layer</p>
      </item>
      <item>
        <p>Freedom to geographically distribute both call function and 
          gateway function</p>
      </item>
      <item>
        <p>Adaptation of legacy equipment</p>
      </item>
    </list>
  </section>

  <section>
    <title>General</title>
    <p>This Erlang/OTP application supplies a framework for building
      applications that need to use the Megaco/H.248 protocol.</p>
    <p>We have introduced the term "user" as a generic term for either
      an MG or an MGC, as most of the functionality we support is
      common for both MGs and MGCs. A (local) user can be configured
      in various ways and can establish any number of connections
      to its counterpart, the remote user. Once a connection has been
      established, the connection is supervised and can be used for
      the purpose of sending messages. Notice that according to the standard,
      an MG is connected to at most one MGC, while an MGC can be
      connected to any number of MGs.</p>
    <p>For the purpose of managing "virtual MGs", one Erlang node can
      host any number of MGs. In fact, it can host a mix of MGs and
      MGCs. You can say that an Erlang node can host any number of
      "users".</p>
    <p>The protocol engine uses callback modules to handle various
      things:</p>
    <list type="bulleted">
      <item>
        <p>Encoding callback modules - Handles the encoding and
          decoding of messages. Several modules for handling different
          encodings are included, such as ASN.1 BER, pretty well-indented
          text, compact text, and some others. Others may be
          written by you.</p>
      </item>
      <item>
        <p>Transport callback modules - Handles sending and receiving
          of messages. Transport modules for TCP/IP and UDP/IP are
          included and others may be written by you.</p>
      </item>
      <item>
        <p>User callback modules - The actual implementation of an MG
          or MGC. Most of the functions are intended for handling of a
          decoded transaction (request, reply, acknowledgement), but
          others are handling connect, disconnect, and
          errors cases.</p>
      </item>
    </list>
    <p>Each connection can have its own configuration of callback
      modules, resend timers, transaction ID ranges, and so on, and they
      can be reconfigured on-the-fly.</p>
    <p>In the API of Megaco, a user can explicitly send action
      requests, but generating transaction identifiers, the
      encoding, and actual transport of the message to the remote user
      is handled automatically by the protocol engine according to the
      actual connection configuration. Megaco messages are not exposed
      in the API.</p>
    <p>On the receiving side, the transport module receives the message
      and forwards it to the protocol engine, which decodes it and
      invokes user callback functions for each transaction. When a
      user has handled its action requests, it simply returns a list
      of action replies (or a message error). The protocol engine
      uses the encoding module and transport module to compose and
      forward the message to the originating user.</p>
    <p>The protocol stack also handles things like automatic
      sending of acknowledgements, pending transactions, resending
      messages, and supervision of connections.</p>
    <p>To provide a solution for scalable implementations of
      MGs and MGCs, a user can be distributed over several Erlang
      nodes. One of the Erlang nodes is connected to the physical
      network interface, but messages can be sent from other nodes and
      the replies are automatically forwarded back to the originating
      node.</p>
  </section>

  <section>
    <title>Single Node Config</title>
    <p>The following figure shows a system configuration with an MG and MGC
      residing in one Erlang node:</p>
    <image file="single_node_config.gif">
      <icaption>Single Node Config</icaption>
    </image>
  </section>

  <section>
    <title>Distributed Config</title>
    <p>In a larger system with a user (in this case an MGC)
      distributed over several Erlang nodes, it looks a bit different,
      see the following figure.</p>
    <image file="distr_node_config.gif">
      <icaption>Distributes node config</icaption>
    </image>
    <list type="bulleted">
      <item>
        <p>Here the encoding is performed on the originating
          Erlang node (1).</p>
        <p>The binary is forwarded to node 2 with
          the physical network interface.</p>
        <p>When the potential message reply
          is received on the interface on node 2, it is decoded there,
          and then different actions are taken for each transaction in
          the message.</p>
        <p>The transaction reply is forwarded in its
          decoded form to the originating node (1) while the other types
          of transactions are handled locally on node 2.</p>
      </item>
    </list>
    <p>Timers and resend of messages are handled locally on
      one node, that is node 1, to avoid unnecessary
      data transfer between the Erlang nodes.</p>
  </section>

  <section>
    <title>Message Round-Trip Call Flow</title>
    <p>The typical round-trip of a message can be viewed as
      follows. First, we view the call flow on the originating
      side:</p>
    <image file="call_flow.gif">
      <icaption>Message Call Flow - Originating Side</icaption>
    </image>
    <p>Then we continue with the call flow on the destination
      side:</p>
    <image file="call_flow_cont.gif">
      <icaption>Message Call Flow - Destination Side</icaption>
    </image>
  </section>
</chapter>

