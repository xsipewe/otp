<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>2000</year><year>2016</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.

    </legalnotice>

    <title>megaco_user</title>
    <prepared>H&aring;kan Mattsson</prepared>
    <responsible>H&aring;kan Mattsson</responsible>
    <docno></docno>
    <approved>H&aring;kan Mattsson</approved>
    <checked></checked>
    <date>2016-12-14</date>
    <rev>%VSN%</rev>
    <file>megaco_user.xml</file>
  </header>
  <module>megaco_user</module>
  <modulesummary>Callback module for users of the Megaco application.
  </modulesummary>
  <description>
    <p>This module defines the callback behavior of Megaco users.
      The functions in this module must be exported from a
      <c>megaco_user</c>-compliant callback module.</p>
    <p>The <c><![CDATA[user_args]]></c> configuration parameter can be
      used to extend the argument list of the callback functions. For example,
      the <c>handle_connect</c> function takes by default two arguments:</p>
    <code type="none"><![CDATA[
handle_connect(Handle, Version)
    ]]></code>
    <p>However, if parameter <c><![CDATA[user_args]]></c> is set to a longer
      list, such as <c><![CDATA[[SomePid,SomeTableRef]]]></c>, the callback
      function is expected to have these (in this case two) extra
      arguments last in the argument list:</p>
    <code type="none"><![CDATA[
handle_connect(Handle, Version, SomePid, SomeTableRef)
    ]]></code>
    <marker id="extra_argument"></marker>
    <note>
      <p>Must of the functions in this module have an optional <c>Extra</c>
        argument, for example, <seealso marker="#unexpected_trans">
        <c>handle_unexpected_trans/4</c></seealso>. The functions that takes
        this argument are called if and only if one functions
        <seealso marker="megaco#receive_message">
        <c>megaco:receive_message/5</c></seealso> or
        <seealso marker="megaco#process_received_message">
        <c>megaco:process_received_message/5</c></seealso>
        was called with argument <c>Extra</c> different than
        <c>ignore_extra</c>.</p>
    </note>
  </description>

  <datatypes>
    <datatype>
      <name name="action_reply() = #'ActionReply'{}"/>
    </datatype>
    <datatype>
      <name name="action_request() = #'ActionRequest'{}"/>
    </datatype>
    <datatype>
      <name name="conn_handle() = #megaco_conn_handle{}"/>
      <desc>
        <p>The record initially returned by
          <seealso marker="megaco#connect/4">
          <c>megaco:connect/4,5</c></seealso>.
          It identifies a "virtual" connection and can be reused after a
          reconnect (disconnect + connect).</p>
      </desc>
    </datatype>
    <datatype>
      <name name="error_desc() = #'ErrorDescriptor'{}"/>
    </datatype>
    <datatype>
      <name name="protocol_version() = integer()"/>
      <desc>
        <p>The actual protocol version. In most cases the protocol
          version is retrieved from the processed message, but there
          are exceptions:</p>
        <list type="bulleted">
          <item>When <seealso marker="#handle_connect/2">
            <c>handle_connect/2,3</c></seealso> is triggered by an
            explicit call to <seealso marker="megaco#connect/4">
            <c>megaco:connect/4,5</c></seealso>.</item>
          <item><seealso marker="#handle_disconnect/3">
            <c>handle_disconnect/3</c></seealso></item>
          <item><seealso marker="#handle_syntax_error/3">
            <c>handle_syntax_error/3</c></seealso></item>
        </list>
        <p>In these cases, the <c>ProtocolVersion</c> default version is
          obtained from the static connection configuration:</p>
        <list type="bulleted">
          <item>
            <seealso marker="megaco#conn_info/1">
            <c>megaco:conn_info(ConnHandle, protocol_version)</c></seealso>
          </item>
        </list>
      </desc>
    </datatype>
    <datatype>
      <name name="segment_no() = integer()"/>
      <desc><marker id="connect"></marker></desc>
    </datatype>
  </datatypes>

  <funcs>
    <func>
      <name>handle_connect(ConnHandle, ProtocolVersion)
        -> ok | error | {error,ErrorDescr}</name>
      <name>handle_connect(ConnHandle, ProtocolVersion, Extra])
         -> ok | error | {error,ErrorDescr}</name>
      <fsummary>Invoked when a new connection is established.</fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
        <v>ProtocolVersion = protocol_version()</v>
        <v>ErrorDescr = error_desc()</v>
        <v>Extra = term()</v>
      </type>
      <desc>
        <p>Invoked when a new connection is established.</p>
        <p>Connections can either be established by an explicit call to
          <seealso marker="megaco#connect/4"><c>megaco:connect/4</c></seealso>
          or implicitly at the first invocation of
          <seealso marker="megaco#receive_message/4">
          <c>megaco:receive_message/4</c></seealso>.</p>
        <p>Normally a Media Gateway (MG) connects explicitly while a Media
          Gateway Controller (MGC) connects implicitly.</p>
        <p>At the Media Gateway Controller (MGC) side it is possible to reject
          a connection request (and send a message error reply to the gateway)
          by returning <c><![CDATA[{error, ErrorDescr}]]></c> or simply
          <c><![CDATA[error]]></c>. This
          generates an error descriptor with code 402 (unauthorized) and
          reason <c>Connection refused by user</c> (this is also the case
          for all unknown results, such as exit signals or throw).</p>
	<p>For argument <c>Extra</c> in <c>handle_connect/3</c>, see the
          <seealso marker="#extra_argument">Note</seealso> earlier.</p>
	<p><c><![CDATA[handle_connect/3]]></c> (with <c><![CDATA[Extra]]></c>)
          can also be called as a result of a call to the
          <seealso marker="megaco#connect">
          <c>megaco:connect/5</c></seealso> function
          (if that function is called with argument
          <c>Extra</c> different than <c>ignore_extra</c>.</p>
        <marker id="disconnect"></marker>
      </desc>
    </func>

    <func>
      <name>handle_disconnect(ConnHandle, ProtocolVersion, Reason) -> ok</name>
      <fsummary>Invoked when a connection is teared down.</fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
        <v>ProtocolVersion = protocol_version()</v>
        <v>Reason = term()</v>
      </type>
      <desc>
        <p>Invoked when a connection is teared down.</p>
        <p>The disconnect can either be made explicitly by a call to
          <seealso marker="megaco#disconnect/2">
          <c>megaco:disconnect/2</c></seealso> or implicitly when the
          control process of the connection dies.</p>
        <marker id="syntax_error"></marker>
      </desc>
    </func>

    <func>
      <name>handle_syntax_error(ReceiveHandle, ProtocolVersion, DefaultED)
        -> reply | {reply, ED} | no_reply | {no_reply, ED} </name>
      <name>handle_syntax_error(ReceiveHandle, ProtocolVersion, DefaultED,
        Extra) -> reply | {reply, ED} | no_reply | {no_reply, ED}</name>
      <fsummary>Invoked when a received message has syntax errors.</fsummary>
      <type>
        <v>ReceiveHandle = receive_handle()</v>
        <v>ProtocolVersion = protocol_version()</v>
        <v>DefaultED = error_desc()</v>
        <v>ED = error_desc()</v>
        <v>Extra = term()</v>
      </type>
      <desc>
        <p>Invoked when a received message has syntax errors.</p>
        <p>Incoming messages are delivered by
          <seealso marker="megaco#receive_message/4">
          <c>megaco:receive_message/4</c></seealso>
          and normally decoded successfully. If the decoding
          fails, this function is called to decide if the
          originator is to get a reply message (<c>reply</c>) or if the reply
          silently is to be discarded (<c>no_reply</c>).</p>
        <p>Syntax errors are detected locally on this side of the
          protocol and can have many causes, for example, malfunctioning
          transport layer, wrong encoder/decoder selected, or bad
          configuration of the selected encoder/decoder.</p>
        <p>The error descriptor defaults to <c><![CDATA[DefaultED]]></c>,
          but can be overridden with an alternate one by returning
          <c><![CDATA[{reply,ED}]]></c> or <c><![CDATA[{no_reply,ED}]]></c>
          instead of <c><![CDATA[reply]]></c> and <c><![CDATA[no_reply]]></c>
          respectively.</p>
        <p><c><![CDATA[DefaultED]]></c> is used for
          any other return values (including exit signals or throw).</p>
	<p>For argument <c>Extra</c> in <c>handle_syntax_error/4</c>,
          see the <seealso marker="#extra_argument">Note</seealso> earlier.</p>
        <marker id="message_error"></marker>
      </desc>
    </func>

    <func>
      <name>handle_message_error(ConnHandle, ProtocolVersion, ErrorDescr) -> ok
      </name>
      <name>handle_message_error(ConnHandle, ProtocolVersion, ErrorDescr, Extra)
        -> ok</name>
      <fsummary>Invoked when a received message only contains an error.
      </fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
        <v>ProtocolVersion = protocol_version()</v>
        <v>ErrorDescr = error_desc()</v>
        <v>Extra = term()</v>
      </type>
      <desc>
        <p>Invoked when a received message only contains an error
          instead of a list of transactions.</p>
        <p>Incoming messages are delivered by
          <seealso marker="megaco#receive_message/4">
          <c>megaco:receive_message/4</c></seealso>
          and successfully decoded. Normally a message contains a list
          of transactions, but it can instead contain an
          <c>ErrorDescriptor</c> on the top level of the message.</p>
        <p>Message errors are detected remotely on the other side of
          the protocol. You probably do not need to reply to it,
          but it can indicate that you have outstanding transactions
          that will get no response (request -&gt; reply; reply -&gt;
          ack).</p>
	<p>For argument <c>Extra</c> in <c>handle_message_error/4</c>, see the
          <seealso marker="#extra_argument">Note</seealso> earlier.</p>
<!--    <marker id="segment_error"></marker> -->
        <marker id="trans_request"></marker>
      </desc>
    </func>

<!--
    <func>
      <name>handle_segment_error(ConnHandle, ProtocolVersion, TransId,
        SegmentError) -> ok</name>
      <name>handle_segment_error(ConnHandle, ProtocolVersion, TransId,
        SegmentError, Extra) -> ok</name>
      <fsummary>Invoked when a segment error has been detected.</fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
        <v>ProtocolVersion = protocol_version()</v>
        <v>TransId = integer()</v>
        <v>SegmentError = {missing_segments, [integer()]}</v>
        <v>Extra = term()</v>
      </type>
      <desc>
        <p>Invoked when a segment error has been detected.</p>
        <p><c><![CDATA[missing_segments]]></c> means that one or more
          segments of a segmented message were not received in time.</p>
	<p>For argument <c>Extra</c> in <c>handle_segement_error/5</c>, see the
          <seealso marker="#extra_argument">Note</seealso> earlier.</p>
        <marker id="trans_request"></marker>
      </desc>
    </func>
-->

    <func>
      <name>handle_trans_request(ConnHandle, ProtocolVersion, ActionRequests)
        -> pending() | reply() | ignore_trans_request</name>
      <name>handle_trans_request(ConnHandle, ProtocolVersion, ActionRequests,
        Extra) -> pending() | reply() | ignore_trans_request</name>
      <fsummary>Invoked for each transaction request.</fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
        <v>ProtocolVersion = protocol_version()</v>
        <v>ActionRequests = [action_request()]</v>
        <v>Extra = term()</v>
        <v>pending() = {pending, req_data()}</v>
        <v>req_data() = term()</v>
        <v>reply() = {ack_action(), actual_reply()}
          | {ack_action(), actual_reply(), send_options()} </v>
        <v>ack_action() = discard_ack | {handle_ack, ack_data()}
          | {handle_pending_ack, ack_data()}
          | {handle_sloppy_ack, ack_data()}</v>
        <v>actual_reply() = [action_reply()] | error_desc()</v>
        <v>ack_data() = term()</v>
        <v>send_options() = [send_option()]</v>
        <v>send_option() = {reply_timer, megaco_timer()}
          | {send_handle, term()} | {protocol_version, integer()}</v>
        <v>Extra = term()</v>
      </type>
      <desc>
        <p>Invoked for each transaction request.</p>
        <p>Incoming messages are delivered by
          <seealso marker="megaco#receive_message/4">
          <c>megaco:receive_message/4</c></seealso>
          and successfully decoded. Normally a message contains a list
          of transactions and this function is invoked for each
          <c>TransactionRequest</c> in the message.</p>
        <p>This function takes a list of <c>ActionRequest</c> records and
          has three main options:</p>
        <taglist>
          <tag><c><![CDATA[Return ignore_trans_request]]></c></tag>
          <item>
            <p>Decide that these action requests shall be ignored
              completely.</p>
          </item>
          <tag><c><![CDATA[Return pending()]]></c></tag>
          <item>
            <p>Decides that the processing of these action requests
              will take a long time and that the originator is to get
              an immediate <c>TransactionPending</c> reply as interim
              response. The actual processing of these action requests
              is instead to be delegated to the
              <seealso marker="#handle_trans_long_request/3">
              <c>handle_trans_long_request/3</c></seealso> callback function
              with <c>req_data()</c> as one of its arguments.</p>
          </item>
          <tag><c><![CDATA[Return reply()]]></c></tag>
          <item>
            <p>Processes the action requests and either returns an
              <c>error_descr()</c> indicating some fatal error or a list of
              action replies (wildcarded or not).</p>
            <p>If Megaco for some reason is unable to deliver the reply,
              the reason for this will be passed to the user through a call
              to the callback function
              <seealso marker="#trans_ack">
              <c>handle_trans_ack/4,5</c></seealso>,
              unless <c><![CDATA[ack_action() = discard_ack]]></c>.</p>
            <p><c>ack_action()</c> is one of the following:</p>
            <taglist>
              <tag><c><![CDATA[discard_ack]]></c></tag>
              <item>
                <p>This means that you do not care if the reply is
                  acknowledged or not.</p>
              </item>
              <tag><c><![CDATA[{handle_ack, ack_data()}
                | {handle_ack, ack_data(), send_options()}]]></c></tag>
              <item>
                <p>This means that you want an immediate acknowledgement
                  when the other part receives this transaction
                  reply. When the acknowledgement eventually is
                  received, the <seealso marker="#trans_ack">
                  <c>handle_trans_ack/4,5</c></seealso> callback function
                  will be invoked with <c>ack_data()</c> as one of its
                  arguments. <c>ack_data()</c> can be any Erlang term.</p>
              </item>
              <tag><c><![CDATA[{handle_pending_ack, ack_data()}
                | {handle_pending_ack, ack_data(), send_options()}]]></c></tag>
              <item>
                <p>This has the same effect as the above,
                  <em>if and only if</em> Megaco has sent at least one
                  pending message for this request (during the processing
                  of the request). If no pending message has been sent, then
                  immediate acknowledgement will <em>not</em> be requested.</p>
                <p>Notice that this only works as specified if config option
                  <c><![CDATA[sent_pending_limit]]></c> has been set to
                  an integer value.</p>
              </item>
              <tag><c><![CDATA[{handle_sloppy_ack, ack_data()}
                | {handle_sloppy_ack, ack_data(), send_options()}]]></c></tag>
              <item>
                <p>This means that you want an acknowledgement
                  <em>sometime</em>.
                  When the acknowledgement eventually is received, the
                  <seealso marker="#trans_ack">
                  <c>handle_trans_ack/4,5</c></seealso> callback function
                  will be invoked with <c>ack_data()</c> as one of its
                  arguments. <c>ack_data()</c> can be any Erlang term.</p>
              </item>
            </taglist>
          </item>
        </taglist>
        <p>Any other return value (including exit signals or throw)
          results in an error descriptor with code 500 (internal gateway error)
          and the module name (of the callback module) as reason.</p>
	<p>For argument <c>Extra</c> in <c>handle_trans_request/4</c>, see the
          <seealso marker="#extra_argument">Note</seealso> earlier.</p>
        <marker id="trans_long_request"></marker>
      </desc>
    </func>

    <func>
      <name>handle_trans_long_request(ConnHandle, ProtocolVersion, ReqData)
        -> reply()</name>
      <name>handle_trans_long_request(ConnHandle, ProtocolVersion, ReqData,
        Extra) -> reply()</name>
      <fsummary>Optionally invoked for a time-consuming transaction request.
      </fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
        <v>ProtocolVersion = protocol_version()</v>
        <v>ReqData = req_data()</v>
        <v>Extra = term()</v>
        <v>req_data() = term()</v>
        <v>reply() = {ack_action(), actual_reply()}
          | {ack_action(), actual_reply(), send_options()}</v>
        <v>ack_action() = discard_ack | {handle_ack, ack_data()}
          | {handle_sloppy_ack, ack_data()}</v>
        <v>actual_reply() = [action_reply()] | error_desc()</v>
        <v>ack_data() = term()</v>
        <v>send_options() = [send_option()]</v>
        <v>send_option() = {reply_timer, megaco_timer()}
          | {send_handle, term()} | {protocol_version, integer()}</v>
        <v>Extra = term()</v>
      </type>
      <desc>
        <p>Optionally invoked for a time-consuming transaction request.</p>
        <p>If this function is invoked or is not controlled by the
          reply from the preceding call to
          <seealso marker="#handle_trans_request/3">
          <c>handle_trans_request/3</c></seealso>.
          The <c>handle_trans_request/3</c> function can decide to process
          the action requests itself or to delegate the processing to
          this function.</p>
        <p>Argument <c>req_data()</c> to this function is the Erlang term
          returned by <c>handle_trans_request/3</c>.</p>
        <p>Any other return value (including exit signals or throw)
          result in an error descriptor with code 500 (internal gateway error)
          and the module name (of the callback module) as reason.</p>
	<p>For argument <c>Extra</c> in <c>handle_trans_long_request/4</c>,
          see the <seealso marker="#extra_argument">Note</seealso> earlier.</p>
        <marker id="trans_reply"></marker>
      </desc>
    </func>

    <func>
      <name>handle_trans_reply(ConnHandle, ProtocolVersion, UserReply,
        ReplyData) -> ok</name>
      <name>handle_trans_reply(ConnHandle, ProtocolVersion, UserReply,
        ReplyData, Extra) -> ok</name>
      <fsummary>Optionally invoked for a transaction reply.</fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
        <v>ProtocolVersion = protocol_version()</v>
        <v>UserReply = success() | failure()</v>
        <v>success() = {ok, result()} </v>
        <v>result() = transaction_result() | segment_result()</v>
        <v>transaction_result() = action_reps()</v>
        <v>segment_result() = {segment_no(), last_segment(), action_reps()}</v>
        <v>action_reps() = [action_reply()]</v>
        <v>failure() = {error, reason()} | {error, ReplyNo, reason()}</v>
        <v>reason() = transaction_reason() | segment_reason()
          | user_cancel_reason() | send_reason() | other_reason()</v>
        <v>transaction_reason() = error_desc()</v>
        <v>segment_reason() = {segment_no(), last_segment(), error_desc()}</v>
        <v>other_reason() = timeout | {segment_timeout, missing_segments()}
          | exceeded_recv_pending_limit | term()</v>
        <v>last_segment() = bool()</v>
        <v>missing_segments() = [segment_no()]</v>
        <v>user_cancel_reason() = {user_cancel, reason_for_user_cancel()}</v>
        <v>reason_for_user_cancel() = term()</v>
        <v>send_reason() = send_cancelled_reason() | send_failed_reason()</v>
        <v>send_cancelled_reason() = {send_message_cancelled,
          reason_for_send_cancel()}</v>
        <v>reason_for_send_cancel() = term()</v>
        <v>send_failed_reason() = {send_message_failed,
          reason_for_send_failure()}</v>
        <v>reason_for_send_failure() = term()</v>
        <v>ReplyData = reply_data()</v>
        <v>ReplyNo = integer() > 0</v>
        <v>reply_data() = term()</v>
        <v>Extra = term()</v>
      </type>
      <desc>
        <p>Optionally invoked for a transaction reply.</p>
        <p>The sender of a transaction request can decide
          whether the originating Erlang process is to
          synchronously wait (<c><![CDATA[megaco:call/3]]></c>)
          for a reply, or if the message is to be sent asynchronously
          (<c><![CDATA[megaco:cast/3]]></c>) and
          the processing of the reply is to be delegated this
          callback function.</p>
        <p>Notice that if the reply is segmented (split into several smaller
          messages; segments), then some extra information, segment number and
          an indication if all segments of a reply have been received or
          not, is also included in <c><![CDATA[UserReply]]></c>.</p>
        <p><c><![CDATA[ReplyData]]></c> defaults to
          <c><![CDATA[megaco:lookup(ConnHandle, reply_data)]]></c>,
          but can be explicitly overridden by a
          <c><![CDATA[megaco:cast/3]]></c> option to forward information
          about the calling context of the originating process.</p>
        <p>At <c><![CDATA[success()]]></c>, <c><![CDATA[UserReply]]></c>
          contains either of the following:</p>
        <list type="bulleted">
          <item>
            <p>A list of <c>ActionReply</c> records possibly containing
              error indications.</p>
          </item>
          <item>
            <p>A 3-tuple containing the segment number,
              the <c><![CDATA[last segment indicator]]></c>, and
              a list of <c>ActionReply</c> records possibly containing error
              indications. This is clearly only possible if the
              reply was segmented.</p>
          </item>
        </list>
        <p><c><![CDATA[failure()]]></c> indicates a local or an external
          error and can be one of the following:</p>
        <list type="bulleted">
          <item>
            <p>A <c><![CDATA[transaction_reason()]]></c> indicating that the
              remote user has replied with an explicit <c>transactionError</c>
            .</p>
          </item>
          <item>
            <p>A <c><![CDATA[segment_reason()]]></c> indicating that the remote
              user has replied with an explicit <c>transactionError</c> for
              this segment. This is clearly only possible if the reply was
              segmented.</p>
          </item>
          <item>
            <p>A <c><![CDATA[user_cancel_reason()]]></c> indicating that the
              request has been canceled by the user.
              <c><![CDATA[reason_for_user_cancel()]]></c>
              is the reason specified in the call to the
              <seealso marker="megaco#cancel"><c>megaco:cancel/2</c></seealso>
              function.</p>
          </item>
          <item>
            <p>A <c><![CDATA[send_reason()]]></c> indicating that the
              <seealso marker="megaco_transport#send_message">
              <c>megaco_transport:send_message</c></seealso> function
              did not send the message. The reason for this can be either
              of the following:</p>
            <list type="bulleted">
              <item>
                <p><c><![CDATA[send_cancelled_reason()]]></c> - The message
                  sending was deliberately cancelled.
                  <c><![CDATA[reason_for_send_cancel()]]></c>
                  is the reason specified in the <c><![CDATA[cancel]]></c>
                  return from the
                  <seealso marker="megaco_transport#send_message">
                  <c>megaco_transport:send_message/2,3</c></seealso>
                  function.</p>
              </item>
              <item>
                <p><c><![CDATA[send_failed_reason()]]></c> - An error occurred
                  while attempting to send the message.</p>
              </item>
            </list>
          </item>
          <item>
            <p>An <c><![CDATA[other_reason()]]></c> indicating some other
              error, for example:</p>
            <list type="bulleted">
              <item>
                <p><c><![CDATA[timeout]]></c> - The reply failed to arrive
                  before the request timer expired.</p>
              </item>
              <item>
                <p><c><![CDATA[{segment_timeout, missing_segments()}]]></c> -
                  One or more segments were
                  not delivered before the expire of the segment timer.</p>
              </item>
              <item>
                <p><c><![CDATA[exceeded_recv_pending_limit]]></c> - The pending
                  limit was exceeded for this request.</p>
              </item>
            </list>
          </item>
        </list>
	<p>For argument <c>Extra</c> in <c>handle_trans_reply/5</c>, see the
          <seealso marker="#extra_argument">Note</seealso> earlier.</p>
        <marker id="trans_ack"></marker>
      </desc>
    </func>

    <func>
      <name>handle_trans_ack(ConnHandle, ProtocolVersion, AckStatus, AckData)
        -> ok</name>
      <name>handle_trans_ack(ConnHandle, ProtocolVersion, AckStatus, AckData,
        Extra) -> ok</name>
      <fsummary>Optionally invoked for a transaction acknowledgement.</fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
        <v>ProtocolVersion = protocol_version()</v>
        <v>AckStatus = ok | {error, reason()}</v>
        <v>reason() = user_cancel_reason() | send_reason() | other_reason()</v>
        <v>user_cancel_reason() = {user_cancel, reason_for_user_cancel()}</v>
        <v>send_reason() = send_cancelled_reason() | send_failed_reason()</v>
        <v>send_cancelled_reason() =
          {send_message_cancelled, reason_for_send_cancel()}</v>
        <v>reason_for_send_cancel() = term()</v>
        <v>send_failed_reason() = {send_message_failed,
          reason_for_send_failure()}</v>
        <v>reason_for_send_failure() = term()</v>
        <v>other_reason() = term()</v>
        <v>AckData = ack_data()</v>
        <v>ack_data() = term()</v>
        <v>Extra = term()</v>
      </type>
      <desc>
        <p>Optionally invoked for a transaction acknowledgement.</p>
        <p>Whether this function is invoked or not is controlled by the
          reply from the preceding call to
          <seealso marker="#handle_trans_request/3">
          <c>handle_trans_request/3</c></seealso>.
          The <c>handle_trans_request/3</c> function can decide to return
          <c>{handle_ack, ack_data()}</c> or
          <c>{handle_sloppy_ack, ack_data()}</c>, which
          means that you need an immediate acknowledgement of the
          reply and that this function is to be invoked to handle the
          acknowledgement.</p>
        <p>Argument <c>ack_data()</c> to this function is the Erlang term
          returned by <c>handle_trans_request/3</c>.</p>
        <p>If <c>AckStatus</c> is OK, it indicates that this is a
          true acknowledgement of the transaction reply.</p>
        <p>If <c>AckStatus</c> is <c>{error, Reason}</c>, it indicates that
          the acknowledgement or even the reply (for which this is an
          acknowledgement) was not delivered, but there is no point to
          wait for it to arrive. This occurs in the following situations:</p>
        <list type="bulleted">
          <item>The <c><![CDATA[reply_timer]]></c> eventually times out.</item>
          <item>Megaco fails to send the reply (see
            <seealso marker="#trans_reply"><c>handle_trans_reply</c></seealso>) 
            for whatever reason.</item>
          <item>The user has explicitly cancelled the wait
            <seealso marker="megaco#cancel/2"><c>megaco:cancel/2</c></seealso>.
          </item>
        </list>
	<p>For argument <c>Extra</c> in <c>handle_trans_ack/5</c>, see the
          <seealso marker="#extra_argument">Note</seealso> earlier.</p>
        <marker id="unexpected_trans"></marker>
        <marker id="handle_unexpected_trans"></marker>
      </desc>
    </func>

    <func>
      <name>handle_unexpected_trans(ConnHandle, ProtocolVersion, Trans) -> ok
      </name>
      <name>handle_unexpected_trans(ConnHandle, ProtocolVersion, Trans, Extra)
        -> ok</name>
      <fsummary>Invoked when an unexpected message is received.</fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
        <v>ProtocolVersion = protocol_version()</v>
        <v>Trans = #'TransactionPending'{} | #'TransactionReply'{}
          | #'TransactionResponseAck'{}</v>
        <v>Extra = term()</v>
      </type>
      <desc>
        <p>Invoked when an unexpected message is received.</p>
        <p>If a reply to a request is not received in time, the
          Megaco stack removes all information about the request from
          its tables. If a reply arrives after this has been
          done, the application has no way of knowing where to send this
          message. The message is delivered to the "user" by calling this
          function on the local node (the node that has the link).</p>
	<p>For argument <c>Extra</c> in <c>handle_unexpected_trans/4</c>,
          see the <seealso marker="#extra_argument">Note</seealso> earlier.</p>
        <marker id="request_abort"></marker>
      </desc>
    </func>

    <func>
      <name>handle_trans_request_abort(ConnHandle, ProtocolVersion, TransNo,
        Pid) -> ok</name>
      <name>handle_trans_request_abort(ConnHandle, ProtocolVersion, TransNo,
        Pid, Extra) -> ok</name>
      <fsummary>Invoked when a transaction request has been aborted.</fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
        <v>ProtocolVersion = protocol_version()</v>
        <v>TransNo = integer()</v>
        <v>Pid = undefined | pid()</v>
        <v>Extra = term()</v>
      </type>
      <desc>
        <p>Invoked when a transaction request has been aborted.</p>
        <p>This function is invoked if the originating pending limit
          is exceeded. This usually means that a request has taken
          abnormally long time to complete.</p>
	<p>For argument <c>Extra</c> in <c>handle_trans_request_abort/5</c>,
          see the <seealso marker="#extra_argument">Note</seealso> earlier.</p>
        <marker id="segment_reply"></marker>
      </desc>
    </func>

    <func>
      <name>handle_segment_reply(ConnHandle, ProtocolVersion, TransNo, SegNo,
        SegCompl) -> ok</name>
      <name>handle_segment_reply(ConnHandle, ProtocolVersion, TransNo, SegNo,
        SegCompl, Extra) -> ok</name>
      <fsummary>Segment reply indication.</fsummary>
      <type>
        <v>ConnHandle = conn_handle()</v>
        <v>ProtocolVersion = protocol_version()</v>
        <v>TransNo = integer()</v>
        <v>SegNo = integer()</v>
        <v>SegCompl = asn1_NOVALUE | 'NULL'</v>
        <v>Extra = term()</v>
      </type>
      <desc>
        <p>This function is called when a segment reply has been received
          if config option <seealso marker="megaco#conn_info">
          <c>segment_reply_ind</c></seealso> has been set to <c>true</c>.</p>
        <p>This is in effect a progress report.</p>
	<p>For argument <c>Extra</c> in <c>handle_segment_reply/6</c>, see the
          <seealso marker="#extra_argument">Note</seealso> above.</p>
      </desc>
    </func>
  </funcs>

</erlref>

