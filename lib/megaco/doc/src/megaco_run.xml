<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE chapter SYSTEM "chapter.dtd">

<chapter>
  <header>
    <copyright>
      <year>2000</year><year>2016</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.

    </legalnotice>

    <title>Running the Stack</title>
    <prepared>H&aring;kan Mattsson</prepared>
    <responsible>H&aring;kan Mattsson</responsible>
    <docno></docno>
    <approved>H&aring;kan Mattsson</approved>
    <checked></checked>
    <date>2016-12-12</date>
    <rev>%VSN%</rev>
    <file>megaco_run.xml</file>
  </header>

  <section>
    <marker id="starting"></marker>
    <title>Starting</title>
    <p>A user can have a number of "virtual" connections to other
      users. An MG is connected to at most one MGC, while an MGC can
      be connected to any number of MGs. For each connection the user
      selects a transport service, an encoding scheme, and a user
      callback module.</p>
    <p>An MGC must initiate its transport service to listen
      to MGs trying to connect. How the actual transport is initiated
      is outside the scope of this application. However, a send handle
      (typically a socket ID, or host and port) must be provided from
      the transport service to enable us to send the message
      to the correct destination. We do however not assume anything
      about this, from our point of view, opaque handle. Hopefully it
      is small, as it will pass around the system between
      processes frequently.</p>
    <p>A user can either be statically configured in a config file
      according to the application concept of Erlang/OTP, or
      dynamically started with the configuration settings as arguments to
      <seealso marker="megaco#start_user/2">
      <c>megaco:start_user/2</c></seealso>.
      These configuration settings can be updated later with
      <seealso marker="megaco#update_conn_info/3">
      <c>megaco#update_conn_info/3</c></seealso>.</p>
    <p>The <seealso marker="megaco#connect/4">
      <c>megaco#connect/4</c></seealso> function is used to tell the Megaco
      application about which control process it is to supervise,
      which Message Identifier (MID) the remote user has, which callback
      module it is to
      use to send messages, and so on. When this "virtual" connection is
      established, the user can use
      <seealso marker="megaco#call/3">
      <c>megaco#call/3</c></seealso> and
      <seealso marker="megaco#cast/3">
      <c>megaco#cast/3</c></seealso>
      to send messages to the other side. It is then up to the
      MG to send its first Service Change Request message after
      applying some clever algorithm to fight the problem
      with startup avalanche (as discussed in the RFC).</p>
    <p>The originating user waits for a reply or a time-out
      (defined by the <c>request_timer</c>). When it receives the reply,
      this is optionally acknowledged (regulated by <c>auto_ack</c>), and
      forwarded to the user. If an interim pending reply is received,
      the <c>long_request_timer</c> is used instead of the usual
      <c>request_timer</c> to avoid spurious resends
      of the request.</p>
    <p>On the destination side the transport service waits for
      messages. Each message is forwarded to the Megaco application
      through the <seealso marker="megaco#receive_message/4">
      <c>megaco:receive_message/4</c></seealso> callback function. The
      transport service either provides or does not provide
      means for blocking and
      unblocking the reception of the incoming messages.</p>
    <p>If a message is received before the "virtual" connection is
      established, the connection is set up automatically. An
      MGC can be real open-minded and dynamically decide which
      encoding and transport service to use, depending on how the
      transport layer contact is performed. For IP transports two
      ports are standardized, one for textual encoding and one for
      binary encoding. If, for example, an UDP packet is received on
      the text port, it can be possible to decide encoding and
      transport on-the-fly.</p>
    <p>After decoding a message various user callback functions are
      invoked to allow the user to act properly. For more information
      about the callback arguments, see the
      <seealso marker="megaco_user"><c>megaco_user</c></seealso>
      module.</p>
    <p>When the user has processed a transaction request in its
      callback function, the Megaco application assembles a
      transaction reply, encodes it using the selected encoding module,
      and sends the message back by invoking the callback
      function:</p>
    <list type="bulleted">
      <item><c>SendMod:send_message(SendHandle, ErlangBinary)</c>
      </item>
    </list>
    <p>Resend of messages, handling pending transactions,
      acknowledgements, and so on, is handled automatically by the Megaco
      application, but the user is free to override the default
      behavior by the various configuration possibilities, see
      <seealso marker="megaco#update_user_info/2">
      <c>megaco#update_user_info/2</c></seealso> and
      <seealso marker="megaco#update_conn_info/2">
      <c>megaco#update_conn_info/2</c></seealso>.</p>
    <p>When connections gets broken (that is, explicitly by
      <seealso marker="megaco#disconnect/2">
      <c>megaco:disconnect/2</c></seealso>
      or when its controlling process dies), a user
      callback function is invoked to allow the user to
      re-establish the connection. The internal state of kept
      messages, resend timers, and so on, is not affected by this. A few
      resends do of course fail while the connection is down, but
      the automatic resend algorithm does not bother about this.
      Eventually when the connection is up and running, the messages
      are delivered if the time-outs are set to be long enough. The
      user has the option of explicitly invoking
      <seealso marker="megaco#cancel/2">
      <c>megaco:cancel/2</c></seealso>
      to cancel all messages for a connection.</p>
  </section>

  <section>
    <marker id="mgc_startup_call_flow"></marker>
    <title>Media Gateway Controller Startup Call Flow</title>
    <p>To prepare the MGC for the reception of the initial
      message, hopefully a Service Change Request, the following must
      be done:</p>
    <list type="bulleted">
      <item>
        <p>Start the Megaco application.</p>
      </item>
      <item>
        <p>Start the MGC user. This can either be done explicitly with
          <seealso marker="megaco#start_user/2">
          <c>megaco:start_user/2</c></seealso>
          or implicitly by providing the -megaco
          users configuration parameter.</p>
      </item>
      <item>
        <p>Initiate the transport service and provide it with a
          receive handle obtained from
          <seealso marker="megaco#user_info/2">
          <c>megaco:user_info/2</c></seealso>.</p>
      </item>
    </list>
    <p>When the initial message arrives, the transport service
      forwards it to the protocol engine, which automatically
      sets up the connection and invokes <c>UserMod:handle_connect/2</c>
      before it invokes <c>UserMod:handle_trans_request/3</c> with
      the Service Change Request as follows:</p>
    <image file="MGC_startup_call_flow.gif">
      <icaption>MGC Startup Call Flow</icaption>
    </image>
  </section>

  <section>
    <marker id="mg_startup_call_flow"></marker>
    <title>Media Gateway Startup Call Flow</title>
    <p>To prepare the MG for the sending of the initial
      message, hopefully a Service Change Request, the following must
      be done:</p>
    <list type="bulleted">
      <item>
        <p>Start the Megaco application.</p>
      </item>
      <item>
        <p>Start the MG user. This can either be done explicitly with
          <seealso marker="megaco#start_user/2">
          <c>megaco:start_user/2</c></seealso>
          or implicitly by providing the -megaco
          users configuration parameter.</p>
      </item>
      <item>
        <p>Initiate the transport service and provide it with a
          receive handle obtained from
          <seealso marker="megaco#user_info/2">
          <c>megaco:user_info/2</c></seealso>.</p>
      </item>
      <item>
        <p>Set up a connection to the MGC with
          <seealso marker="megaco#connect/4">
          <c>megaco:connect/4</c></seealso>
          and provide it with a receive handle obtained from
          <seealso marker="megaco#user_info/2">
          <c>megaco:user_info/2</c></seealso>.</p>
      </item>
    </list>
    <p>If the MG has been provisioned with the MID of
      the MGC, it can be specified as parameter <c>RemoteMid</c> to
      <seealso marker="megaco#connect/4">
      <c>megaco:connect/4</c></seealso>
      and the call flow looks as follows:</p>
    <image file="MG_startup_call_flow.gif">
      <icaption>MG Startup Call Flow</icaption>
    </image>
    <p>If the MG cannot be provisioned with the MID of the MGC,
      the MG can use the atom <c>preliminary_mid</c> as parameter
      <c>RemoteMid</c> to
      <seealso marker="megaco#connect/4">
      <c>megaco:connect/4</c></seealso>
      and the call flow looks as follows:</p>
    <image file="MG-startup_flow_noMID.gif">
      <icaption>MG Startup Call Flow (No MID)</icaption>
    </image>
  </section>

  <section>
    <marker id="config_megaco"></marker>
    <title>Configuring the Megaco Stack</title>
    <p>There are three kinds of configuration:</p>
    <list type="bulleted">
      <item>
        <p>User information - Related to Megaco users. Read/Write.</p>
        <p>A user is an entity identified by a MID, for example, an MGC
          or an MG.</p>
        <p>This information can be retrieved using
          <seealso marker="megaco#user_info">
          <c>megaco:user_info</c></seealso>.</p>
      </item>
      <item>
        <p>Connection information - Regarding connections. Read/Write.</p>
        <p>This information can be retrieved using
          <seealso marker="megaco#conn_info">
          <c>megaco:conn_info</c></seealso>.</p>
      </item>
      <item>
        <p>System information - System-wide information. Read only.</p>
        <p>This information can be retrieved using
          <seealso marker="megaco#system_info">
          <c>megaco:system_info</c></seealso>.</p>
      </item>
    </list>
  </section>

  <section>
    <marker id="initial_config"></marker>
    <title>Initial Configuration</title>
    <p>The initial configuration of Megaco is to be defined in the
      Erlang system configuration file. The following configuration parameters
      are defined for the Megaco application:</p>
    <list type="bulleted">
      <item>
        <p><c><![CDATA[users = [{Mid, [user_config()]}].]]></c></p>
        <p>Each user is represented by a tuple with the MID of the user and a
          list of configuration parameters (each parameter is in turn a tuple:
          <c><![CDATA[{Item, Value}]]></c>).</p>
      </item>
      <item>
        <p><c><![CDATA[scanner = flex
          | {Module, Function, Arguments, Modules}]]></c></p>
<!--
        For future use:
        <p><c><![CDATA[scanner = flex | {flex, Opts}
          | {Module, Function, Arguments, Modules}]]></c></p>
-->
        <list type="bulleted">
          <item>
            <p><c><![CDATA[flex]]></c> results in the start of the flex
              scanner with default options.</p>
          </item>
<!--
          For future use:
          <item>
            <p><c><![CDATA[{flex, Opts}]]></c> results in the start of the
              flex scanner with the specified options. <c>Opts</c> is a
              two-tuple list, where the only allowed option is
              <c>{smp, boolean()}</c>, with default value <c>false</c>
              and the value of
              <c>true</c> resulting in a start of an smp-optimized scanner.</p>
          </item>
-->
          <item>
            <p>The MFA alternative makes it possible for Megaco to start and
              supervise a scanner written by the user. For a description of
              the parameters, see section
              <c><![CDATA[supervisor:start_child]]></c>.</p>
          </item>
        </list>
      </item>
    </list>
    <p>See also <seealso marker="megaco_encode#text_config">Configuration of text encoding module(s)</seealso> 
      for more info. </p>
  </section>

  <section>
    <marker id="changing_config"></marker>
    <title>Changing the Configuration</title>
    <p>The configuration can be changed during runtime. This is done with
      the functions <seealso marker="megaco#update_user_info">
      <c>megaco:update_user_info</c></seealso> and
      <seealso marker="megaco#update_conn_info">
      <c>megaco:update_conn_info</c></seealso>.</p>
  </section>

  <section>
    <marker id="transaction_sender"></marker>
    <title>The Transaction Sender</title>
    <p>The transaction sender is a process (one per connection), which handles
      all transaction sending, if so configured (see
      <seealso marker="megaco#user_info">
      <c>megaco:user_info</c></seealso> and
      <seealso marker="megaco#conn_info">
      <c>megaco:conn_info</c></seealso>).</p>
    <p>The purpose of the transaction sender is to accumulate transactions
      for a more efficient message sending. The transactions that are
      accumulated are transaction request and transaction acknowledgement.
      For transaction acknowledgements the benefit is quite large, as the
      transactions are small and it is possible to have ranges (that is,
      transaction acknowledgements for transactions 1, 2, 3, and 4 can
      be sent as a range 1-4 in one transaction acknowledgement
      instead of four separate transactions).</p>
    <p>A number of configuration parameters control the
      operation of the transaction sender. In principle, a message with
      everything stored (acknowledgements and requests) is sent from the
      process in the following situations:</p>
    <list type="bulleted">
      <item>
        <p>When <c><![CDATA[trans_timer]]></c> expires</p>
      </item>
      <item>
        <p>When <c><![CDATA[trans_ack_maxcount]]></c> number of
          acknowledgements has been received</p>
      </item>
      <item>
        <p>When <c><![CDATA[trans_req_maxcount]]></c> number of requestss has
          been received</p>
      </item>
      <item>
        <p>When the size of all received requests exceeds
          <c><![CDATA[trans_req_maxsize]]></c></p>
      </item>
      <item>
        <p>When a reply transaction is sent</p>
      </item>
      <item>
        <p>When a pending transaction is sent</p>
      </item>
    </list>
    <p>When something is to be sent, everything is packed into one message, 
      unless the trigger was a reply transaction and the added size of the
      reply and all the requests is greater than
      <c><![CDATA[trans_req_maxsize]]></c>, in which case the stored
      transactions are sent first in a separate message and the reply in
      another message.</p>
    <p>When the transaction sender receives a request that is already
      "in storage" (indicated by the transaction ID), it is assumed to
      be a resend and everything stored is sent. This can occur if
      the values of <c><![CDATA[trans_timer]]></c> and
      <c><![CDATA[request_timer]]></c> are not chosen properly.</p>
  </section>

  <section>
    <marker id="segment_reply"></marker>
    <title>Segmentation of Transaction Replies</title>
    <p>In version 3 of the Megaco standard the segmentation package was
      introduced. Simply, this package defines a procedure to segment
      Megaco messages (transaction replies) when using a transport that
      does not automatically do this (such as UDP). See also section
      <seealso marker="megaco_encode#handling_versions">
      Handling Megaco Versions</seealso>.</p>
    <p>Although it would be both pointless and counter-productive to use
      segmentation on a transport that already does this (such as TCP), the
      Megaco application does not check this. Instead, it is up to the
      user to configure this properly.</p>
    <list type="bulleted">
      <item>
        <p>Receiving segmented messages:</p>
        <p>This is handled automatically by the Megaco application.
          However, the user must configure option
          <seealso marker="megaco#user_info">
          <c>segment_recv_timer</c>c></seealso> (described in
          <seealso marker="megaco#user_info/1">
          <c>megaco:user_info</c></seealso>.</p>
        <p>Notice that the segments are delivered to the user differently
          depending on which function is used to issue the original request.
          When issuing the request using the
          <seealso marker="megaco#cast"><c>megaco:cast</c></seealso> function,
          the segments are delivered to the user through the
          <seealso marker="megaco_user#trans_reply">
          <c>handle_trans_reply</c></seealso> callback function
          (in <c>megaco:megaco_user</c>) one at a time, as they arrive.
          However, this clearly does not work for the
          <seealso marker="megaco#call"><c>megaco:call</c></seealso> function.
          In this case, the segments are accumulated and then delivered
          all at once as the function returns.</p>
      </item>
      <item>
        <p>Sending segmented messages:</p>
        <p>This is also handled automatically by the Megaco application
          as follows:</p>
        <list type="bulleted">
          <item><p>First, segmentation is only attempted if so configured,
            see option
            <seealso marker="megaco#user_info"><c>segment_send</c></seealso>
            (in <seealso marker="megaco#user_info/1">
            <c>megaco:user_info</c></seealso>.</p>
          </item>
          <item><p>Megaco relies on the ability of the used codec to
            encode action replies, which is the smallest component the
            Megaco application handles when segmenting.</p>
          </item>
          <item><p>The reply is segmented only if the sum of the size of the
            action replies (plus an arbitrary message header size) are greater
            than the specified maximum message size (see option
            <seealso marker="megaco#user_info">max_pdu_size</seealso> in
            <seealso marker="megaco#user_info/1">
            <c>megaco:user_info</c></seealso>.)</p>
          </item>
          <item><p>Finally, if segmentation is decided, each action reply
            make up its own (segment) message.</p>
          </item>
        </list>
      </item>
    </list>
  </section>
</chapter>

