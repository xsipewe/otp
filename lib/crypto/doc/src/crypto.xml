<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>1999</year><year>2016</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.

    </legalnotice>
    <title>crypto</title>
    <prepared></prepared>
    <docno></docno>
    <approved></approved>
    <checked></checked>
    <date></date>
    <rev></rev>
  </header>

  <module>crypto</module>
  <modulesummary>Crypto functions.</modulesummary>
  <description>
    <p>This module provides a set of cryptographic functions:</p>
    <list type="bulleted">
      <item>
        <p>Hash functions -
          <url href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">
          Secure Hash Standard</url>,
          <url href="http://www.ietf.org/rfc/rfc1321.txt">
          The MD5 Message Digest Algorithm (RFC 1321)</url>, and
          <url href="http://www.ietf.org/rfc/rfc1320.txt">
          The MD4 Message Digest Algorithm (RFC 1320)</url></p>
      </item>
      <item>
        <p>Hmac functions -
          <url href="http://www.ietf.org/rfc/rfc2104.txt">
          Keyed-Hashing for Message Authentication (RFC 2104)</url></p>
      </item>
      <item>
        <p><url href="http://csrc.nist.gov/groups/ST/toolkit/block_ciphers.html">
          Block ciphers</url> - DES and AES in Block Cipher Modes -
          <url href="http://csrc.nist.gov/groups/ST/toolkit/BCM/index.html">
          ECB, CBC, CFB, OFB, CTR, and GCM</url></p>
      </item>
      <item>
        <p><url href="http://www.ietf.org/rfc/rfc1321.txt">
          RSA encryption (RFC 1321)</url></p>
      </item>
      <item>
        <p>Digital signatures -
          <url href="http://csrc.nist.gov/publications/drafts/fips186-3/fips_186-3.pdf">
          Digital Signature Standard (DSS)</url> and
          <url href="http://csrc.nist.gov/groups/STM/cavp/documents/dss2/ecdsa2vs.pdf">
          Elliptic Curve Digital Signature Algorithm (ECDSA)</url></p>
      </item>
      <item>
        <p><url href="http://www.ietf.org/rfc/rfc2945.txt">
          Secure Remote Password Protocol (SRP - RFC 2945)</url></p>
      </item>
      <item>
        <p>gcm: Dworkin, M., "Recommendation for Block Cipher Modes of
          Operation: Galois/Counter Mode (GCM) and GMAC",
          National Institute of Standards and Technology SP 800-38D,
          November 2007.</p>
      </item>
    </list>
  </description>

  <datatypes>
    <datatype>
      <name>key_value() = integer() | binary()</name>
      <desc>
        <p>Always <c>binary()</c> when used as return value.</p>
      </desc>
    </datatype>
    <datatype>
      <name>rsa_public() = [key_value()] = [E, N]</name>
      <desc>
        <taglist>
          <tag><c>E</c></tag>
          <item>Public exponent</item>
          <tag><c>N</c></tag>
          <item>Public modulus</item>
        </taglist>
      </desc>
    </datatype>
    <datatype>
      <name>rsa_private() = [key_value()] = [E, N, D] |
        [E, N, D, P1, P2, E1, E2, C]</name>
      <desc>
        <taglist>
          <tag><c>E</c></tag>
          <item>Public exponent</item>
          <tag><c>N</c></tag>
          <item>Public modulus</item>
          <tag><c>D</c></tag>
          <item>Private exponent</item>
        </taglist>
        <p>The longer key format contains redundant information that makes the
          calculation faster:</p>
        <taglist>
          <tag><c>P1</c> and <c>P2</c></tag>
          <item>First and second prime factors</item>
          <tag><c>E1</c> and <c>E2</c></tag>
          <item>First and second exponents</item>
          <tag><c>C</c></tag>
          <item>CRT coefficient</item>
        </taglist>
        <p>Terminology is taken from
          <url href="http://www.ietf.org/rfc/rfc3477.txt">RFC 3447</url>.</p>
      </desc>
    </datatype>
    <datatype>
      <name>dss_public() = [key_value()] = [P, Q, G, Y]</name>
      <desc>
        <taglist>
          <tag><c>P</c>, <c>Q</c>, and <c>G</c></tag>
          <item>dss parameters</item>
          <tag><c>Y</c></tag>
          <item>Public key</item>
        </taglist>
      </desc>
    </datatype>
    <datatype>
      <name>dss_private() = [key_value()] = [P, Q, G, X]</name>
      <desc>
        <taglist>
          <tag><c>P</c>, <c>Q</c>, and <c>G</c></tag>
          <item>dss parameters</item>
          <tag><c>X</c></tag>
          <item>Private key</item>
        </taglist>
      </desc>
    </datatype>
    <datatype>
      <name>srp_public() = key_value() = A | B</name>
      <desc>
        <p><c>A</c> and <c>B</c> are defined by
          <url href="http://srp.stanford.edu/design.html">SRP design</url>.</p>
      </desc>
    </datatype>
    <datatype>
      <name>srp_private() = key_value() = a | b</name>
      <desc>
        <p><c>a</c> and <c>b</c> are defined by
          <url href="http://srp.stanford.edu/design.html">SRP design</url>.</p>
      </desc>
    </datatype>
    <datatype>
      <name>srp_params() = {user, [Generator::binary(), Prime::binary(),
        Version::atom()]} | {host, [Verifier::binary(), Generator::binary(),
        Prime::binary(), Version::atom()]}</name>
      <desc>
        <taglist>
          <tag><c>Version</c></tag>
          <item>
            <p>'3' | '6' | '6a'</p>
            <p>See also <url href="http://srp.stanford.edu/design.html">
              SRP design</url></p>
          </item>
        </taglist>
      </desc>
    </datatype>
    <datatype>
      <name>dh_public() = key_value()</name>
    </datatype>
    <datatype>
      <name>dh_private() = key_value()</name>
    </datatype>
    <datatype>
      <name>dh_params() = [key_value()] = [P, G]</name>
    </datatype>
    <datatype>
      <name>ecdh_public() = key_value()</name>
    </datatype>
    <datatype>
      <name>ecdh_private() = key_value()</name>
    </datatype>
    <datatype>
      <name>ecdh_params() = ec_named_curve() | ec_explicit_curve()</name>
    </datatype>
    <datatype>
      <name>ec_explicit_curve() = {ec_field(), Prime :: key_value(), Point ::
        key_value(), Order :: integer(), CoFactor :: none | integer()}</name>
    </datatype>
    <datatype>
      <name>ec_field() = {prime_field, Prime :: integer()} |
        {characteristic_two_field, M :: integer(), Basis :: ec_basis()}</name>
    </datatype>
    <datatype>
      <name>ec_basis() =  {tpbasis, K :: non_neg_integer()} |
        {ppbasis, K1 :: non_neg_integer(), K2 :: non_neg_integer(), K3 ::
        non_neg_integer()} | onbasis</name>
    </datatype>
    <datatype>
      <name>ec_named_curve() -> sect571r1 | sect571k1 | sect409r1 | sect409k1 |
        secp521r1 | secp384r1 | secp224r1 | secp224k1 | secp192k1 | secp160r2 |
        secp128r2 | secp128r1 | sect233r1 | sect233k1 | sect193r2 | sect193r1 |
        sect131r2 | sect131r1 | sect283r1 | sect283k1 | sect163r2 | secp256k1 |
        secp160k1 | secp160r1 | secp112r2 | secp112r1 | sect113r2 | sect113r1 |
        sect239k1 | sect163r1 | sect163k1 | secp256r1 | secp192r1 |
        brainpoolP160r1 | brainpoolP160t1 | brainpoolP192r1 | brainpoolP192t1 |
        brainpoolP224r1 | brainpoolP224t1 | brainpoolP256r1 | brainpoolP256t1 |
        brainpoolP320r1 | brainpoolP320t1 | brainpoolP384r1 | brainpoolP384t1 |
        brainpoolP512r1 | brainpoolP512t1</name>
      <desc>
        <p>Notice that the <em>sect</em> curves are GF2m (characteristic two)
          curves and are only supported if the underlying OpenSSL has support
          for them. See also <seealso marker="#supports-0">
          <c>supports/0</c></seealso>.</p>
      </desc>
    </datatype>
    <datatype>
      <name>stream_cipher() = rc4 | aes_ctr</name>
    </datatype>
    <datatype>
      <name>block_cipher() = aes_cbc | aes_cfb8 | aes_cfb128 | aes_ige256 |
        blowfish_cbc | blowfish_cfb64 | des_cbc | des_cfb | des3_cbc |
        des3_cbf | des_ede3 | rc2_cbc</name>
    </datatype>
    <datatype>
      <name>aead_cipher() = aes_gcm | chacha20_poly1305</name>
    </datatype>
    <datatype>
      <name>stream_key() = aes_key() | rc4_key()</name>
    </datatype>
    <datatype>
      <name>block_key() = aes_key() | blowfish_key() | des_key()|
        des3_key()</name>
    </datatype>
    <datatype>
      <name>aes_key() = iodata()</name>
      <desc>
        <p>Key length is 128, 192, or 256 bits.</p>
      </desc>
    </datatype>
    <datatype>
      <name>rc4_key() = iodata()</name>
      <desc>
        <p>Key length is 8-2048 bits (usually 40-256 bits).</p>
      </desc>
    </datatype>
    <datatype>
      <name>blowfish_key() = iodata()</name>
      <desc>
        <p>Key length is 32-448 bits.</p>
      </desc>
    </datatype>
    <datatype>
      <name>des_key() = iodata()</name>
      <desc>
        <p>Key length is 64 bits (in CBC mode only 8 bits are used).</p>
      </desc>
    </datatype>
    <datatype>
      <name>des3_key() = [binary(), binary(), binary()]</name>
      <desc>
        <p>Each key part is 64 bits (in CBC mode only 8 bits are used).</p>
      </desc>
    </datatype>
    <datatype>
      <name>digest_type() = md5 | sha | sha224 | sha256 | sha384 | sha512</name>
    </datatype>
    <datatype>
      <name>hash_algorithms() = md5 | ripemd160 | sha | sha224 | sha256 |
        sha384 | sha512</name>
      <desc>
        <p>md4 is also supported for
          <seealso marker="#hash_init/1"><c>hash_init/1</c></seealso> and
          <seealso marker="#hash/2"><c>hash/s</c></seealso>.</p>
        <p>Notice that both md4 and md5 are recommended only for compatibility
          with existing applications.</p>
      </desc>
    </datatype>
    <datatype>
      <name>cipher_algorithms() = aes_cbc | aes_cfb8 | aes_cfb128 | aes_ctr |
        aes_gcm | aes_ige256 | blowfish_cbc | blowfish_cfb64 |
        chacha20_poly1305 | des_cbc | des_cfb | des3_cbc | des3_cbf |
        des_ede3 | rc2_cbc | rc4</name>
    </datatype>
    <datatype>
      <name>public_key_algorithms() = rsa | dss | ecdsa | dh | ecdh |
        ec_gf2m</name>
      <desc>
        <p>Notice that ec_gf2m is not strictly a public key algorithm, but a
          restriction on what curves are supported with ecdsa and ecdh.</p>
      </desc>
    </datatype>
  </datatypes>

  <funcs>
    <func>
      <name>block_decrypt(Type, Key, CipherText) -> PlainText</name>
      <fsummary>Decrypt <c>CipherText</c> according to <c>Type</c> block cipher.
      </fsummary>
      <type>
        <v>Type = des_ecb | blowfish_ecb | aes_ecb</v>
        <v>Key = block_key()</v>
        <v>PlainText = iodata()</v>
      </type>
      <desc>
        <p>Decrypts <c>CipherText</c> according to <c>Type</c> block cipher.</p>
        <p>Can throw exception <c>notsup</c> if the chosen <c>Type</c>
          is not supported by the underlying OpenSSL implementation.</p>
      </desc>
    </func>

    <func>
      <name>block_decrypt(Type, Key, Ivec, CipherText) -> PlainText</name>
      <name>block_decrypt(AeadType, Key, Ivec, {AAD, CipherText, CipherTag}) ->
        PlainText | error</name>
      <fsummary>Decrypt <c>CipherText</c> according to <c>Type</c> block cipher.
      </fsummary>
      <type>
        <v>Type = block_cipher()</v>
        <v>AeadType = aead_cipher()</v>
        <v>Key = block_key()</v>
        <v>PlainText = iodata()</v>
        <v>AAD = IVec = CipherText = CipherTag = binary()</v>
      </type>
      <desc>
        <p>Decrypts <c>CipherText</c> according to <c>Type</c> block cipher.
          <c>IVec</c> is an arbitrary initializing vector.</p>
        <p>In AEAD (Authenticated Encryption with Associated Data) mode,
          decrypts <c>CipherText</c> according to <c>Type</c> block cipher, and
          authenticates the <c>PlainText</c> and <c>AAD</c> (Associated
          Authenticated Data) using the <c>CipherTag</c>. Can return
          <c>error</c> if the decryption or validation fails.</p>
        <p>Can throw exception <c>notsup</c> if the chosen <c>Type</c>
          is not supported by the underlying OpenSSL implementation.</p>
      </desc>
    </func>

    <func>
      <name>block_encrypt(Type, Key, PlainText) -> CipherText</name>
      <fsummary>Encrypt <c>PlainText</c> according to <c>Type</c> block cipher.
      </fsummary>
      <type>
        <v>Type = des_ecb | blowfish_ecb | aes_ecb</v>
        <v>Key = block_key()</v>
        <v>PlainText = iodata()</v>
      </type>
      <desc>
        <p>Encrypts <c>PlainText</c> according to <c>Type</c> block cipher.</p>
        <p>Can throw exception <c>notsup</c> if the chosen <c>Type</c>
          is not supported by the underlying OpenSSL implementation.</p>
      </desc>
    </func>

    <func>
      <name>block_encrypt(Type, Key, Ivec, PlainText) -> CipherText</name>
      <name>block_encrypt(AeadType, Key, Ivec, {AAD, PlainText}) ->
        {CipherText, CipherTag}</name>
      <name>block_encrypt(aes_gcm, Key, Ivec, {AAD, PlainText, TagLength}) ->
        {CipherText, CipherTag}</name>
      <fsummary>Encrypt <c>PlainText</c> according to <c>Type</c> block cipher.
      </fsummary>
      <type>
        <v>Type = block_cipher()</v>
        <v>AeadType = aead_cipher()</v>
        <v>Key = block_key()</v>
        <v>PlainText = iodata()</v>
        <v>AAD = IVec = CipherText = CipherTag = binary()</v>
        <v>TagLength = 1..16</v>
      </type>
      <desc>
        <p>Encrypts <c>PlainText</c> according to <c>Type</c> block cipher.
          <c>IVec</c> is an arbitrary initializing vector.</p>
        <p>In AEAD (Authenticated Encryption with Associated Data) mode,
          encrypts <c>PlainText</c> according to <c>Type</c> block cipher and
          calculates <c>CipherTag</c>, which also authenticates the <c>AAD</c>
          (Associated Authenticated Data).</p>
        <p>Can throw exception <c>notsup</c> if the chosen <c>Type</c>
          is not supported by the underlying OpenSSL implementation.</p>
      </desc>
    </func>

    <func>
      <name>bytes_to_integer(Bin) -> Integer</name>
      <fsummary>Convert binary representation, of an integer, to an Erlang
        integer.</fsummary>
      <type>
        <v>Bin = binary() - as returned by crypto functions</v>
        <v>Integer = integer()</v>
      </type>
      <desc>
        <p>Converts binary representation, of an integer, to an Erlang integer.
        </p>
      </desc>
    </func>

    <func>
      <name>compute_key(Type, OthersPublicKey, MyKey, Params) -> SharedSecret
      </name>
      <fsummary>Compute the shared secret.</fsummary>
      <type>
        <v>Type = dh | ecdh | srp</v>
        <v>OthersPublicKey = dh_public() | ecdh_public() | srp_public()</v>
        <v>MyKey = dh_private() | ecdh_private() |
          {srp_public(),srp_private()}</v>
        <v>Params = dh_params() | ecdh_params() | SrpUserParams | SrpHostParams
        </v>
        <v>SrpUserParams = {user, [DerivedKey::binary(), Prime::binary(),
          Generator::binary(), Version::atom() | [Scrambler:binary()]]}</v>
        <v>SrpHostParams = {host, [Verifier::binary(), Prime::binary(),
          Version::atom() | [Scrambler::binary]]}</v>
        <v>SharedSecret = binary()</v>
      </type>
      <desc>
        <p>Computes the shared secret from the private key and the other
          party's public key. See also
          <seealso marker="public_key:public_key#compute_key-2">
          <c>public_key:compute_key/2</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>ec_curve(NamedCurve) -> EllipticCurve</name>
      <fsummary>Get the defining parameters of an elliptic curve.</fsummary>
      <type>
        <v>NamedCurve = ec_named_curve()</v>
        <v>EllipticCurve = ec_explicit_curve()</v>
      </type>
      <desc>
        <p>Returns the defining parameters of an elliptic curve.</p>
      </desc>
    </func>

    <func>
      <name>ec_curves() -> EllipticCurveList </name>
      <fsummary>Get a list of available named elliptic curves.</fsummary>
      <type>
        <v>EllipticCurveList = [ec_named_curve()]</v>
      </type>
      <desc>
        <p>Can be used to determine which named elliptic curves are supported.
        </p>
      </desc>
    </func>

    <func>
      <name>exor(Data1, Data2) -> Result</name>
      <fsummary>XOR data.</fsummary>
      <type>
        <v>Data1, Data2 = iodata()</v>
        <v>Result = binary()</v>
      </type>
      <desc>
        <p>Performs bitwise XOR (exclusive or) on the data supplied.</p>
      </desc>
    </func>

    <func>
      <name>generate_key(Type, Params) -> {PublicKey, PrivKeyOut}</name>
      <name>generate_key(Type, Params, PrivKeyIn) -> {PublicKey, PrivKeyOut}
      </name>
      <fsummary>Generate a public keys of type <c>Type</c>.</fsummary>
      <type>
        <v>Type = dh | ecdh | srp</v>
        <v>Params = dh_params() | ecdh_params() | srp_params()</v>
        <v>PublicKey = dh_public() | ecdh_public() | srp_public()</v>
        <v>PrivKeyIn = undefined | dh_private() | ecdh_private() | srp_private()
        </v>
        <v>PrivKeyOut = dh_private() | ecdh_private() | srp_private()</v>
      </type>
      <desc>
        <p>Generates public keys of type <c>Type</c>.
          See also <seealso marker="public_key:public_key#generate_key-1">
          <c>public_key:generate_key/1</c></seealso>.</p>
        <p>Can throw exception <c>low_entropy</c> if the random generator
          fails because of lack of secure "randomness".</p>
      </desc>
    </func>

    <func>
      <name>hash(Type, Data) -> Digest</name>
      <fsummary></fsummary>
      <type>
        <v>Type = md4 | hash_algorithms()</v>
        <v>Data = iodata()</v>
        <v>Digest = binary()</v>
      </type>
      <desc>
        <p>Computes a message digest of type <c>Type</c> from <c>Data</c>.</p>
        <p>Can throw exception <c>notsup</c> if the chosen <c>Type</c>
          is not supported by the underlying OpenSSL implementation.</p>
      </desc>
    </func>

    <func>
      <name>hash_final(Context) -> Digest</name>
      <fsummary></fsummary>
      <type>
        <v>Digest = binary()</v>
      </type>
      <desc>
        <p>Finalizes the hash operation referenced by <c>Context</c> returned
          from a previous call to
          <seealso marker="#hash_update-2"><c>hash_update/2</c></seealso>.
          The size of <c>Digest</c> is determined by the type of hash
          function used to generate it.</p>
      </desc>
    </func>

    <func>
      <name>hash_init(Type) -> Context</name>
      <fsummary></fsummary>
      <type>
        <v>Type = md4 | hash_algorithms()</v>
      </type>
      <desc>
        <p>Initializes the context for streaming hash operations.
          <c>Type</c> determines which digest to use.
          The returned context is to be used as argument to
          <seealso marker="#hash_update-2"><c>hash_update/2</c></seealso>.</p>
        <p>Can throw exception <c>notsup</c> if the chosen <c>Type</c>
          is not supported by the underlying OpenSSL implementation.</p>
      </desc>
    </func>

    <func>
      <name>hash_update(Context, Data) -> NewContext</name>
      <fsummary></fsummary>
      <type>
        <v>Data = iodata()</v>
      </type>
      <desc>
        <p>Updates the digest represented by <c>Context</c> using the specified
          <c>Data</c>. <c>Context</c> must have been generated using
          <seealso marker="#hash_init-1"><c>hash_init/1</c></seealso>
          or a previous call to this function. <c>Data</c> can be any length.
          <c>NewContext</c> must be passed into the next call to
          <c>hash_update</c> or
          <seealso marker="#hash_final-1"><c>hash_final/1</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>hmac(Type, Key, Data) -> Mac</name>
      <name>hmac(Type, Key, Data, MacLength) -> Mac</name>
      <fsummary></fsummary>
      <type>
        <v>Type = hash_algorithms() - except ripemd160</v>
        <v>Key = iodata()</v>
        <v>Data = iodata()</v>
        <v>MacLength = integer()</v>
        <v>Mac = binary()</v>
      </type>
      <desc>
        <p>Computes an HMAC of type <c>Type</c> from <c>Data</c> using
          <c>Key</c> as the authentication key.</p>
        <p><c>MacLength</c> limits the size of the resultant <c>Mac</c>.</p>
      </desc>
    </func>

    <func>
      <name>hmac_final(Context) -> Mac</name>
      <fsummary></fsummary>
      <type>
        <v>Context = Mac = binary()</v>
      </type>
      <desc>
        <p>Finalizes the HMAC operation referenced by <c>Context</c>.
          The size of the resultant MAC is
          determined by the type of hash function used to generate it.</p>
      </desc>
    </func>

    <func>
      <name>hmac_final_n(Context, HashLen) -> Mac</name>
      <fsummary></fsummary>
      <type>
        <v>Context = Mac = binary()</v>
        <v>HashLen = non_neg_integer()</v>
      </type>
      <desc>
        <p>Finalizes the HMAC operation referenced by <c>Context</c>.
          <c>HashLen</c> must be &gt; > 0. <c>Mac</c> will be a binary with at
          most <c>HashLen</c> bytes. Notice that if <c>HashLen</c> is greater
          than the number of bytes returned from the underlying hash, the
          returned hash will have less than <c>HashLen</c> bytes.</p>
      </desc>
    </func>

    <func>
      <name>hmac_init(Type, Key) -> Context</name>
      <fsummary></fsummary>
      <type>
        <v>Type = hash_algorithms() - except ripemd160</v>
        <v>Key = iodata()</v>
        <v>Context = binary()</v>
      </type>
      <desc>
        <p>Initializes the context for streaming HMAC operations. <c>Type</c>
          determines which hash function to use in the HMAC operation.
          <c>Key</c> is the authentication key.
          The key can be any length.</p>
      </desc>
    </func>

    <func>
      <name>hmac_update(Context, Data) -> NewContext</name>
      <fsummary></fsummary>
      <type>
        <v>Context = NewContext = binary()</v>
        <v>Data = iodata()</v>
      </type>
      <desc>
        <p>Updates the HMAC represented by <c>Context</c> using the specified
          <c>Data</c>. <c>Context</c>
          must have been generated using an HMAC init function (such as
          <seealso marker="#hmac_init-2"><c>hmac_init/2</c></seealso>).
          <c>Data</c> can be any length. <c>NewContext</c>
          must be passed into the next call to either <c>hmac_update</c>,
          <seealso marker="#hmac_final-1"><c>hmac_final/1</c></seealso>, or
          <seealso marker="#hmac_final_n-2"><c>hmac_final_n/2</c></seealso>.</p>
        <warning>
          <p>Do not use a <c>Context</c> as argument in more than one call
            call to <c>hmac_update</c>, <c>hmac_final/1</c>, or
            <c>hmac_final_n/2</c>. The semantics of
            reusing old contexts in any way is undefined and could even crash
            the VM in earlier releases. This limitation is because of
            lack of support in the underlying OpenSSL API.</p>
        </warning>
      </desc>
    </func>

    <func>
      <name>info_lib() -> [{Name,VerNum,VerStr}]</name>
      <fsummary>Information about the libraries used by crypto.</fsummary>
      <type>
        <v>Name = binary()</v>
        <v>VerNum = integer()</v>
        <v>VerStr = binary()</v>
      </type>
      <desc>
        <p>Provides the name and version of the libraries used by crypto.</p>
        <p><c>Name</c> is the library name. <c>VerNum</c> is
          the numeric version according to the library's own versioning
          scheme. <c>VerStr</c> contains a text variant of the version.</p>
        <pre>
> <input>info_lib().</input>
[{&lt;&lt;"OpenSSL"&gt;&gt;,9469983,&lt;&lt;"OpenSSL 0.9.8a 11 Oct 2005"&gt;&gt;}]</pre>
        <note>
          <p>As from Erlang/OTP R16 the <em>numeric version</em> represents the
            version of the OpenSSL <em>header files</em>
            (<c>openssl/opensslv.h</c>) used when <c>crypto</c> was compiled.
	    The text variant represents the OpenSSL library used at runtime.
	    Before Erlang/OTP R16 both numeric and text were taken from the
            library.</p>
        </note>
      </desc>
    </func>

    <func>
      <name>mod_pow(N, P, M) -> Result</name>
      <fsummary>Compute the function N^P mod M.</fsummary>
      <type>
        <v>N, P, M = binary() | integer()</v>
        <v>Result = binary() | error</v>
      </type>
      <desc>
        <p>Computes the function <c>N^P mod M</c>.</p>
      </desc>
    </func>

    <func>
      <name>next_iv(Type, Data) -> NextIVec</name>
      <name>next_iv(Type, Data, IVec) -> NextIVec</name>
      <fsummary></fsummary>
      <type>
        <v>Type = des_cbc | des3_cbc | aes_cbc | des_cfb</v>
        <v>Data = iodata()</v>
        <v>IVec = NextIVec = binary()</v>
      </type>
      <desc>
        <p>Returns the initialization vector to be used in the next
          iteration of encrypt/decrypt of type <c>Type</c>. <c>Data</c> is the
          encrypted data from the previous iteration step. Argument <c>IVec</c>
          is only needed for <c>des_cfb</c> as the vector used
          in the previous iteration step.</p>
      </desc>
    </func>

    <func>
      <name>private_decrypt(Type, CipherText, PrivateKey, Padding) -> PlainText
      </name>
      <fsummary>Decrypt CipherText using the private key.</fsummary>
      <type>
        <v>Type = rsa</v>
        <v>CipherText = binary()</v>
        <v>PrivateKey = rsa_private()</v>
        <v>Padding = rsa_pkcs1_padding | rsa_pkcs1_oaep_padding | rsa_no_padding
        </v>
        <v>PlainText = binary()</v>
      </type>
      <desc>
        <p>Decrypts the <c>CipherText</c>, encrypted with
          <seealso marker="#public_encrypt-4"><c>public_encrypt/4</c></seealso>
          (or equivalent function) using the <c>PrivateKey</c>, and returns the
          plaintext (message digest). This is a low-level signature verification
          operation used by, for example, older versions of the SSL protocol.
          See also <seealso marker="public_key:public_key#decrypt_private-2">
          <c>public_key:decrypt_private/2,3</c></seealso>.</p>
      </desc>
    </func>
    
    <func>
      <name>private_encrypt(Type, PlainText, PrivateKey, Padding) -> CipherText
      </name>
      <fsummary>Encrypt PlainText using the private key.</fsummary>
      <type>
        <v>Type = rsa</v>
        <v>PlainText = binary()</v>
        <d>The size of <c>PlainText</c> must be less
          than <c>byte_size(N)-11</c> if <c>rsa_pkcs1_padding</c> is
          used, and <c>byte_size(N)</c> if <c>rsa_no_padding</c> is
          used, where N is public modulus of the RSA key.</d>
        <v>PrivateKey = rsa_private()</v>
        <v>Padding = rsa_pkcs1_padding | rsa_no_padding</v>
        <v>CipherText = binary()</v>
      </type>
      <desc>
        <p>Encrypts the <c>PlainText</c> using the <c>PrivateKey</c>
          and returns the ciphertext. This is a low-level signature operation
          used by, for example, older versions of the SSL protocol.
          See also <seealso marker="public_key:public_key#encrypt_private-2">
          <c>public_key:encrypt_private/2,3</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>public_decrypt(Type, CipherText, PublicKey, Padding) -> PlainText
      </name>
      <fsummary>Decrypt CipherText using the public key.</fsummary>
      <type>
        <v>Type = rsa</v>
        <v>CipherText = binary()</v>
        <v>PublicKey =  rsa_public()</v>
        <v>Padding = rsa_pkcs1_padding | rsa_no_padding</v>
        <v>PlainText = binary()</v>
      </type>
      <desc>
        <p>Decrypts the <c>CipherText</c>, encrypted with
          <seealso marker="#private_encrypt-4">
          <c>private_encrypt/4</c></seealso> (or equivalent function)
          using the <c>PrivateKey</c>, and returns the plaintext (message
          digest). This is a low-level signature verification operation
          used by, for example, older versions of the SSL protocol.
          See also <seealso marker="public_key:public_key#decrypt_public-2">
          <c>public_key:decrypt_public/2,3</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>public_encrypt(Type, PlainText, PublicKey, Padding) -> CipherText
      </name>
      <fsummary>Encrypt PlainText using the public key.</fsummary>
      <type>
        <v>Type = rsa</v>
        <v>PlainText = binary()</v>
        <d>The size of <c>PlainText</c> must be less
          than <c>byte_size(N)-11</c> if <c>rsa_pkcs1_padding</c> is
          used, and <c>byte_size(N)</c> if <c>rsa_no_padding</c> is
          used, where N is public modulus of the RSA key.</d>
        <v>PublicKey = rsa_public()</v>
        <v>Padding = rsa_pkcs1_padding | rsa_pkcs1_oaep_padding |
          rsa_no_padding</v>
        <v>CipherText = binary()</v>
      </type>
      <desc>
        <p>Encrypts the <c>PlainText</c> (message digest) using the
          <c>PublicKey</c> and returns the <c>CipherText</c>. This is a
          low-level signature operation used by, for example, older versions
          of the SSL protocol. See also
          <seealso marker="public_key:public_key#encrypt_public-2">
          <c>public_key:encrypt_public/2,3</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>rand_seed(Seed) -> ok</name>
      <fsummary>Set the seed for random bytes generation.</fsummary>
      <type>
        <v>Seed = binary()</v>
      </type>
      <desc>
        <p>Sets the seed for PRNG to the specified binary. This calls the
          RAND_seed function from OpenSSL. Use this only if the system
          you are running on does not have enough "randomness" built in;
          normally this is when <seealso marker="#strong_rand_bytes/1">
          <c>strong_rand_bytes/1</c></seealso> returns <c>low_entropy</c>.</p>
      </desc>
    </func>

    <func>
      <name>rand_uniform(Lo, Hi) -> N</name>
      <fsummary>Generate a random number.</fsummary>
      <type>
        <v>Lo, Hi, N = integer()</v>
      </type>
      <desc>
        <p>Generates a random number <c><![CDATA[N, Lo =< N < Hi]]></c>.
          Uses the <c>crypto</c> library pseudo-random number generator.
          <c>Hi</c> must be greater than <c>Lo</c>.</p>
      </desc>
    </func>

    <func>
      <name>sign(Algorithm, DigestType, Msg, Key) -> binary()</name>
      <fsummary>Create digital signature.</fsummary>
      <type>
        <v>Algorithm = rsa | dss | ecdsa</v>
        <v>Msg = binary() | {digest,binary()}</v>
        <d><c>Msg</c> is either the binary "cleartext" data to be
          signed or the hashed value of "cleartext", that is, the
          digest (plaintext).</d>
        <v>DigestType = digest_type()</v>
        <v>Key = rsa_private() | dss_private() | [ecdh_private(),ecdh_params()]
        </v>
      </type>
      <desc>
        <p>Creates a digital signature.</p>
        <p>Algorithm <c>dss</c> can only be used together with digest type
          <c>sha</c>.</p>
        <p>See also <seealso marker="public_key:public_key#sign-3">
          <c>public_key:sign/3</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>start() -> ok</name>
      <fsummary>Equivalent to application:start(crypto).</fsummary>
      <desc>
        <p>Equivalent to <seealso marker="kernel:application#start/1">
          <c>application:start(crypto)</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>stop() -> ok</name>
      <fsummary>Equivalent to application:stop(crypto).</fsummary>
      <desc>
        <p>Equivalent to <seealso marker="kernel:application#stop/1">
          <c>application:stop(crypto)</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>stream_decrypt(State, CipherText) -> { NewState, PlainText }</name>
      <fsummary></fsummary>
      <type>
        <v>CipherText = iodata()</v>
        <v>PlainText = binary()</v>
      </type>
      <desc>
        <p>Decrypts <c>CipherText</c> according to the stream cipher <c>Type</c>
          specified in <seealso marker="#stream_init/3">
          <c>stream_init/3</c></seealso>. <c>PlainText</c> can be any number of
          bytes. The initial <c>State</c> is created using
          <seealso marker="#stream_init-2"><c>stream_init/2,3</c></seealso>.
          <c>NewState</c> must be passed into the next call to
          <c>stream_decrypt</c>.</p>
      </desc>
    </func>

    <func>
      <name>stream_encrypt(State, PlainText) -> { NewState, CipherText}</name>
      <fsummary></fsummary>
      <type>
        <v>Text = iodata()</v>
        <v>CipherText = binary()</v>
      </type>
      <desc>
        <p>Encrypts <c>PlainText</c> according to the stream cipher <c>Type</c>
          specified in <seealso marker="#stream_init/3">
          <c>stream_init/3</c></seealso>. <c>Text</c> can be any number of
          bytes. The initial <c>State</c> is created using
          <seealso marker="#stream_init-2"><c>stream_init/2,3</c></seealso>.
          <c>NewState</c> must be passed into the next call to
          <c>stream_encrypt</c>.</p>
      </desc>
    </func>

    <func>
      <name>stream_init(Type, Key) -> State</name>
      <fsummary></fsummary>
      <type>
        <v>Type = rc4</v>
        <v>State = opaque()</v>
        <v>Key = iodata()</v>
      </type>
      <desc>
        <p>Initializes the state for use in RC4 stream encryption with
          <seealso marker="#stream_encrypt-2"><c>stream_encrypt/2</c></seealso>
          and
          <seealso marker="#stream_decrypt-2"><c>stream_decrypt/2</c></seealso>.
        </p>
      </desc>
    </func>

   <func>
      <name>stream_init(Type, Key, IVec) -> State</name>
      <fsummary></fsummary>
      <type>
        <v>Type = aes_ctr</v>
        <v>State = opaque()</v>
        <v>Key = iodata()</v>
        <v>IVec = binary()</v>
      </type>
      <desc>
        <p>Initializes the state for use in streaming AES encryption using
          Counter mode (CTR). <c>Key</c> is the AES key and must be either
          128, 192, or 256 bits long. <c>IVec</c> is an arbitrary initializing
          vector of 128 bits (16 bytes). This state is for use with
          <seealso marker="#stream_encrypt-2"><c>stream_encrypt/2</c></seealso>
          and
          <seealso marker="#stream_decrypt-2"><c>stream_decrypt/2</c></seealso>.
        </p>
      </desc>
    </func>

    <func>
      <name>strong_rand_bytes(N) -> binary()</name>
      <fsummary>Generate a binary of random bytes.</fsummary>
      <type>
        <v>N = integer()</v>
      </type>
      <desc>
        <p>Generates N bytes randomly uniform 0..255 and returns the
          result in a binary. Uses a cryptographically secure PRNG, seeded and
          periodically mixed with operating system-provided entropy. By default
          this is the <c>RAND_bytes</c> method from OpenSSL.</p>
        <p>Can throw exception <c>low_entropy</c> if the random generator
          fails because of lack of secure "randomness".</p>
      </desc>
    </func>

   <func>
      <name>supports() -> AlgorithmList</name>
      <fsummary>Get a list of available crypto algorithms.</fsummary>
      <type>
        <v>AlgorithmList =  [{hashs, [hash_algorithms()]}, {ciphers,
          [cipher_algorithms()]}, {public_keys, [public_key_algorithms()]}</v>
      </type>
      <desc>
        <p>Can be used to determine which crypto algorithms are supported
          by the underlying OpenSSL library.</p>
      </desc>
    </func>

    <func>
      <name>verify(Algorithm, DigestType, Msg, Signature, Key) -> boolean()
      </name>
      <fsummary>Verify a digital signature.</fsummary>
      <type>
        <v>Algorithm = rsa | dss | ecdsa</v>
        <v>Msg = binary() | {digest,binary()}</v>
        <d>Msg is either the binary "cleartext" data or the hashed value
          of "cleartext", that is, the digest (plaintext).</d>
        <v>DigestType = digest_type()</v>
        <v>Signature = binary()</v>
        <v>Key = rsa_public() | dss_public() | [ecdh_public(),ecdh_params()]</v>
      </type>
      <desc>
        <p>Verifies a digital signature.</p>
        <p>Algorithm <c>dss</c> can be used only with digest type
          <c>sha</c>.</p>
        <p>See also <seealso marker="public_key:public_key#verify-4">
          <c>public_key:verify/4</c></seealso>.</p>
      </desc>
    </func>
  </funcs>

</erlref>

