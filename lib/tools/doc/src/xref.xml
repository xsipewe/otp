<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>2000</year><year>2013</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.

    </legalnotice>

    <title>xref</title>
    <prepared>Hans Bolinder</prepared>
    <responsible></responsible>
    <docno></docno>
    <approved></approved>
    <checked></checked>
    <date>2000-08-15</date>
    <rev>PA1</rev>
    <file>xref.xml</file>
  </header>
  <module>xref</module>
  <modulesummary>A cross reference tool for analyzing dependencies between
    functions, modules, applications, and releases.</modulesummary>
  <description>
    <p>Xref is a cross reference tool that can be used for finding
      dependencies between functions, modules, applications, and releases.</p>
  </description>

  <section>
    <title>Data Types</title>
    <taglist>
      <tag><c>application() = atom()</c></tag>
      <item></item>
      <tag><c>arity() = int() | -1</c></tag>
      <item></item>
      <tag><c>bool() = true | false</c></tag>
      <item></item>
      <tag><c>call() = {atom(), atom()} | funcall()</c></tag>
      <item></item>
      <tag><c>constant() = mfa() | module() | application() | release()</c></tag>
      <item></item>
      <tag><c>directory() = string()</c></tag>
      <item></item>
      <tag><c>file() = string()</c></tag>
      <item></item>
      <tag><c>funcall() = {mfa(), mfa()}</c></tag>
      <item></item>
      <tag><c>function() = atom()</c></tag>
      <item></item>
      <tag><c>int() = integer() >= 0</c></tag>
      <item></item>
      <tag><c>library() = atom()</c></tag>
      <item></item>
      <tag><c>library_path() = path() | code_path</c></tag>
      <item></item>
      <tag><c>mfa() = {module(), function(), arity()}</c></tag>
      <item></item>
      <tag><c>mode() = functions | modules</c></tag>
      <item></item>
      <tag><c>module() = atom()</c></tag>
      <item></item>
      <tag><c>release() = atom()</c></tag>
      <item></item>
      <tag><c>string_position() = int() | at_end</c></tag>
      <item></item>
      <tag><c>variable() = atom()</c></tag>
      <item></item>
      <tag><c>xref() = atom() | pid()</c></tag>
      <item></item>
    </taglist>
  </section>

  <funcs>
    <func>
      <name>add_application(Xref, Directory [, Options]) ->  {ok, application()} | Error</name>
      <fsummary>Adds the modules of an application.</fsummary>
      <type>
        <v>Directory = directory()</v>
        <v>Error = {error, module(), Reason}</v>
        <v>Options = [Option] | Option</v>
        <v>Option = {builtins, bool()} | {name, application()} | {verbose, bool()} | {warnings, bool()}</v>
        <v>Reason =  {application_clash, {application(), directory(), directory()}} | {file_error, file(), error()} | {invalid_filename, term()} | {invalid_options, term()} | -&nbsp;see&nbsp;also&nbsp;add_directory&nbsp;-</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Adds an application, the modules of the application, and
          <seealso marker="xref_chapter#module_data">module data</seealso>
          of the modules to an
          <seealso marker="xref_chapter#xref_server">Xref server</seealso>.
          The modules becomes members of the application.
          The default is to use the base name of the
          directory with the version removed as application name, but
          this can be overridden by option <c>name</c>. Returns the
          application name.</p>
        <p>If the specified directory has a subdirectory named
          <c>ebin</c>, modules (Beam files) are searched for in that
          directory, otherwise modules are searched for in the specified
          directory.</p>
        <p>If the <seealso marker="xref_chapter#mode">mode</seealso> of the
          Xref server is <c>functions</c>, Beam files containing no
          <seealso marker="xref_chapter#debug_info">debug information</seealso>
          are ignored.</p>
      </desc>
    </func>
 
   <func>
      <name>add_directory(Xref, Directory [, Options]) ->  {ok, Modules} | Error</name>
      <fsummary>Adds the modules in a directory.</fsummary>
      <type>
        <v>Directory = directory()</v>
        <v>Error = {error, module(), Reason}</v>
        <v>Modules = [module()]</v>
        <v>Options = [Option] | Option</v>
        <v>Option = {builtins, bool()} | {recurse, bool()} | {verbose, bool()} | {warnings, bool()}</v>
        <v>Reason = {file_error, file(), error()} | {invalid_filename, term()} | {invalid_options, term()} | {unrecognized_file, file()} | -&nbsp;error from beam_lib:chunks/2&nbsp;-</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Adds the modules found in the specified directory and their
          <seealso marker="xref_chapter#module_data">module data</seealso> to an
          <seealso marker="xref_chapter#xref_server">Xref server</seealso>. 
          The default is not to examine subdirectories, but if option
          <c>recurse</c> has the value <c>true</c>, modules are searched
          for in subdirectories on all levels and in the speciified
          directory.
          Returns a sorted list of the names of the added modules.</p>
        <p>The modules added do not become members of any applications.</p>
        <p>If the <seealso marker="xref_chapter#mode">mode</seealso> of the
          Xref server is <c>functions</c>, Beam files containing no
          <seealso marker="xref_chapter#debug_info">debug information</seealso>
          are ignored.</p>
      </desc>
    </func>

    <func>
      <name>add_module(Xref, File [, Options]) -> {ok, module()} | Error</name>
      <fsummary>Adds a module.</fsummary>
      <type>
        <v>Error = {error, module(), Reason}</v>
        <v>File = file()</v>
        <v>Options = [Option] | Option</v>
        <v>Option = {builtins, bool()} | {verbose, bool()} | {warnings, bool()}</v>
        <v>Reason = {file_error, file(), error()} | {invalid_filename, term()} | {invalid_options, term()} | {module_clash, {module(), file(), file()}} | {no_debug_info, file()} | -&nbsp;error from beam_lib:chunks/2&nbsp;-</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Adds a module and its
          <seealso marker="xref_chapter#module_data">module data</seealso> to an
          <seealso marker="xref_chapter#xref_server">Xref server</seealso>.
          The module does not become member of any application.
          Returns the module name.</p>
        <p>If the <seealso marker="xref_chapter#mode">mode</seealso> of the Xref
          server is <c>functions</c>, and the Beam file contains no
          <seealso marker="xref_chapter#debug_info">debug information</seealso>,
          error message <c>no_debug_info</c> is returned.</p>
      </desc>
    </func>

    <func>
      <name>add_release(Xref, Directory [, Options]) ->  {ok, release()} | Error</name>
      <fsummary>Adds the modules of a release.</fsummary>
      <type>
        <v>Directory = directory()</v>
        <v>Error = {error, module(), Reason}</v>
        <v>Options = [Option] | Option</v>
        <v>Option = {builtins, bool()} | {name, release()} | {verbose, bool()} | {warnings, bool()}</v>
        <v>Reason =  {application_clash, {application(), directory(), directory()}} | {file_error, file(), error()} | {invalid_filename, term()} | {invalid_options, term()} | {release_clash, {release(), directory(), directory()}} | -&nbsp;see&nbsp;also&nbsp;add_directory&nbsp;-</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Adds a release, the applications of the release, the
          modules of the applications, and
          <seealso marker="xref_chapter#module_data">module data</seealso>
          of the modules to an
          <seealso marker="xref_chapter#xref_server">Xref server</seealso>.
          The applications become members of the release, 
          and the modules become members of the applications.
          The default is to use the base name of the
          directory as release name, but this can be overridden by option
          <c>name</c>. Returns the release name.</p>
        <p>If the specified directory has a subdirectory named <c>lib</c>,
          the directories in that directory are assumed to be
          application directories. Otherwise all subdirectories of the
          specified directory are assumed to be application directories.
          If there are many versions of some application, the one
          with the highest version is chosen.</p>
        <p>If the <seealso marker="xref_chapter#mode">mode</seealso> of the Xref
          server is <c>functions</c>, Beam files containing no
          <seealso marker="xref_chapter#debug_info">debug information</seealso>
          are ignored.</p>
      </desc>
    </func>

    <func>
      <name>analyze(Xref, Analysis [, Options]) ->  {ok, Answer} | Error</name>
      <fsummary>Evaluates a predefined analysis.</fsummary>
      <type>
        <v>Analysis = undefined_function_calls | undefined_functions | locals_not_used | exports_not_used | deprecated_function_calls | {deprecated_function_calls, DeprFlag} | deprecated_functions | {deprecated_functions, DeprFlag} | {call, FuncSpec} | {use, FuncSpec} | {module_call, ModSpec} | {module_use, ModSpec} | {application_call, AppSpec} | {application_use, AppSpec} | {release_call, RelSpec} | {release_use, RelSpec}</v>
        <v>Answer = [term()]</v>
        <v>AppSpec = application() | [application()]</v>
        <v>DeprFlag = next_version | next_major_release | eventually</v>
        <v>Error = {error, module(), Reason}</v>
        <v>FuncSpec = mfa() | [mfa()]</v>
        <v>ModSpec = module() | [module()]</v>
        <v>Options = [Option] | Option</v>
        <v>Option = {verbose, bool()}</v>
        <v>RelSpec = release() | [release()]</v>
        <v>Reason = {invalid_options, term()} | {parse_error, string_position(), term()} | {unavailable_analysis, term()} | {unknown_analysis, term()} | {unknown_constant, string()} | {unknown_variable, variable()}</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
      <marker id="analyze"></marker>
        <p>Evaluates a predefined analysis.
          Returns a sorted list without duplicates of <c>call()</c> or
          <c>constant()</c>, depending on the chosen analysis. The
          predefined analyses, which operate on all
          <seealso marker="xref_chapter#analyzed_module">analyzed modules</seealso>,
          are as follows:
          (analyses marked with (*) are available in <c>functions</c>
          <seealso marker="xref_chapter#mode">mode</seealso> only):</p>
        <taglist>
          <tag><c>undefined_function_calls</c>(*)</tag>
          <item><p>Returns a list of calls to
            <seealso marker="xref_chapter#undefined_function">undefined functions</seealso>.
            </p>
          </item>
          <tag><c>undefined_functions</c></tag>
          <item><p>Returns a list of
            <seealso marker="xref_chapter#undefined_function">undefined functions</seealso>.
            </p>
          </item>
          <tag><c>locals_not_used</c>(*)</tag>
          <item><p>Returns a list of local functions that are not
            used locally.</p></item>
          <tag><c>exports_not_used</c></tag>
          <item><p>Returns a list of exported functions that are not
            used externally.</p></item>
          <tag><c>deprecated_function_calls</c>(*)</tag>
          <item><p>Returns a list of external calls to
            <seealso marker="xref_chapter#deprecated_function">deprecated functions</seealso>.
            </p>
          </item>
          <tag><c>{deprecated_function_calls, DeprFlag}</c>(*)</tag>
          <item><p>Returns a list of external calls to deprecated
            functions.</p>
            <list type="bulleted">
              <item><p>If <c>DeprFlag</c> is equal to <c>next_version</c>,
                calls to functions to be removed in the next version are
                returned.</p></item>
              <item><p>If <c>DeprFlag</c> is equal to <c>next_major_release</c>,
                calls to functions to be removed in the next major release
                or in the next version are returned.</p></item>
              <item><p>If <c>DeprFlag</c> is equal to <c>eventually</c>, all
                calls to functions to be removed are returned, including calls
                to functions to be removed in the next version or the next
                major release.</p></item>
            </list>
          </item>
          <tag><c>deprecated_functions</c></tag>
          <item><p>Returns a list of externally used deprecated
            functions.</p></item>
          <tag><c>{deprecated_functions, DeprFlag}</c></tag>
          <item><p>Returns a list of externally used deprecated functions.</p>
            <list type="bulleted">
              <item><p>If <c>DeprFlag</c> is equal to <c>next_version</c>,
                functions to be removed in the next version are returned.</p>
              </item>
              <item><p>If <c>DeprFlag</c> is equal to <c>next_major_release</c>,
                functions to be removed in the next major release or in the
                next version are returned.</p></item>
              <item><p>If <c>DeprFlag</c> is equal to <c>eventually</c>, all
                functions to be removed are returned, including functions to be
                removed in the next version or the next major release.</p>
              </item>
            </list>
          </item>
          <tag><c>{call, FuncSpec}</c>(*)</tag>
          <item><p>Returns a list of functions called by some of the specified 
            functions.</p></item>
          <tag><c>{use, FuncSpec}</c>(*)</tag>
          <item><p>Returns a list of functions that use some of the specified
            functions.</p></item>
          <tag><c>{module_call, ModSpec}</c></tag>
          <item><p>Returns a list of modules called by some of the specified
            modules.</p></item>
          <tag><c>{module_use, ModSpec}</c></tag>
          <item><p>Returns a list of modules that use some of the specified
            modules.</p></item>
          <tag><c>{application_call, AppSpec}</c></tag>
          <item><p>Returns a list of applications called by some of the
            specified applications.</p></item>
          <tag><c>{application_use, AppSpec}</c></tag>
          <item><p>Returns a list of applications that use some of the
            specified applications.</p></item>
          <tag><c>{release_call, RelSpec}</c></tag>
          <item><p>Returns a list of releases called by some of the specified
            releases.</p></item>
          <tag><c>{release_use, RelSpec}</c></tag>
          <item><p>Returns a list of releases that use some of the specified
            releases.</p></item>
        </taglist>
      </desc>
    </func>

    <func>
      <name>d(Directory) -> [DebugInfoResult] | [NoDebugInfoResult] | Error</name>
      <fsummary>Checks the modules in a directory using the code path.</fsummary>
      <type>
        <v>Directory = directory()</v>
        <v>DebugInfoResult = {deprecated, [funcall()]} | {undefined, [funcall()]} | {unused, [mfa()]}</v>
        <v>Error = {error, module(), Reason}</v>
        <v>NoDebugInfoResult = {deprecated, [mfa()]} | {undefined, [mfa()]}</v>
        <v>Reason = {file_error, file(), error()} | {invalid_filename, term()} | {unrecognized_file, file()} | -&nbsp;error from beam_lib:chunks/2&nbsp;-</v>
      </type>
      <desc>
        <p>The modules found in the specified directory are checked for calls to
          <seealso marker="xref_chapter#deprecated_function">deprecated functions</seealso>,
          calls to
          <seealso marker="xref_chapter#undefined_function">undefined functions</seealso>,
          and for unused local functions. The code path is used as
          <seealso marker="xref_chapter#library_path">library path</seealso>.
          </p>
        <p>If some of the found Beam files contain
          <seealso marker="xref_chapter#debug_info">debug information</seealso>,
          those modules are checked and a list of tuples is returned. The
          first element of each tuple is one of the following:</p>
        <list type="bulleted">
          <item><p><c>deprecated</c> - The second element is a sorted list
            of calls to deprecated functions.</p></item>
          <item><p><c>undefined</c> - The second element is a sorted list
            of calls to undefined functions.</p></item>
          <item><p><c>unused</c> - The second element is a sorted list of
            unused local functions.</p></item>
        </list>
        <p>If no Beam file contains debug information, a list of
          tuples is returned. The first element of each tuple is one of
          the following:</p>
        <list type="bulleted">
          <item><p><c>deprecated</c> - The second element is a sorted list
            of externally used deprecated functions.</p></item>
          <item><p><c>undefined</c> - The second element is a sorted list
            of undefined functions.</p></item>
        </list>
      </desc>
    </func>

    <func>
      <name>forget(Xref) -> ok</name>
      <name>forget(Xref, Variables) -> ok | Error</name>
      <fsummary>Removes user variables and their values.</fsummary>
      <type>
        <v>Error = {error, module(), Reason}</v>
        <v>Reason = {not_user_variable, term()}</v>
        <v>Variables = [variable()] | variable()</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Removes all or some of the
          <seealso marker="xref_chapter#user_variable">user variables</seealso>
          of an
          <seealso marker="xref_chapter#xref_server">Xref server</seealso>.</p>
      </desc>
    </func>

    <func>
      <name>format_error(Error) -> Chars</name>
      <fsummary>Returns an English description of an Xref error reply.</fsummary>
      <type>
        <v>Error = {error, module(), term()}</v>
        <v>Chars = [char() | Chars]</v>
      </type>
      <desc>
        <p>Given the error returned by any function of this module,
          this function returns a descriptive string
          of the error in English. For file errors, the function
          <c>format_error/1</c> in module <c>file</c> is called.</p>
      </desc>
    </func>

    <func>
      <name>get_default(Xref) -> [{Option, Value}]</name>
      <name>get_default(Xref, Option) -> {ok, Value} | Error</name>
      <fsummary>Returns the default values of options.</fsummary>
      <type>
        <v>Error = {error, module(), Reason}</v>
        <v>Option = builtins | recurse | verbose | warnings</v>
        <v>Reason = {invalid_options, term()}</v>
        <v>Value = bool()</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Returns the default values of one or more options.</p>
      </desc>
    </func>

    <func>
      <name>get_library_path(Xref) -> {ok, LibraryPath}</name>
      <fsummary>Returns the library path.</fsummary>
      <type>
        <v>LibraryPath = library_path()</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Returns the
          <seealso marker="xref_chapter#library_path">library path</seealso>.
        </p>
      </desc>
    </func>

    <func>
      <name>info(Xref) -> [Info]</name>
      <name>info(Xref, Category) -> [{Item, [Info]}]</name>
      <name>info(Xref, Category, Items) ->  [{Item, [Info]}]</name>
      <fsummary>Returns information about an Xref server.</fsummary>
      <type>
        <v>Application = [] | [application()]</v>
        <v>Category = modules | applications | releases | libraries</v>
        <v>Info = {application, Application} | {builtins, bool()} | {directory, directory()} | {library_path, library_path()} | {mode, mode()} | {no_analyzed_modules, int()} | {no_applications, int()} | {no_calls, {NoResolved, NoUnresolved}} | {no_function_calls, {NoLocal, NoResolvedExternal, NoUnresolved}} | {no_functions, {NoLocal, NoExternal}} | {no_inter_function_calls, int()} | {no_releases, int()} | {release, Release} | {version, Version}</v>
        <v>Item = module() | application() | release() | library()</v>
        <v>Items = Item | [Item]</v>
        <v>NoLocal = NoExternal = NoResolvedExternal, NoResolved = NoUnresolved = int()</v>
        <v>Release = [] | [release()]</v>
        <v>Version = [int()]</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Returns information as a list of
          pairs {Tag,&nbsp;term()} in some order about the state and the
          <seealso marker="xref_chapter#module_data">module data</seealso>
          of an
          <seealso marker="xref_chapter#xref_server">Xref server</seealso>.</p>
        <p><c>info/1</c> returns information with the following tags
          (tags marked with (*) are available in <c>functions</c>
          mode only):</p>
        <taglist>
          <tag><c>library_path</c></tag>
          <item><p>The
            <seealso marker="xref_chapter#library_path">library path</seealso>.
            </p></item>
          <tag><c>mode</c></tag>
          <item><p>The <seealso marker="xref_chapter#mode">mode</seealso>.
            </p></item>
          <tag><c>no_releases</c></tag>
          <item><p>Number of releases.</p></item>
          <tag><c>no_applications</c></tag>
          <item><p>Total number of applications (of all releases).</p></item>
          <tag><c>no_analyzed_modules</c></tag>
          <item><p>Total number of
            <seealso marker="xref_chapter#analyzed_module">analyzed modules</seealso>.
            </p></item>
          <tag><c>no_calls</c> (*)</tag>
          <item><p>Total number of calls (in all modules), regarding instances
            of one function call in different lines as separate calls.</p>
          </item>
          <tag><c>no_function_calls</c> (*)</tag>
          <item><p>Total number of
            <seealso marker="xref_chapter#local_call">local calls</seealso>,
            resolved
            <seealso marker="xref_chapter#external_call">external calls</seealso>,
            and 
            <seealso marker="xref_chapter#unresolved_call">unresolved calls</seealso>.
            </p></item>
          <tag><c>no_functions</c> (*)</tag>
          <item><p>Total number of local and exported functions.</p></item>
          <tag><c>no_inter_function_calls</c> (*)</tag>
          <item><p>Total number of calls of the
            <seealso marker="xref_chapter#inter_call_graph">Inter Call Graph</seealso>.
            </p></item>
        </taglist>
        <p><c>info/2</c> and <c>info/3</c> return information about
          all or some of the analyzed modules, applications, releases,
          or library modules of an Xref server.
          The following information is returned for every analyzed module:</p>
        <taglist>
          <tag><c>application</c></tag>
          <item><p>An empty list if the module does not belong to any
            application, otherwise a list of the application names.</p></item>
          <tag><c>builtins</c></tag>
          <item><p>Whether calls to BIFs are included in the module
            data.</p></item>
          <tag><c>directory</c></tag>
          <item><p>The directory where the Beam file of the module is
            located.</p></item>
          <tag><c>no_calls</c> (*)</tag>
          <item><p>Number of calls, regarding instances of one function call
            in different lines as separate calls.</p></item>
          <tag><c>no_function_calls</c> (*)</tag>
          <item><p>Number of local calls, resolved external calls, and
            unresolved calls.</p></item>
          <tag><c>no_functions</c> (*)</tag>
          <item><p>Number of local and exported functions.</p></item>
          <tag><c>no_inter_function_calls</c> (*)</tag>
          <item><p>Number of calls of the Inter Call Graph.</p></item>
        </taglist>
        <p>The following information is returned for every application:</p>
        <taglist>
          <tag><c>directory</c></tag>
            <item><p>The directory where the Beam files of the
              modules are located.</p></item>
          <tag><c>no_analyzed_modules</c></tag>
          <item><p>Number of analyzed modules.</p></item>
          <tag><c>no_calls</c> (*)</tag>
          <item><p>Number of calls of the application modules, regarding
            instances of one function call in different lines as separate
            calls.</p></item>
          <tag><c>no_function_calls</c> (*)</tag>
          <item><p>Number of local calls, resolved external calls, and
            unresolved calls of the application modules.</p></item>
          <tag><c>no_functions</c> (*)</tag>
          <item><p>Number of local and exported functions of the application
            modules.</p></item>
          <tag><c>no_inter_function_calls</c> (*)</tag>
          <item><p>Number of calls of the Inter Call Graph of the application
            modules.</p></item>
          <tag><c>release</c></tag>
          <item><p>An empty list if the application does not belong to any
            release, otherwise a list of the release names.</p></item>
          <tag><c>version</c></tag>
          <item><p>The application version as a list of numbers. For example,
            the directory "kernel-2.6" results in the application name
            <c>kernel</c>, and the application version [2,6]; "kernel" yields
            the name <c>kernel</c> and the version <c>[]</c>.</p></item>
        </taglist>
        <p>The following information is returned for every release:</p>
        <taglist>
          <tag><c>directory</c></tag>
          <item><p>The release directory.</p></item>
          <tag><c>no_analyzed_modules</c></tag>
          <item><p>Number of analyzed modules.</p></item>
          <tag><c>no_applications</c></tag>
          <item><p>Number of applications.</p></item>
          <tag><c>no_calls</c> (*)</tag>
          <item><p>Number of calls of the modules of the release, regarding
            instances of one function call in different lines as separate
            calls.</p></item>
          <tag><c>no_function_calls</c> (*)</tag>
          <item><p>Number of local calls, resolved external calls, and
            unresolved calls of the modules of the release.</p></item>
          <tag><c>no_functions</c> (*)</tag>
          <item><p>Number of local and exported functions of the modules
            of the release.</p></item>
          <tag><c>no_inter_function_calls</c> (*)</tag>
          <item><p>Number of calls of the Inter Call Graph of the modules
            of the release.</p></item>
        </taglist>
        <p>The following information is returned for every library module:</p>
        <taglist>
        <tag><c>directory</c></tag>
        <item><p>The directory where the
          <seealso marker="xref_chapter#library_module">library module's</seealso>
          Beam file is located.</p></item>
        </taglist>
        <p>For every number of calls, functions, and so on, returned by the
          <c>no_</c> tags, a query returns the same number. Examples of such
          queries are listed in the following. Some of the queries return the
          sum of two or more <c>no_</c> tags numbers. <c>mod</c> (<c>app</c>,
          <c>rel</c>) refers to any module (application, release).</p>
        <taglist>
          <tag><c>no_analyzed_modules</c></tag>
          <item>
            <list type="bulleted">
              <item><c>"# AM"</c> (<c>info/1</c>)</item>
              <item><c>"# (Mod) app:App"</c> (application)</item>
              <item><c>"# (Mod) rel:Rel"</c> (release)</item>
            </list>
	  </item>
	  <tag><c>no_applications</c></tag>
          <item>
            <list type="bulleted">
              <item><c>"# A"</c> (<c>info/1</c>)</item>
            </list>
          </item>
          <tag><c>no_calls</c></tag>
          <item><p>The sum of the number of resolved and unresolved calls:</p>
            <list type="bulleted">
              <item><c>"# (XLin) E + # (LLin) E"</c> (<c>info/1</c>)</item>
              <item><c>"T = E | mod:Mod, # (LLin) T + # (XLin) T"</c>
               (module)</item>
              <item><c>"T = E | app:App, # (LLin) T + # (XLin) T"</c>
               (application)</item>
              <item><c>"T = E | rel:Rel, # (LLin) T + # (XLin) T"</c>
               (release)</item>
            </list>
          </item>
          <tag><c>no_functions</c></tag>
          <item><p>Functions in library modules and the functions
            <c>module_info/0,1</c> are not counted by <c>info</c>. Assuming
            that <c>"Extra := _:module_info/\"(0|1)\" + LM"</c> has been
            evaluated, the sum of the number of local and exported functions
            are as follows:</p>
            <list type="bulleted">
              <item><c>"# (F - Extra)"</c> (<c>info/1</c>)</item>
              <item><c>"# (F * mod:Mod - Extra)"</c> (module)</item>
              <item><c>"# (F * app:App - Extra)"</c> (application)</item>
              <item><c>"# (F * rel:Rel - Extra)"</c> (release)</item>
            </list>
          </item>
          <tag><c>no_function_calls</c></tag>
          <item><p>The sum of the number of local calls, resolved external
            calls, and unresolved calls:</p>
            <list type="bulleted">
              <item><c>"# LC + # XC"</c> (<c>info/1</c>)</item>
              <item><c>"# LC | mod:Mod + # XC | mod:Mod"</c> (module)</item>
              <item><c>"# LC | app:App + # XC | app:App"</c> (application)
              </item>
              <item><c>"# LC | rel:Rel + # XC | mod:Rel"</c> (release)</item>
            </list>
          </item>
          <tag><c>no_inter_function_calls</c></tag>
          <item>
            <list type="bulleted">
              <item><c>"# EE"</c> (<c>info/1</c>)</item>
              <item><c>"# EE | mod:Mod"</c> (module)</item>
              <item><c>"# EE | app:App"</c> (application)</item>
              <item><c>"# EE | rel:Rel"</c> (release)</item>
            </list>
          </item>
          <tag><c>no_releases</c></tag>
          <item>
            <list type="bulleted">
              <item><c>"# R"</c> (<c>info/1</c>)</item>
            </list>
          </item>
	</taglist>
      </desc>
    </func>

    <func>
      <name>m(Module) -> [DebugInfoResult] | [NoDebugInfoResult] | Error</name>
      <name>m(File) -> [DebugInfoResult] | [NoDebugInfoResult] | Error</name>
      <fsummary>Checks a module using the code path.</fsummary>
      <type>
        <v>DebugInfoResult = {deprecated, [funcall()]} | {undefined, [funcall()]} | {unused, [mfa()]}</v>
        <v>Error = {error, module(), Reason}</v>
        <v>File = file()</v>
        <v>Module = module()</v>
        <v>NoDebugInfoResult = {deprecated, [mfa()]} | {undefined, [mfa()]}</v>
        <v>Reason = {file_error, file(), error()} | {interpreted, module()} | {invalid_filename, term()} | {cover_compiled, module()} | {no_such_module, module()} | -&nbsp;error from beam_lib:chunks/2&nbsp;-</v>
      </type>
      <desc>
        <p>The specified Beam file (with or without extension <c>.beam</c>)
          or the file found by calling
          <c>code:which(Module)</c> is checked for calls to
          <seealso marker="xref_chapter#deprecated_function">deprecated functions</seealso>,
          calls to
          <seealso marker="xref_chapter#undefined_function">undefined functions</seealso>,
          and for unused local functions. The code path is used as
          <seealso marker="xref_chapter#library_path">library path</seealso>.
        </p>
        <p>If the Beam file contains
          <seealso marker="xref_chapter#debug_info">debug information</seealso>,
          a list of tuples is returned. The first element of each tuple
          is one of the following:</p>
        <list type="bulleted">
          <item><p><c>deprecated</c> - The second element is a sorted list
            of calls to deprecated functions.</p></item>
          <item><p><c>undefined</c> - The second element is a sorted list
            of calls to undefined functions.</p></item>
          <item><p><c>unused</c> - The second element is a sorted list of
            unused local functions.</p></item>
        </list>
        <p>If the Beam file does not contain debug information, a
          list of tuples is returned. The first element of each tuple
          is one of the following:</p>
        <list type="bulleted">
          <item><p><c>deprecated</c> - The second element is a sorted list
            of externally used deprecated functions.</p></item>
          <item><p><c>undefined</c> - The second element is a sorted list
            of undefined functions.</p></item>
        </list>
      </desc>
    </func>

    <func>
      <name>q(Xref, Query [, Options]) -> {ok, Answer} | Error</name>
      <fsummary>Evaluates a query.</fsummary>
      <type>
        <v>Answer = false | [constant()] | [Call] | [Component] | int() | [DefineAt] | [CallAt] | [AllLines]</v>
        <v>Call = call() | ComponentCall</v>
        <v>ComponentCall = {Component, Component}</v>
        <v>Component = [constant()]</v>
        <v>DefineAt = {mfa(), LineNumber}</v>
        <v>CallAt = {funcall(), LineNumbers}</v>
        <v>AllLines = {{DefineAt, DefineAt}, LineNumbers}</v>
        <v>Error = {error, module(), Reason}</v>
        <v>LineNumbers = [LineNumber]</v>
        <v>LineNumber = int()</v>
        <v>Options = [Option] | Option</v>
        <v>Option = {verbose, bool()}</v>
        <v>Query = string() | atom()</v>
        <v>Reason = {invalid_options, term()} | {parse_error, string_position(), term()} | {type_error, string()} | {type_mismatch, string(), string()} | {unknown_analysis, term()} | {unknown_constant, string()} | {unknown_variable, variable()} | {variable_reassigned, string()}</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Evaluates a <seealso marker="xref_chapter#query">query</seealso>
          in the context of an
          <seealso marker="xref_chapter#xref_server">Xref server</seealso>
          and returns the value of the last
          statement. The syntax of the value depends on the expression as
          follows:</p>
        <list type="bulleted">
          <item><p>A set of calls is represented by a sorted list without
            duplicates of <c>call()</c>.</p></item>
          <item><p>A set of constants is represented by a sorted list
            without duplicates of <c>constant()</c>.</p></item>
          <item><p>A set of strongly connected components is a sorted list
            without duplicates of <c>Component</c>.</p></item>
          <item><p>A set of calls between strongly connected components is
            a sorted list without duplicates of <c>ComponentCall</c>.</p></item>
          <item><p>A chain of calls is represented by a list of
            <c>constant()</c>. The list contains the From vertex of every
            call and the To vertex of the last call.</p></item>
          <item><p>Operator <c>of</c> returns <c>false</c> if no chain
            of calls between the specified constants is found.</p></item>
          <item><p>The value of operator <c>closure</c> (the
            <c>digraph</c> representation) is represented by the atom
            <c>'closure()'</c>.</p></item>
          <item><p>A set of line numbered functions is represented by a sorted
            list without duplicates of <c>DefineAt</c>.</p></item>
          <item><p>A set of line numbered function calls is represented by
            a sorted list without duplicates of <c>CallAt</c>.</p></item>
          <item><p>A set of line numbered functions and function calls is
            represented by a sorted list without duplicates of
          <c>AllLines</c>.</p></item>
        </list>
        <p>For both <c>CallAt</c> and <c>AllLines</c>, it holds that for
          no list element is <c>LineNumbers</c> an empty list; such
          elements are removed. The constants of <c>component</c>
          and the integers of <c>LineNumbers</c> are sorted and without
          duplicates.</p>
      </desc>
    </func>

    <func>
      <name>remove_application(Xref, Applications) -> ok | Error</name>
      <fsummary>Removes applications and their modules.</fsummary>
      <type>
        <v>Applications = application() | [application()]</v>
        <v>Error = {error, module(), Reason}</v>
        <v>Reason = {no_such_application, application()}</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Removes applications and their modules and
          <seealso marker="xref_chapter#module_data">module data</seealso>
          from an
          <seealso marker="xref_chapter#xref_server">Xref server</seealso>.</p>
      </desc>
    </func>

    <func>
      <name>remove_module(Xref, Modules) -> ok | Error</name>
      <fsummary>Removes analyzed modules.</fsummary>
      <type>
        <v>Error = {error, module(), Reason}</v>
        <v>Modules = module() | [module()]</v>
        <v>Reason = {no_such_module, module()}</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Removes
          <seealso marker="xref_chapter#analyzed_module">analyzed modules</seealso>
          and
          <seealso marker="xref_chapter#module_data">module data</seealso>
          from an
          <seealso marker="xref_chapter#xref_server">Xref server</seealso>.</p>
      </desc>
    </func>

    <func>
      <name>remove_release(Xref, Releases) -> ok | Error</name>
      <fsummary>Removes releases and their applications and modules.</fsummary>
      <type>
        <v>Error = {error, module(), Reason}</v>
        <v>Reason = {no_such_release, release()}</v>
        <v>Releases = release() | [release()]</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Removes releases and their applications, modules, and
          <seealso marker="xref_chapter#module_data">module data</seealso>
          from an
          <seealso marker="xref_chapter#xref_server">Xref server</seealso>.</p>
      </desc>
    </func>

    <func>
      <name>replace_application(Xref, Application,  Directory [, Options]) -> {ok, application()} | Error</name>
      <fsummary>Replaces the modules of an application.</fsummary>
      <type>
        <v>Application = application()</v>
        <v>Directory = directory()</v>
        <v>Error = {error, module(), Reason}</v>
        <v>Options = [Option] | Option</v>
        <v>Option = {builtins, bool()} | {verbose, bool()} | {warnings, bool()}</v>
        <v>Reason = {no_such_application, application()} | -&nbsp;see&nbsp;also&nbsp;add_application&nbsp;-</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Replaces the modules of an application with other modules
          read from an application directory. Release membership of the
          application is retained. Notice that the application name
          is kept; the name of the specified directory is not used.</p>
      </desc>
    </func>

    <func>
      <name>replace_module(Xref, Module, File [, Options]) ->  {ok, module()} | Error</name>
      <fsummary>Replaces an analyzed module.</fsummary>
      <type>
        <v>Error = {error, module(), Reason}</v>
        <v>File = file()</v>
        <v>Module = module()</v>
        <v>Options = [Option] | Option</v>
        <v>Option = {verbose, bool()} | {warnings, bool()}</v>
        <v>ReadModule = module()</v>
        <v>Reason = {module_mismatch, module(), ReadModule} | {no_such_module, module()} | -&nbsp;see&nbsp;also&nbsp;add_module&nbsp;-</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Replaces
          <seealso marker="xref_chapter#module_data">module data</seealso>
          of an
          <seealso marker="xref_chapter#analyzed_module">analyzed module</seealso>
          with data read from a Beam file. Application membership of the
          module is retained, and so is the value of option
          <c>builtins</c> of the module. An error is returned
          if the name of the read module differs from the specified module.</p>
        <p>Function <c>update</c> is an alternative for updating
          module data of recompiled modules.</p>
      </desc>
    </func>

    <func>
      <name>set_default(Xref, Option, Value) -> {ok, OldValue} | Error</name>
      <name>set_default(Xref, OptionValues) -> ok | Error</name>
      <fsummary>Sets the default values of options.</fsummary>
      <type>
        <v>Error = {error, module(), Reason}</v>
        <v>OptionValues = [OptionValue] | OptionValue</v>
        <v>OptionValue = {Option, Value}</v>
        <v>Option = builtins | recurse | verbose | warnings</v>
        <v>Reason = {invalid_options, term()}</v>
        <v>Value = bool()</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Sets the default value of one or more options.
          The following options can be set this way:</p>
        <list type="bulleted">
          <item><c>builtins</c>, with initial default value <c>false</c></item>
          <item><c>recurse</c>, with initial default value <c>false</c></item>
          <item><c>verbose</c>, with initial default value <c>false</c></item>
          <item><c>warnings</c>, with initial default value <c>true</c></item>
        </list>
        <p>The initial default values are set when creating an
          <seealso marker="xref_chapter#xref_server">Xref server</seealso>.</p>
      </desc>
    </func>

    <func>
      <name>set_library_path(Xref, LibraryPath [, Options]) ->  ok | Error</name>
      <fsummary>Sets the library path and finds the library modules.</fsummary>
      <type>
        <v>Error = {error, module(), Reason}</v>
        <v>LibraryPath = library_path()</v>
        <v>Options = [Option] | Option</v>
        <v>Option = {verbose, bool()}</v>
        <v>Reason = {invalid_options, term()} | {invalid_path, term()}</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Sets the
          <seealso marker="xref_chapter#library_path">library path</seealso>.
          If the specifed path is a list of directories, the set of
          <seealso marker="xref_chapter#library_module">library modules</seealso>
          is determined by selecting the first module
          encountered while traversing the directories in the specified
          order, for those modules that occur in more than
          one directory. By default, the library path is an empty list.</p>
        <p>The library path
          <marker id="code_path"></marker>
          <c>code_path</c> is used by functions
          <c>m/1</c> and <c>d/1</c>, but can also be set explicitly.
          Notice that the code path is traversed once for each used
          <seealso marker="xref_chapter#library_module">library module</seealso>
          while setting up module data.
          However, if only a few modules are
          used but not analyzed, using <c>code_path</c> can be faster
          than setting the library path to <c>code:get_path()</c>.</p>
        <p>If the library path is set to <c>code_path</c>, the set of
          library modules is not determined, and the <c>info</c>
          functions return empty lists of library modules.</p>
      </desc>
    </func>

    <func>
      <name>start(NameOrOptions) -> Return</name>
      <fsummary>Creates an Xref server.</fsummary>
      <type>
        <v>NameOrOptions = Name | Options</v>
        <v>Name = atom()</v>
        <v>Options = [Option] | Option</v>
        <v>Option = {xref_mode, mode()} | term()</v>
        <v>Return = {ok, pid()} | {error, {already_started, pid()}}</v>
      </type>
      <desc>
        <p>Creates an <seealso marker="xref_chapter#xref_server">xref server</seealso>.
          Optionally, a name can be specified for the process.
          The default <seealso marker="xref_chapter#mode">mode</seealso> is
          <c>functions</c>. Options that are not recognized by Xref
          are passed on to
          <seealso marker="stdlib:gen_server#start/4"><c>gen_server:start/4</c></seealso>.
        </p>
      </desc>
    </func>

    <func>
      <name>start(Name, Options) -> Return</name>
      <fsummary>Creates an Xref server.</fsummary>
      <type>
        <v>Name = atom()</v>
        <v>Options = [Option] | Option</v>
        <v>Option = {xref_mode, mode()} | term()</v>
        <v>Return = {ok, pid()} | {error, {already_started, pid()}}</v>
      </type>
      <desc>
        <p>Creates an <seealso marker="xref_chapter#xref_server">Xref server</seealso>
          with a specified name. The default
          <seealso marker="xref_chapter#mode">mode</seealso> is
          <c>functions</c>. Options that are not recognized by Xref
          are passed on to
          <seealso marker="stdlib:gen_server#start/4"><c>gen_server:start/4</c></seealso>.
        </p>
      </desc>
    </func>

    <func>
      <name>stop(Xref)</name>
      <fsummary>Deletes an Xref server.</fsummary>
      <type>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Stops an <seealso marker="xref_chapter#xref_server">Xref server</seealso>.
        </p>
      </desc>
    </func>

    <func>
      <name>update(Xref [, Options]) -> {ok, Modules} | Error</name>
      <fsummary>Replaces newly compiled analyzed modules.</fsummary>
      <type>
        <v>Error = {error, module(), Reason}</v>
        <v>Modules = [module()]</v>
        <v>Options = [Option] | Option</v>
        <v>Option = {verbose, bool()} | {warnings, bool()}</v>
        <v>Reason = {invalid_options, term()} | {module_mismatch, module(), ReadModule} | -&nbsp;see&nbsp;also&nbsp;add_module&nbsp;-</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Replaces the <seealso marker="xref_chapter#module_data">module data</seealso>
          of all
          <seealso marker="xref_chapter#analyzed_module">analyzed modules'</seealso>
          Beam files that are modified since they were last read by an
          <c>add</c> function or <c>update</c>. Application membership
          of the modules is retained, and so is the value of option
          <c>builtins</c>. Returns a sorted list
          of the names of the replaced modules.</p>
      </desc>
    </func>

    <func>
      <name>variables(Xref [, Options]) -> {ok, [VariableInfo]}</name>
      <fsummary>Returns the names of variables.</fsummary>
      <type>
        <v>Options = [Option] | Option</v>
        <v>Option = predefined | user | {verbose, bool()}</v>
        <v>Reason = {invalid_options, term()}</v>
        <v>VariableInfo = {predefined, [variable()]} | {user, [variable()]}</v>
        <v>Xref = xref()</v>
      </type>
      <desc>
        <p>Returns a sorted lists of the names of the variables of an
          <seealso marker="xref_chapter#xref_server">Xref server</seealso>.
          The default is to return the
          <seealso marker="xref_chapter#user_variable">user variables</seealso> only.
        </p>
      </desc>
    </func>
  </funcs>

  <section>
    <title>See Also</title><p>
      <seealso marker="stdlib:beam_lib"><c>stdlib:beam_lib(3)</c></seealso>,
      <seealso marker="stdlib:digraph"><c>stdlib:digraph(3)</c></seealso>,
      <seealso marker="stdlib:digraph_utils"><c>stdlib:digraph_utils(3)</c></seealso>,
      <seealso marker="stdlib:re"><c>stdlib:re(3)</c></seealso></p>
  </section>
</erlref>

