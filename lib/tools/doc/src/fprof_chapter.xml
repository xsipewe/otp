<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE chapter SYSTEM "chapter.dtd">

<chapter>
  <header>
    <copyright>
      <year>2001</year><year>2013</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    
    </legalnotice>

    <title>Fprof - File Trace Profiler</title>
    <prepared>Raimo Niskanen</prepared>
    <responsible>nobody</responsible>
    <docno></docno>
    <approved>nobody</approved>
    <checked>no</checked>
    <date>2001-08-14</date>
    <rev>PA1</rev>
    <file>fprof_chapter.xml</file>
  </header>
  <p>Fprof is a profiling tool that can be used to determine
    how much processing time different functions consumes and in which
    processes.</p>
  <p>This tool uses tracing with time stamps to collect profiling
    data. There is therefore no need for special compilation of
    modules to be profiled.</p>
  <p>Wall clock times from the host machine OS are presented by
    Fprof, with the assumption that OS scheduling randomly loads the
    profiled functions in a fair way. Both <em>own time</em> (the
    time used by a function for its own execution) and
    <em>accumulated time</em> (the execution time including called
    functions) are presented.</p>

  <section>
    <title>Main Profiling Steps</title> 
    <p>The three main steps for profiling are as follows:</p>
    <p><em>Step 1.</em> Tracing to file.</p>
    <p>The trace contains entries for function calls, returns to function,
      process scheduling, other process-related (spawn, and others) events,
      and garbage collection. All trace entries are time-stamped.</p>
    <p><em>Step 2.</em> Profiling.</p>
    <p>The trace file is read, the execution call stack is simulated, raw
      profile data is collected from the simulated call stack and the trace
      time-stamps, and the data is collected into an internal RAM storage
      on the node. The profile data is stored in the Fprof server
      state. During this step, the trace data can be dumped in text format
      to file or console.</p>
    <p><em>Step 3.</em> Analyzing.</p>
    <p>The raw profile data is sorted, filtered, and dumped in text format
      to file or console. The text format is intended to be both readable
      for a human and parsable with the standard Erlang parsing tools.</p>
    <p>As Fprof uses trace to file, the runtime performance 
      degradation is minimized, but still far from negligible, especially
      for programs using the file system heavily by themselves. Where
      you place the trace file is also important, for example, on Solaris
      <c>/tmp</c> is often a good choice, but any NFS (network) mounted
      disk is a bad idea.</p>
    <p>Fprof can also skip the file step and trace to a tracer
      process of its own, which does the profiling in runtime.</p>
    <p>The following sections show some examples of profiling with Fprof.
      For details, see
      <seealso marker="fprof"><c>fprof(3)</c></seealso>.</p>
  </section>

  <section>
    <title>Profile from Source Code</title>
    <p>Do as follows:</p>
    <p><em>Step 1:</em> If you can edit and recompile the source code,
      it is convenient to insert <c>fprof:trace(start)</c> and
      <c>fprof:trace(stop)</c> before and after the code to be profiled.
      All spawned processes are also traced. If you want another filename
      than the default, use
       <seealso marker="fprof#trace"><c>fprof:trace(start, "my_fprof.trace")</c></seealso>.
    </p>
    <p><em>Step 2:</em> Read the trace file and create the raw profile data
      with
      <seealso marker="fprof#profile"><c>fprof:profile()</c></seealso> or
      <seealso marker="fprof#profile"><c>fprof:profile(file, "my_fprof.trace")</c></seealso>
      for non-default filename.</p>
    <p><em>Step 3:</em> Create an informative table dumped on the console
      using one of the following alternatives:</p>
    <list type="bulleted">
      <item><p><seealso marker="fprof#analyse"><c>fprof:analyse()</c></seealso>
      </p></item>
      <item><p>On file with
      <seealso marker="fprof#analyse"><c>fprof:analyse(dest, [])</c></seealso>
      </p></item>
      <item><p><seealso marker="fprof#analyse"><c>fprof:analyse([{dest, "my_fprof.analysis"}, {cols, 120}])</c></seealso>
        for a wider listing on non-default filename.</p></item>
    </list>
  </section>

  <section>
    <title>Profile a Function</title>
    <p>If you have a function that does the task that you want to
      profile, and the function returns when the profiling is to
      stop, it is convenient to use
      <seealso marker="fprof#apply"><c>fprof:apply(Module, Function, Args)</c></seealso>
      and the related for the tracing step.</p>
    <p>If the tracing is to continue after the function returns, for
      example, if it is a start function that spawns processes to be
      profiled,
      <seealso marker="fprof#apply"><c>fprof:apply(M, F, Args, [continue | OtherOpts])</c></seealso>
      can be used. The tracing must be stopped at a suitable later time using
      <c>fprof:trace(stop)</c>.</p>
  </section>

  <section>
    <title>Immediate Profiling</title>
    <p>Tracing can also be done immediately into the profiling
      process that creates the raw profile data. That is, to short
      circuit the tracing and profiling steps so that the file system
      is not used.</p>
    <p>Do something like this:</p>

    <pre>
{ok, Tracer} = fprof:profile(start),
fprof:trace([start, {tracer, Tracer}]),
%% Code to profile
fprof:trace(stop);</pre>

    <p>This puts less load on the file system, but much more on the
      Erlang runtime system.</p>
  </section>
</chapter>

