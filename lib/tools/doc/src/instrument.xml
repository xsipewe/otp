<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>1998</year><year>2013</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    
    </legalnotice>

    <title>instrument</title>
    <prepared>Arndt Jonasson</prepared>
    <responsible>Torbj&ouml;rn Johnsson</responsible>
    <docno>1</docno>
    <approved>Bj&ouml;rn Gustavsson</approved>
    <checked></checked>
    <date>1998-04-01</date>
    <rev>PA1</rev>
    <file>instrument.xml</file>
  </header>
  <module>instrument</module>
  <modulesummary>Analysis and utility functions for instrumentation.</modulesummary>
  <description>
    <p>The <c>instrument</c> module contains support for studying the resource
      use in an Erlang runtime system. Only the allocation of memory can be
      studied.</p>
    <note>
      <p>This module is experimental. The representations used
        and the functionality are likely to change in future releases.</p>
      <p>The <c>instrument</c> module interface was slightly changed in
        Erlang/OTP R9C.</p>
    </note>
    <p>To start an Erlang runtime system with instrumentation, use the
      <c>+Mi*</c> set of command-line arguments to the <c>erl</c> command, see
      <seealso marker="erts:erts_alloc"><c>erts:erts_alloc(3)</c></seealso>
      and
      <seealso marker="erts:erl"><c>erts:erl(1)</c></seealso>.</p>
    <p>The basic object of study in the case of memory allocation is a memory
      allocation map. It contains a list of descriptors for each allocated
      memory block. A descriptor is a 4-tuple:</p>

    <pre>
{TypeNo, Address, Size, PidDesc}</pre>

    <p>where:</p>
    <list type="bulleted">
      <item><p><c>TypeNo</c> is the memory block type number.</p></item>
      <item><p><c>Address</c> is its place in memory.</p></item>
      <item><p><c>Size</c> is its size, in bytes.</p></item>
      <item><p><c>PidDesc</c> is either a tuple <c>{X,Y,Z}</c> identifying
        the process executing when the block was allocated, or
        <c>undefined</c> if no process was executing. The pid tuple
        <c>{X,Y,Z}</c> can be transformed into a real pid with
        function <c>c:pid/3</c> (see
        <seealso marker="stdlib:c"><c>stdlib:c</c></seealso>.</p></item>
    </list>

    <p>Some details about memory allocation:</p>
    <list type="bulleted">
      <item><p>Memory blocks are allocated both on the heap segment and on
        other memory segments. This can cause the instrumentation
        functionality to report very large holes.</p></item>
      <item><p> The instrumentation functionality provides no support for
        distinguishing between holes between memory segments, and holes
        between allocated blocks inside memory segments.</p></item>
      <item><p>The current size of the process cannot be obtained from
        within Erlang, but can be obtained with one of the system statistics
        tools, for example, <c>ps</c> or <c>top</c>. The Solaris utility
        <c>pmap</c> can be useful. It reports currently mapped memory
        segments.</p></item>
      <item><p>Overhead for instrumentation:</p>
        <list type="bulleted">
          <item><p>When the emulator is started with flag
            <seealso marker="erts:erts_alloc#Mim"><c>+Mim true</c></seealso>,
            each block is preceded by a 24 bytes large header on a 32-bit
            machine and a 48 bytes large header on a 64-bit machine.</p></item>
          <item><p>When the emulator is started with flag
            <seealso marker="erts:erts_alloc#Mis"><c>+Mis true</c></seealso>,
            each block is preceded by an 8 bytes large header.</p></item>
          <item><p>These header sizes are used by the Erlang 5.3/OTP R9C
            emulator. Other versions of the emulator can use other header
            sizes.</p></item>
          <item><p>Function
            <seealso marker="#block_header_size/1"><c>block_header_size/1</c></seealso>
            can be used to retrieve the header size used for a specific
            memory allocation map. The time overhead for managing the
            instrumentation data is small.</p></item>
        </list>
      </item>
      <item><p>Sizes presented by the instrumentation functionality are
        (by the emulator) requested sizes, that is, instrumentation
        headers or headers used by allocators are not included.</p></item>
    </list>
  </description>

  <funcs>
    <func>
      <name>allocator_descr(MemoryData, TypeNo) -> AllocDescr | invalid_type | "unknown"</name>
      <fsummary>Returns an allocator description.</fsummary>
      <type>
        <v>MemoryData = {term(), AllocList}</v>
        <v>AllocList = [Desc]</v>
        <v>Desc = {int(), int(), int(), PidDesc}</v>
        <v>PidDesc = {int(), int(), int()} | undefined</v>
        <v>TypeNo = int()</v>
        <v>AllocDescr = atom() | string()</v>
      </type>
      <desc>
        <p>Returns the description of the allocator managing memory
          blocks of type number <c>TypeNo</c> used in <c>MemoryData</c>.
          Valid <c>TypeNo</c>s are in the range returned by function
          <seealso marker="#type_no_range/1"><c>type_no_range/1</c></seealso>
          on this specific memory allocation map. If <c>TypeNo</c> is an
          invalid integer, <c>invalid_type</c> is returned.</p>
      </desc>
    </func>

    <func>
      <name>block_header_size(MemoryData) -> int()</name>
      <fsummary>Returns the memory block header size used by the emulator
        that generated the memory allocation map.</fsummary>
      <type>
        <v>MemoryData = {term(), AllocList}</v>
        <v>AllocList = [Desc]</v>
        <v>Desc = {int(), int(), int(), PidDesc}</v>
        <v>PidDesc = {int(), int(), int()} | undefined</v>
      </type>
      <desc>
        <marker id="block_header_size_1"></marker>
        <p>Returns the memory block header size used by the
          emulator that generated the memory allocation map. The block
          header size can differ between different emulators.</p>
      </desc>
    </func>

    <func>
      <name>class_descr(MemoryData, TypeNo) -> ClassDescr | invalid_type | "unknown"</name>
      <fsummary>Returns an allocator description.</fsummary>
      <type>
        <v>MemoryData = {term(), AllocList}</v>
        <v>AllocList = [Desc]</v>
        <v>Desc = {int(), int(), int(), PidDesc}</v>
        <v>PidDesc = {int(), int(), int()} | undefined</v>
        <v>TypeNo = int()</v>
        <v>ClassDescr = atom() | string()</v>
      </type>
      <desc>
        <p>Returns the description of the class that type number
          <c>TypeNo</c> used in <c>MemoryData</c> belongs to.
          Valid <c>TypeNo</c>s are in the range returned by function
          <seealso marker="#type_no_range/1"><c>type_no_range/1</c></seealso>
          on this specific memory allocation map. If <c>TypeNo</c> is an
          invalid integer, <c>invalid_type</c> is returned.</p>
      </desc>
    </func>

    <func>
      <name>descr(MemoryData) -> DescrMemoryData</name>
      <fsummary>Replaces type numbers in memory allocation map with type
        descriptions.</fsummary>
      <type>
        <v>MemoryData = {term(), AllocList}</v>
        <v>AllocList = [Desc]</v>
        <v>Desc = {int(), int(), int(), PidDesc}</v>
        <v>PidDesc = {int(), int(), int()} | undefined</v>
        <v>DescrMemoryData = {term(), DescrAllocList}</v>
        <v>DescrAllocList = [DescrDesc]</v>
        <v>DescrDesc = {TypeDescr, int(), int(), DescrPidDesc}</v>
        <v>TypeDescr = atom() | string()</v>
        <v>DescrPidDesc = pid() | undefined</v>
      </type>
      <desc>
        <p>Returns a memory allocation map where the type numbers (first
          element of <c>Desc</c>) are replaced by type descriptions,
          and pid tuples (fourth element of <c>Desc</c>) are
          replaced by real pids.</p>
      </desc>
    </func>

    <func>
      <name>holes(MemoryData) -> ok</name>
      <fsummary>Prints the sizes of unused memory blocks.</fsummary>
      <type>
        <v>MemoryData = {term(), AllocList}</v>
        <v>AllocList = [Desc]</v>
        <v>Desc = {int(), int(), int(), PidDesc}</v>
        <v>PidDesc = {int(), int(), int()} | undefined</v>
      </type>
      <desc>
        <p>Prints the size of each hole (that is, the space between
          allocated blocks) on the terminal.</p>
        <note>
          <p>Very large holes are probably holes between memory segments.
            The memory allocation map must be sorted, see function
            <seealso marker="#sort/1"><c>sort/1</c></seealso>.</p>
        </note>
      </desc>
    </func>

    <func>
      <name>mem_limits(MemoryData) -> {Low, High}</name>
      <fsummary>Returns lowest and highest memory address used.</fsummary>
      <type>
        <v>MemoryData = {term(), AllocList}</v>
        <v>AllocList = [Desc]</v>
        <v>Desc = {int(), int(), int(), PidDesc}</v>
        <v>PidDesc = {int(), int(), int()} | undefined</v>
        <v>Low = High = int()</v>
      </type>
      <desc>
        <p>Returns a tuple, <c>{Low, High}</c>, indicating
          the lowest and highest memory address used.
          The memory allocation map must be sorted, see function
          <seealso marker="#sort/1"><c>sort/1</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>memory_data() -> MemoryData | false</name>
      <fsummary>Returns the current memory allocation map.</fsummary>
      <type>
        <v>MemoryData = {term(), AllocList}</v>
        <v>AllocList = [Desc]</v>
        <v>Desc = {int(), int(), int(), PidDesc}</v>
        <v>PidDesc = {int(), int(), int()} | undefined</v>
      </type>
      <desc>
        <p>Returns <c>MemoryData</c> (the memory allocation map)
          if the emulator is started with command-line argument
          <c>+Mim true</c>, otherwise <c>false</c> is returned.</p>
        <note>
          <p><c>memory_data/0</c> blocks execution of other processes while
          the data is collected. The time it takes to collect the data can
          be substantial.</p>
        </note>
      </desc>
    </func>

    <func>
      <name>memory_status(StatusType) -> [StatusInfo] | false</name>
      <fsummary>Returns the current memory allocation status.</fsummary>
      <type>
        <v>StatusType = total | allocators | classes | types</v>
        <v>StatusInfo = {About, [Info]}</v>
        <v>About = atom()</v>
        <v>Info = {InfoName, Current, MaxSinceLast, MaxEver}</v>
        <v>InfoName = sizes|blocks</v>
        <v>Current = int()</v>
        <v>MaxSinceLast = int()</v>
        <v>MaxEver = int()</v>
      </type>
      <desc>
        <p>Returns a list of <c>StatusInfo</c> if the emulator is
          started with command-line argument <c>+Mis true</c> or
          <c>+Mim true</c>, otherwise <c>false</c> is returned.</p>
        <p>For a description of term <c>StatusInfo</c>, see function
          <seealso marker="#read_memory_status/1"><c>read_memory_status/1</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>read_memory_data(File) -> MemoryData | {error, Reason}</name>
      <fsummary>Reads a memory allocation map.</fsummary>
      <type>
        <v>File = string()</v>
        <v>MemoryData = {term(), AllocList}</v>
        <v>AllocList = [Desc]</v>
        <v>Desc = {int(), int(), int(), PidDesc}</v>
        <v>PidDesc = {int(), int(), int()} | undefined</v>
      </type>
      <desc>
        <marker id="read_memory_data_1"></marker>
        <p>Reads a memory allocation map from file <c>File</c> and
          returns it. The file is assumed to be created by function
          <seealso marker="#store_memory_data-1"><c>store_memory_data/1</c></seealso>.
          The error codes are the same as for function <c>file:consult/1</c>,
          see
          <seealso marker="kernel:file"><c>kernel:file(3)</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>read_memory_status(File) -> MemoryStatus | {error, Reason}</name>
      <fsummary>Reads memory allocation status from a file.</fsummary>
      <type>
        <v>File = string()</v>
        <v>MemoryStatus = [{StatusType, [StatusInfo]}]</v>
        <v>StatusType = total | allocators | classes | types</v>
        <v>StatusInfo = {About, [Info]}</v>
        <v>About = atom()</v>
        <v>Info = {InfoName, Current, MaxSinceLast, MaxEver}</v>
        <v>InfoName = sizes|blocks</v>
        <v>Current = int()</v>
        <v>MaxSinceLast = int()</v>
        <v>MaxEver = int()</v>
      </type>
      <desc>
        <marker id="read_memory_status_1"></marker>
        <p>Reads memory allocation status from file <c>File</c> and
          returns it. The file is assumed to be created by function
          <seealso marker="#store_memory_status-1"><c>store_memory_status/1</c></seealso>.
          The error codes are the same as for function <c>file:consult/1</c>,
          see
          <seealso marker="kernel:file"><c>kernel:file(3)</c></seealso>.</p>
        <p><c>About</c> depends on <c>StatusType</c> as follows:</p>
        <list type="bulleted">
          <item><p>When <c>StatusType</c> is <c>allocators</c>, <c>About</c>
            is the allocator that the information is about.</p></item>
          <item><p>When <c>StatusType</c> is <c>types</c>, <c>About</c> is
            the memory block type that the information is about. Memory
            block types are not described other than by their name and can
            vary between emulators.</p></item>
          <item><p> When <c>StatusType</c> is <c>classes</c>, <c>About</c>
            is the memory block type class that information is presented
            about.</p></item>
          </list>
          <p>Memory block types are classified after their use. The following
            classes exist:</p>
        <taglist>
          <tag><c>process_data</c></tag>
          <item><p>Erlang process-specific data.</p></item>
          <tag><c>binary_data</c></tag>
          <item><p>Erlang binaries.</p></item>
          <tag><c>atom_data</c></tag>
          <item><p>Erlang atoms.</p></item>
          <tag><c>code_data</c></tag>
          <item><p>Erlang code.</p></item>
          <tag><c>system_data</c></tag>
          <item><p>Other data used by the system.</p></item>
        </taglist>
        <p>When <c>InfoName</c> is <c>sizes</c>:</p>
        <list type="bulleted">
          <item><p><c>Current</c> is the current size.</p></item>
          <item><p><c>MaxSinceLast</c> is the maximum size since the last
            call to <c>store_memory_status/1</c> or <c>memory_status/1</c>
            with the specific <c>StatusType</c>.</p></item>
          <item><p><c>MaxEver</c> is the maximum size since the emulator
            was started.</p></item>
        </list>
        <p>When <c>InfoName</c> is <c>blocks</c>:</p>
        <list type="bulleted">
          <item><p><c>Current</c> is the current number of blocks.</p></item>
          <item><p><c>MaxSinceLast</c> is the maximum number of blocks since
            the last call to <c>store_memory_status/1</c> or
            <c>memory_status/1</c> with the specific <c>StatusType</c>.</p>
          </item>
          <item><p><c>MaxEver</c> is the maximum number of blocks since the
            emulator was started.</p></item>
        </list>
        <note>
          <p>A memory block is accounted for at "the first level" allocator.
            For example, <c>fix_alloc</c> allocates its memory pools through
            <c>ll_alloc</c>. When a <c>fix_alloc</c> block is allocated, the
            block or the pool in which it resides are not accounted for as
            memory allocated through <c>ll_alloc</c> even though it is.</p>
        </note>
      </desc>
    </func>

    <func>
      <name>sort(MemoryData) -> MemoryData</name>
      <fsummary>Sorts memory allocation list.</fsummary>
      <type>
        <v>MemoryData = {term(), AllocList}</v>
        <v>AllocList = [Desc]</v>
        <v>Desc = {int(), int(), int(), PidDesc}</v>
        <v>PidDesc = {int(), int(), int()} | undefined</v>
      </type>
      <desc>
        <marker id="sort_1"></marker>
        <p>Sorts a memory allocation map in ascending address order.</p>
      </desc>
    </func>

    <func>
      <name>store_memory_data(File) -> true|false</name>
      <fsummary>Stores the current memory allocation map on a file.</fsummary>
      <type>
        <v>File = string()</v>
      </type>
      <desc>
        <p>Stores the current memory allocation map on file <c>File</c>.
          Returns <c>true</c> if the emulator is started with
          command-line argument <c>+Mim true</c>, and the map is successfully
          stored, otherwise <c>false</c> is returned. The file contents can
          later be read using function
          <seealso marker="#read_memory_data/1"><c>read_memory_data/1</c></seealso>.</p>
        <note>
          <p><c>store_memory_data/0</c> blocks execution of
            other processes while data is collected. The time it takes
            to collect the data can be substantial.</p>
        </note>
      </desc>
    </func>

    <func>
      <name>store_memory_status(File) -> true|false</name>
      <fsummary>Stores the current memory allocation status on a file.</fsummary>
      <type>
        <v>File = string()</v>
      </type>
      <desc>
        <p>Stores the current memory status on file <c>File</c>. Returns
          <c>true</c> if the emulator is started with command-line argument
          <c>+Mis true</c> or <c>+Mim true</c>, and the data is successfully
          stored, otherwise <c>false</c> is returned. The file contents can
          later be read using function
          <seealso marker="#read_memory_status/1"><c>read_memory_status/1</c></seealso>.</p>
      </desc>
    </func>

    <func>
      <name>sum_blocks(MemoryData) -> int()</name>
      <fsummary>Returns the total amount of memory used.</fsummary>
      <type>
        <v>MemoryData = {term(), AllocList}</v>
        <v>AllocList = [Desc]</v>
        <v>Desc = {int(), int(), int(), PidDesc}</v>
        <v>PidDesc = {int(), int(), int()} | undefined</v>
      </type>
      <desc>
        <p>Returns the total size of the memory blocks in the list.</p>
      </desc>
    </func>

    <func>
      <name>type_descr(MemoryData, TypeNo) -> TypeDescr | invalid_type</name>
      <fsummary>Returns a type description.</fsummary>
      <type>
        <v>MemoryData = {term(), AllocList}</v>
        <v>AllocList = [Desc]</v>
        <v>Desc = {int(), int(), int(), PidDesc}</v>
        <v>PidDesc = {int(), int(), int()} | undefined</v>
        <v>TypeNo = int()</v>
        <v>TypeDescr = atom() | string()</v>
      </type>
      <desc>
        <p>Returns the type description of a type number used in
          <c>MemoryData</c>. Valid <c>TypeNo</c>s are in the range returned
          by function
          <seealso marker="#type_no_range/1"><c>type_no_range/1</c></seealso>
          on this specific memory allocation map. If <c>TypeNo</c> is an
          invalid integer, <c>invalid_type</c> is returned.</p>
      </desc>
    </func>

    <func>
      <name>type_no_range(MemoryData) -> {Min, Max}</name>
      <fsummary>Returns the memory block type numbers.</fsummary>
      <type>
        <v>MemoryData = {term(), AllocList}</v>
        <v>AllocList = [Desc]</v>
        <v>Desc = {int(), int(), int(), PidDesc}</v>
        <v>PidDesc = {int(), int(), int()} | undefined</v>
        <v>Min = int()</v>
        <v>Max = int()</v>
      </type>
      <desc>
        <marker id="type_no_range_1"></marker>
        <p>Returns the memory block type number range used in
          <c>MemoryData</c>. If the memory allocation map is generated
          by an Erlang 5.3/OTP R9C or newer emulator, all integers <c>T</c>
          that satisfy <c>Min</c> &lt;= <c>T</c> &lt;= <c>Max</c> are
          valid type numbers. If the memory allocation map is generated
          by a pre-Erlang 5.3/OTP R9C emulator, all integers in the
          range are <em>not</em> valid type numbers.</p>
      </desc>
    </func>
  </funcs>

  <section>
    <title>See Also</title>
    <p><seealso marker="erts:erts_alloc"><c>erts:erts_alloc(3)</c></seealso>,
      <seealso marker="erts:erl"><c>erts:erl(1)</c></seealso>,
      <seealso marker="kernel:file"><c>kernel:file(3)</c></seealso>,
      <seealso marker="stdlib:c"><c>stdlib:c</c></seealso></p>
  </section>
</erlref>

