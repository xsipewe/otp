<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE chapter SYSTEM "chapter.dtd">

<chapter>
  <header>
    <copyright>
      <year>2001</year><year>2013</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    
    </legalnotice>

    <title>Cover - Coverage Analysis</title>
    <prepared></prepared>
    <docno></docno>
    <date></date>
    <rev></rev>
    <file>cover_chapter.xml</file>
  </header>
    <p>The Cover tool provides a set of functions for coverage
      analysis of Erlang programs, counting how many times each
      <seealso marker="#lines">executable line</seealso> is executed.</p>
    <p>Coverage analysis can be used to verify test cases, ensuring that
      all relevant code is covered, and can be helpful to find
      bottlenecks in the code.</p>

  <section>
    <title>Getting Started</title>
    <section>
      <title>Example</title>
      <p>Assume that a test case for the following program is to be
        verified:</p>

      <code type="none">
-module(channel).
-behaviour(gen_server).

-export([start_link/0,stop/0]).
-export([alloc/0,free/1]). % client interface
-export([init/1,handle_call/3,terminate/2]). % callback functions

start_link() ->
    gen_server:start_link({local,channel},channel,[],[]).

stop() ->
    gen_server:call(channel,stop).

%%%-Client interface functions-------------------------------------------

alloc() ->
    gen_server:call(channel,alloc).

free(Channel) ->
    gen_server:call(channel,{free,Channel}).

%%%-gen_server callback functions----------------------------------------

init(_Arg) ->
    {ok,channels()}.

handle_call(stop,Client,Channels) ->
    {stop,normal,ok,Channels};

handle_call(alloc,Client,Channels) ->
    {Ch,Channels2} = alloc(Channels),
    {reply,{ok,Ch},Channels2};

handle_call({free,Channel},Client,Channels) ->
    Channels2 = free(Channel,Channels),
    {reply,ok,Channels2}.

terminate(_Reason,Channels) ->
    ok.

%%%-Internal functions---------------------------------------------------

channels() ->
    [ch1,ch2,ch3].

alloc([Channel|Channels]) ->
    {Channel,Channels};
alloc([]) ->
    false.

free(Channel,Channels) ->
    [Channel|Channels].</code>

      <p>The test case is implemented as follows:</p>

      <code type="none">
-module(test).
-export([s/0]).

s() ->
    {ok,Pid} = channel:start_link(),
    {ok,Ch1} = channel:alloc(),
    ok = channel:free(Ch1),
    ok = channel:stop().</code>
    </section>

    <section>
      <title>Preparations</title>
      <p>To use this tool, the preparation steps are as follows:</p>
      <p><em>Step 1.</em> Start Cover:</p>

      <pre>
1> <input>cover:start().</input>
{ok,&lt;0.30.0>}</pre>

      <p>This spawns a process that owns the Cover database where
        all coverage data is stored.</p>
      <p><em>Step 2.</em></p>
      <p>To include other nodes in the coverage analysis, use
        <seealso marker="cover#start-1"><c>cover:start/1</c></seealso>.
        All Cover-compiled modules are then loaded
        on all nodes, and data from all nodes is summed up when
        analyzing. For simplicity, this example only involves the
        current node.</p>
      <p><em>Step 3.</em></p>
      <p>Before any analysis can start, the involved modules must be
        Cover-compiled:</p>

      <pre>
2> <input>cover:compile_module(channel).</input>
{ok,channel}</pre>

      <p>This means that some extra information is added
        to the module before it is compiled into a binary, which then
        is <seealso marker="#loading">loaded</seealso>. The source file of
        the module is not affected and no <c>.beam</c> file is created.</p>
      <p>Each time a function in the Cover-compiled module <c>channel</c>
        is called, information about the call is added to the Cover
        database.</p>
      <p><em>Step 4.</em></p>
      <p>Run the test case:</p>

      <pre>
3> <input>test:s().</input>
ok</pre>

      <p>Coverage analysis is performed by examining the contents of
        the Cover database. The output is determined by the
        following two parameters:</p>
      <taglist>
        <tag><c>Level</c></tag> 
        <item><p>Is either <c>module</c>, <c>function</c>, <c>clause</c>, or
          <c>line</c> and determines the level of the analysis.</p></item>
        <tag><c>Analysis</c></tag>
        <item><p>Is either <c>coverage</c> or <c>calls</c> and determines
          the type of the analysis.</p></item>
      </taglist>
    </section>

    <section>
      <title>Coverage Analysis</title>
      <p>Analysis of type <c>coverage</c> is used to determine how much of
        the code is executed and how much is not executed.
        Coverage is represented by a tuple <c>{Cov,NotCov}</c>, where
        <c>Cov</c> is the number of executable lines that are executed
        at least once, and <c>NotCov</c> is the number of executable lines
        that is not executed.</p>
      <p>If the analysis is made on module level, the result is given for
        the entire module as a tuple <c>{Module,{Cov,NotCov}}</c>:</p>

      <pre>
4> <input>cover:analyse(channel,coverage,module).</input>
{ok,{channel,{14,1}}}</pre>

      <p>For <c>channel</c>, the result shows that 14 lines in the module
        are covered and one line is not covered.</p>
      <p>If the analysis is made on function level, the result is given as
        a list of tuples <c>{Function,{Cov,NotCov}}</c>, one for each
        function in the module. A function is specified by its module name,
        function name, and arity:</p>

      <pre>
5> <input>cover:analyse(channel,coverage,function).</input>
{ok,[{{channel,start_link,0},{1,0}},
     {{channel,stop,0},{1,0}},
     {{channel,alloc,0},{1,0}},
     {{channel,free,1},{1,0}},
     {{channel,init,1},{1,0}},
     {{channel,handle_call,3},{5,0}},
     {{channel,terminate,2},{1,0}},
     {{channel,channels,0},{1,0}},
     {{channel,alloc,1},{1,1}},
     {{channel,free,2},{1,0}}]}</pre>

      <p>For <c>channel</c>, the result shows that the uncovered line is in
        function <c>channel:alloc/1</c>.</p>
      <p>If the analysis is made on clause level, the result is given as
        a list of tuples <c>{Clause,{Cov,NotCov}}</c>, one for each
        function clause in the module. A clause is specified by its module
        name, function name, arity, and position within the function
        definition:</p>

      <pre>
6> <input>cover:analyse(channel,coverage,clause).</input>
{ok,[{{channel,start_link,0,1},{1,0}},
     {{channel,stop,0,1},{1,0}},
     {{channel,alloc,0,1},{1,0}},
     {{channel,free,1,1},{1,0}},
     {{channel,init,1,1},{1,0}},
     {{channel,handle_call,3,1},{1,0}},
     {{channel,handle_call,3,2},{2,0}},
     {{channel,handle_call,3,3},{2,0}},
     {{channel,terminate,2,1},{1,0}},
     {{channel,channels,0,1},{1,0}},
     {{channel,alloc,1,1},{1,0}},
     {{channel,alloc,1,2},{0,1}},
     {{channel,free,2,1},{1,0}}]}</pre>

      <p>For <c>channel</c>, the result shows that the uncovered line is in
        the second clause of <c>channel:alloc/1</c>.</p>
      <p>Finally, if the analysis is made on line level, the result is given
        as a list of tuples <c>{Line,{Cov,NotCov}}</c>, one for each
        executable line in the source code. A line is specified by its
        module name and line number:</p>

      <pre>
7> <input>cover:analyse(channel,coverage,line).</input>
{ok,[{{channel,9},{1,0}},
     {{channel,12},{1,0}},
     {{channel,17},{1,0}},
     {{channel,20},{1,0}},
     {{channel,25},{1,0}},
     {{channel,28},{1,0}},
     {{channel,31},{1,0}},
     {{channel,32},{1,0}},
     {{channel,35},{1,0}},
     {{channel,36},{1,0}},
     {{channel,39},{1,0}},
     {{channel,44},{1,0}},
     {{channel,47},{1,0}},
     {{channel,49},{0,1}},
     {{channel,52},{1,0}}]}</pre>

      <p>For <c>channel</c>, the result shows that the uncovered line is
        line 49.</p>
    </section>

    <section>
      <title>Call Statistics</title>
      <p>Analysis of type <c>calls</c> is used to determine how many times
        something has been called and is represented by an integer
        <c>Calls</c>.</p>
      <p>If the analysis is made on module level, the result is given as a
        tuple <c>{Module,Calls}</c>. Here, <c>Calls</c> is the total number
        of calls to functions in the module:</p>

      <pre>
8> <input>cover:analyse(channel,calls,module).</input>
{ok,{channel,12}}</pre>

      <p>For <c>channel</c>, the result shows that a total of 12 calls
        are made to functions in the module.</p>
      <p>If the analysis is made on function level, the result is given as
        a list of tuples <c>{Function,Calls}</c>. Here, <c>Calls</c> is
        the number of calls to each function:</p>

      <pre>
9> <input>cover:analyse(channel,calls,function).</input>
{ok,[{{channel,start_link,0},1},
     {{channel,stop,0},1},
     {{channel,alloc,0},1},
     {{channel,free,1},1},
     {{channel,init,1},1},
     {{channel,handle_call,3},3},
     {{channel,terminate,2},1},
     {{channel,channels,0},1},
     {{channel,alloc,1},1},
     {{channel,free,2},1}]}</pre>

      <p>For <c>channel</c>, the result shows that <c>handle_call/3</c> is
        the most called function in the module (three calls). All other
        functions are called once.</p>
      <p>If the analysis is made on clause level, the result is given as
        a list of tuples <c>{Clause,Calls}</c>. Here, <c>Calls</c> is
        the number of calls to each function clause:</p>
 
     <pre>
10> <input>cover:analyse(channel,calls,clause).</input>
{ok,[{{channel,start_link,0,1},1},
     {{channel,stop,0,1},1},
     {{channel,alloc,0,1},1},
     {{channel,free,1,1},1},
     {{channel,init,1,1},1},
     {{channel,handle_call,3,1},1},
     {{channel,handle_call,3,2},1},
     {{channel,handle_call,3,3},1},
     {{channel,terminate,2,1},1},
     {{channel,channels,0,1},1},
     {{channel,alloc,1,1},1},
     {{channel,alloc,1,2},0},
     {{channel,free,2,1},1}]}</pre>

      <p>For <c>channel</c>, the result shows that all clauses are
        called once, except the second clause of <c>channel:alloc/1</c>
        that is not called at all.</p>
      <p>Finally, if the analysis is made on line level, the result is given
        as a list of tuples <c>{Line,Calls}</c>. Here, <c>Calls</c> is 
        the number of times each line has been executed:</p>

      <pre>
11> <input>cover:analyse(channel,calls,line).</input>
{ok,[{{channel,9},1},
     {{channel,12},1},
     {{channel,17},1},
     {{channel,20},1},
     {{channel,25},1},
     {{channel,28},1},
     {{channel,31},1},
     {{channel,32},1},
     {{channel,35},1},
     {{channel,36},1},
     {{channel,39},1},
     {{channel,44},1},
     {{channel,47},1},
     {{channel,49},0},
     {{channel,52},1}]}</pre>

      <p>For <c>channel</c>, the result shows that all lines are
        executed once, except line 49 that is not executed at all.</p>
    </section>

    <section>
      <title>Analysis to File</title>
      <p>A line level calls analysis of <c>channel</c> can be written to
        a file using
        <seealso marker="cover#analyse_to_file-1">cover:analyse_to_file/1</seealso>:
      </p>

      <pre>
12> <input>cover:analyse_to_file(channel).</input>
{ok,"channel.COVER.out"}</pre>

      <p>The function creates a copy of <c>channel.erl</c>, where it for
        each executable line is specified how many times that line is
        executed. The output file is named <c>channel.COVER.out</c>:</p>
 
     <pre>
File generated from channel.erl by COVER 2001-05-21 at 11:16:38

****************************************************************************

        |  -module(channel).
        |  -behaviour(gen_server).
        |  
        |  -export([start_link/0,stop/0]).
        |  -export([alloc/0,free/1]). % client interface
        |  -export([init/1,handle_call/3,terminate/2]). % callback functions
        |  
        |  start_link() ->
     1..|      gen_server:start_link({local,channel},channel,[],[]).
        |  
        |  stop() ->
     1..|      gen_server:call(channel,stop).
        |  
        |  %%%-Client interface functions------------------------------------
        |  
        |  alloc() ->
     1..|      gen_server:call(channel,alloc).
        |  
        |  free(Channel) ->
     1..|      gen_server:call(channel,{free,Channel}).
        |  
        |  %%%-gen_server callback functions---------------------------------
        |  
        |  init(_Arg) ->
     1..|      {ok,channels()}.
        |  
        |  handle_call(stop,Client,Channels) ->
     1..|      {stop,normal,ok,Channels};
        |  
        |  handle_call(alloc,Client,Channels) ->
     1..|      {Ch,Channels2} = alloc(Channels),
     1..|      {reply,{ok,Ch},Channels2};
        |  
        |  handle_call({free,Channel},Client,Channels) ->
     1..|      Channels2 = free(Channel,Channels),
     1..|      {reply,ok,Channels2}.
        |  
        |  terminate(_Reason,Channels) ->
     1..|      ok.
        |  
        |  %%%-Internal functions--------------------------------------------
        |  
        |  channels() ->
     1..|      [ch1,ch2,ch3].
        |  
        |  alloc([Channel|Channels]) ->
     1..|      {Channel,Channels};
        |  alloc([]) ->
     0..|      false.
        |  
        |  free(Channel,Channels) ->
     1..|      [Channel|Channels].</pre>
    </section>

    <section>
      <title>Conclusion</title>
      <p>By looking at the results from the analyses, it can be deducted
        that the test case does not cover the case when all channels are
        allocated and that <c>test.erl</c> must be extended accordingly.</p>
      <p>When the test case is corrected, a bug in <c>channel</c>
        can indeed be discovered.</p>
      <p>When the coverage analysis is ready, Cover is stopped and all
        Cover-compiled modules are
        <seealso marker="#loading">unloaded</seealso>.
        The code for <c>channel</c> is now loaded as usual from a
        <c>.beam</c> file in the current path:</p>
 
     <pre>
13> <input>code:which(channel).</input>
cover_compiled
14> <input>cover:stop().</input>
ok
15> <input>code:which(channel).</input>
"./channel.beam"</pre>
    </section>
  </section>

  <section>
    <title>Performance</title>
      <p>Execution of code in Cover-compiled modules is slower and
        more memory consuming than for regularly compiled modules. As the
        Cover database contains information about each executable
        line in each Cover-compiled module, performance decreases
        proportionally to the size and number of the Cover-compiled
        modules.</p>

      <p>To improve performance when analyzing Cover results, multiple
        calls to <seealso marker="cover#analyse-1"><c>cover:analyse</c></seealso>
        and
        <seealso marker="cover#analyse_to_file-1"><c>cover:analyse_to_file</c></seealso>
        can be done at once. The convenience function
        <seealso marker="cover#async_analyse_to_file-1"><c>cover:async_analyse_to_file</c></seealso> 
        can also be used.</p>
  </section>

  <section>
    <marker id="lines"></marker>
    <title>Executable Lines</title>
      <p>Cover uses the concept of <em>executable lines</em>, which is
        lines of code containing an executable expression, such as a matching or
        a function call. A blank line or a line containing a comment,
        function head, or pattern in a <c>case</c> statement or <c>receive</c>
        statement is not executable.</p>
      <p>In the following example, lines 2, 4, 6, 8, and 11 are executable
        lines:</p>

      <pre>
1: is_loaded(Module,Compiled) ->
2:   case get_file(Module,Compiled) of
3:     {ok,File} ->
4:       case code:which(Module) of
5:         ?TAG ->
6:           {loaded,File};
7:         _ ->
8:           unloaded
9:       end;
10:    false ->
11:      false
12:  end.</pre>
  </section>

  <section>
    <marker id="loading"></marker>
    <title>Code Loading Mechanism</title>
      <p>When a module is Cover-compiled, it is also loaded using
        the normal code loading mechanism of Erlang. This means that if a
        Cover-compiled module is reloaded during a Cover
        session, for example, using <c>c(Module)</c>, it is no longer
        Cover-compiled.</p>
      <p>To determine if a module is Cover-compiled (and still loaded), use
        <seealso marker="cover#is_compiled-1"><c>cover:is_compiled/1</c></seealso>
        or
        <seealso marker="kernel:code#which"><c>code:which/1</c></seealso>.</p>
      <p>When Cover is stopped, all Cover-compiled modules
        are unloaded.</p>
  </section>

  <section>
    <title>Using the Web-Based User Interface</title>

    <section>
      <title>Introduction</title>
      <p>To ease the use of Cover, there is a web-based user interface
        to Cover called WebCover, which is designed to be started
        and used through WebTool. It is possible to cover-compile
        Erlang modules and to generate printable cover and call
        analyses through the web-based user interface.</p>
    </section>

    <section>
      <title>Start the Web-Based User Interface</title>
      <p>WebCover can be started in the following two ways:</p>
      <list type="bulleted">
        <item><p>Start WebTool, point a browser to the WebTool start page,
          and start WebCover from there.</p></item>
        <item><p>Use script <c>start_webtool</c> to start Webtool, WebCover,
           and a browser.</p></item>
      </list>
      <p>For more information, see the
        <seealso marker="webtool"><c>Webtool</c></seealso> application.</p>
      <p>WebCover is only compatible with Internet Explorer and Netscape
        Navigator 4.0 and higher.</p>
    </section>

    <section>
      <title>Navigating WebCover</title>
      <p>From the menu in the left-hand frame, the following pages can be
        selected:</p>
      <list type="bulleted">
        <item><p><c>Nodes</c></p>
          <p>Remote nodes can be added to participate in the
            coverage analysis. Coverage data from all involved nodes are then
            merged during the analysis.</p></item>
        <item><p><c>Compile</c></p>
          <p><c>.erl</c> or <c>.beam</c> files can be Cover-compiled.</p></item>
        <item><p><c>Import</c></p>
          <p>Coverage data from a previous analysis can be
            imported. Imported data is then merged with the current coverage
            data. Notice that only files with extension <c>.coverdata</c> can
            be imported.</p></item>
        <item><p><c>Result</c></p>
          <p>Coverage data can be analyzed, reset, or exported.</p></item>
      </list>
      <p>Follow the instructions on each page.</p>
    </section>
  </section>
</chapter>

