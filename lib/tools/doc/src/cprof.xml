<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>2002</year>
      <year>2013</year>
      <holder>Ericsson AB, All Rights Reserved</holder>
    </copyright>
    <legalnotice>
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
 
      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  The Initial Developer of the Original Code is Ericsson AB.
    </legalnotice>

    <title>cprof</title>
    <prepared>Raimo Niskanen</prepared>
    <responsible></responsible>
    <docno></docno>
    <approved></approved>
    <checked></checked>
    <date>2002-09-12</date>
    <rev>PA1</rev>
    <file>cprof.xml</file>
  </header>
  <module>cprof</module>
  <modulesummary>A simple call count profiling tool using breakpoints for
    minimal runtime performance impact.</modulesummary>
  <description>
    <p>The <c>cprof</c> module is used to profile a program
      to determine how many times different functions are called.
      Breakpoints similar to local call trace, but containing a
      counter, are used to minimize runtime performance impact.</p>
    <p>As breakpoints are used, there is no need for special
      compilation of any module to be profiled. These breakpoints
      can only be set on Beam code, so BIFs
      cannot be call count traced.</p>
    <p>The size of the call counters is the host machine word
      size. One bit is used when pausing the counter, so the maximum
      counter value for a 32-bit host is 2147483647.</p>
    <p>The profiling result is delivered as a term containing a
      sorted list of entries, one per module. Each module entry
      contains a sorted list of functions. The sorting order in both
      cases is of decreasing call count.</p>
    <p>Call count tracing is very lightweight compared to other forms
      of tracing, as no trace message has to be generated. Some
      measurements indicate performance degradation near 10%.</p>
    <marker id="analyse"></marker>
  </description>

  <funcs>
    <func>
      <name>analyse() -> {AllCallCount, ModAnalysisList}</name>
      <name>analyse(Limit) -> {AllCallCount, ModAnalysisList}</name>
      <name>analyse(Mod) -> ModAnalysis</name>
      <name>analyse(Mod, Limit) -> ModAnalysis</name>
      <fsummary>Collects and analyzes call counters.</fsummary>
      <type>
        <v>Limit = integer()</v>
        <v>Mod = atom()</v>
        <v>AllCallCount = integer()</v>
        <v>ModAnalysisList = [ModAnalysis]</v>
        <v>ModAnalysis = {Mod, ModCallCount, FuncAnalysisList}</v>
        <v>ModCallCount = integer()</v>
        <v>FuncAnalysisList = [{{Mod, Func, Arity}, FuncCallCount}]</v>
        <v>Func = atom()</v>
        <v>Arity = integer()</v>
        <v>FuncCallCount = integer()</v>
      </type>
      <desc>
        <p>Collects and analyzes the call counters presently in the
          node for module <c>Mod</c> or for all modules
          (except <c>cprof</c> itself), and returns the following:</p>
        <taglist>
          <tag><c>FuncAnalysisList</c></tag>
          <item><p>A list of tuples, one for each function in a module, in
           decreasing <c>FuncCallCount</c> order.</p></item>
          <tag><c>ModCallCount</c></tag>
          <item><p>The sum of <c>FuncCallCount</c> values for all
           functions in module <c>Mod</c>.</p></item>
          <tag><c>AllCallCount</c></tag>
          <item><p>The sum of <c>ModCallCount</c> values for all modules
           concerned in <c>ModAnalysisList</c>.</p></item>
          <tag><c>ModAnalysisList</c></tag>
          <item><p>A list of tuples, one for each module, except
          <c>cprof</c> itself, in decreasing <c>ModCallCount</c>
           order.</p></item>
        </taglist>
        <p>If call counters are still running while
          <c>analyse/0,1,2</c> is executing, you can get an
          inconsistent result. This occurs if the process executing
          <c>analyse/0,1,2</c> gets scheduled out, so some other process
          can increment the counters that are being analyzed, Calling
          <c>pause()</c> before analyzing solves the problem.</p>
        <p>If argument <c>Mod</c> is specified, the result contains a
          <c>ModAnalysis</c> tuple for module <c>Mod</c> only.
          Otherwise the result contains one <c>ModAnalysis</c> tuple
          for all modules returned from <c>code:all_loaded()</c>,
          except <c>cprof</c> itself.</p>
        <p>All functions with a <c>FuncCallCount</c> lower than
          <c>Limit</c> are excluded from <c>FuncAnalysisList</c>. They
          are still included in <c>ModCallCount</c>, though. 
          <c>Limit</c> defaults to <c>1</c>.</p>
      <marker id="pause_0"></marker>
      </desc>
    </func>

    <func>
      <name>pause() -> integer()</name>
      <fsummary>Pauses running call count trace for all functions.</fsummary>
      <desc>
        <p>Pauses call count tracing for all functions in all modules,
          and stops it for all functions in modules to be
          loaded. This is the same as
          <c>(pause({'_','_','_'})+stop({on_load}))</c>.</p>
        <p>See also
          <seealso marker="#pause"><c>pause/1,2,3</c></seealso>.</p>
      <marker id="pause"></marker>
      </desc>
    </func>

    <func>
      <name>pause(FuncSpec) -> integer()</name>
      <name>pause(Mod, Func) -> integer()</name>
      <name>pause(Mod, Func, Arity) -> integer()</name>
      <fsummary>Pauses running call count trace for matching functions.</fsummary>
      <type>
        <v>FuncSpec = Mod | {Mod,Func,Arity}, {FS}</v>
        <v>Mod = atom()</v>
        <v>Func = atom()</v>
        <v>Arity = integer()</v>
        <v>FS = term()</v>
      </type>
      <desc>
        <p>Pauses call counters for matching functions in matching
          modules. Argument <c>FS</c> can be used to
          specify the first argument to
          <c>erlang:trace_pattern/3</c>, see
          <seealso marker="kernel:erlang"><c>kernel:erlang(3)</c></seealso>.</p>
        <p>The call counters for all matching functions that
          have call count breakpoints are paused at their current
          count.</p>
        <p>Returns the number of matching functions that can have
          call count breakpoints, the same as
          <seealso marker="#start_0"><c>start/0,1,2,3</c></seealso>
          would have returned with the same arguments.</p>
      <marker id="restart"></marker>
      </desc>
    </func>

    <func>
      <name>restart() -> integer()</name>
      <name>restart(FuncSpec) -> integer()</name>
      <name>restart(Mod, Func) -> integer()</name>
      <name>restart(Mod, Func, Arity) -> integer()</name>
      <fsummary>Restarts existing call counters for matching functions.</fsummary>
      <type>
        <v>FuncSpec = Mod | {Mod,Func,Arity}, {FS}</v>
        <v>Mod = atom()</v>
        <v>Func = atom()</v>
        <v>Arity = integer()</v>
        <v>FS = term()</v>
      </type>
      <desc>
        <p>Restarts call counters for the matching functions in
          matching modules that are call count traced. Argument <c>FS</c>
          can be used to specify the first argument to
          <c>erlang:trace_pattern/3</c>, see
          <seealso marker="kernel:erlang"><c>kernel:erlang(3)</c></seealso>.</p>
        <p>The call counters for all matching functions that have
          call count breakpoints are set to zero and running.</p>
        <p>Returns the number of matching functions that can have
          call count breakpoints, the same as
          <seealso marker="#start_0"><c>start/0,1,2,3</c></seealso>
          would have returned with the same arguments.</p>
      <marker id="start_0"></marker>
      </desc>
    </func>

    <func>
      <name>start() -> integer()</name>
      <fsummary>Starts call count tracing for all functions.</fsummary>
      <desc>
        <p>Starts call count tracing for all functions in all modules, 
          and for all functions in modules to be
          loaded. This is the same as 
          <c>(start({'_','_','_'})+start({on_load}))</c>.</p>
        <p>See also
          <seealso marker="#start"><c>start/1,2,3</c></seealso>.</p>
      <marker id="start"></marker>
      </desc>
    </func>

    <func>
      <name>start(FuncSpec) -> integer()</name>
      <name>start(Mod, Func) -> integer()</name>
      <name>start(Mod, Func, Arity) -> integer()</name>
      <fsummary>Starts call count tracing for matching functions.</fsummary>
      <type>
        <v>FuncSpec = Mod | {Mod,Func,Arity}, {FS}</v>
        <v>Mod = atom()</v>
        <v>Func = atom()</v>
        <v>Arity = integer()</v>
        <v>FS = term()</v>
      </type>
      <desc>
        <p>Starts call count tracing for matching functions in matching
          modules. Argument <c>FS</c> can be used to specify the
          first argument to <c>erlang:trace_pattern/3</c>, for example,
          <c>on_load</c>, see
          <seealso marker="kernel:erlang"><c>kernel:erlang(3)</c></seealso>.</p>
        <p>Sets call count breakpoints on the matching functions that
          have no call count breakpoints. Call counters
          are set to zero and running for all matching functions.</p>
        <p>Returns the number of matching functions that have got
          call count breakpoints.</p>
      <marker id="stop_0"></marker>
      </desc>
    </func>

    <func>
      <name>stop() -> integer()</name>
      <fsummary>Stops call count tracing for all functions.</fsummary>
      <desc>
        <p>Stops call count tracing for all functions in all modules,
          and for all functions in modules to be
          loaded. This is the same as 
          <c>(stop({'_','_','_'})+stop({on_load}))</c>.</p>
        <p>See also
          <seealso marker="#stop"><c>stop/1,2,3</c></seealso>.</p>
      <marker id="stop"></marker>
      </desc>
    </func>

    <func>
      <name>stop(FuncSpec) -> integer()</name>
      <name>stop(Mod, Func) -> integer()</name>
      <name>stop(Mod, Func, Arity) -> integer()</name>
      <fsummary>Stops call count tracing for matching functions.</fsummary>
      <type>
        <v>FuncSpec = Mod | {Mod,Func,Arity}, {FS}</v>
        <v>Mod = atom()</v>
        <v>Func = atom()</v>
        <v>Arity = integer()</v>
        <v>FS = term()</v>
      </type>
      <desc>
        <p>Stops call count tracing for matching functions in matching 
          modules. Argument <c>FS</c> can be used to specify the
          first argument to <c>erlang:trace_pattern/3</c>, for example,
          <c>on_load</c>, see
          <seealso marker="kernel:erlang"><c>kernel:erlang(3)</c></seealso>.</p>
        <p>Removes call count breakpoints from the matching functions that
          have call count breakpoints.</p>
        <p>Returns the number of matching functions that can have
          call count breakpoints, the same as
          <seealso marker="#start_0"><c>start/0,1,2,3</c></seealso>
          would have returned with the same arguments.</p>
      </desc>
    </func>
  </funcs>

  <section>
    <title>See Also</title>
    <p><seealso marker="eprof"><c>eprof(3)</c></seealso>, 
      <seealso marker="fprof"><c>fprof(3)</c></seealso>,
      <seealso marker="kernel:erlang"><c>kernel:erlang(3)</c></seealso></p>
  </section>
</erlref>

